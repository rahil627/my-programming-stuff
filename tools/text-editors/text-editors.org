

* what i want
sane defaults
  - don't want to waste time configing all day, need to focus! (focus, textbringer)
  - if not, have a tasteful, un-bloated shared config set-up (doom)
inuititive learning experience
  - quick to re-learn and jump deep into again (focus)
a good non-modal editing experience
  - if modal, a useful main editing/insert mode (*angry face at helix*)
not slow / heavy
  - (helix and focus editor have spoiled me..)
  - native gui
    - though terminal editors may be ok.. now with gpu-powered terminal emulator apps (wezterm)

extra:
a simple way to write extensions
  - (hmm, this may limit it to dynamic langs..)
  - (well, kakoune found an indirect way..)
  - if not perhaps provide running a shell command on the region
  - at least provide running a reg-ex replacement/substitution, interactive
uses a highly dynamic/interactive scripting language
  - bonus points if it's ruby, being the best and most ideal dynamic lang
unrestrictive
  - see the "four pillars" below

a decent community?
  - *the LSP requires quite a bit of effort for each text editor AND for each language, as one must create an interface between the text editor and each language's language-server*, thus a healthy dev community is required to maintain them all
    - TODO: i think..
    - furthermore, languages with introspection can be implemented without the lsp (such as the way emacs handles)
    - *this is kinda make it or break it.. i can't live without completions!! :/*
      - but for game programming, it might be alright, as i'd mostly be using functions and data i created..
  - hence, bustling dev communities have a greater chance of building open-source contributor momentum than others
    - (rust, js, python, ruby, go: various rust editors, vs-code, sublime text, textbringer, micro)
  - however, *if it's written in a language that i like, such a ruby, haxe, or jai, then i'd be more compelled to write whatever i need*
    - thus, i'd LOVE helpin' with textbringer (and perhaps adding a few bare necessities to focus editor too!), but i may have to resort to ai generation for emacs (and emacs lisp), and i'd def struggle with rust editors..!


** the four pillars
https://www.reddit.com/r/emacs/comments/124eyh6/things_your_editor_should_have_with_amir_rajan/
  - 1. can see the function when you press a button
  - 2. can set a key to a series of functions: a key-board macro
  - 3. **can create your own function**
    - the most important, as then there are no restrictions/limitations
  - 4. can see the source code
  additional pillars (by me):
  - 5. is completely hackable, down to the core (not merely api)
  - 6. has a good library eco-system
    - for easy plugin potential
  - 7. has simple C ffi / extensions (..or is made with rust..)
    - for vast plugin potential
    - (also for easier dev: no need to re-write tree-sitter, etc.)

  - tests:
    - vscode
      - probably? (maybe there's way to toggle this..), yes, **yes, but not simple** (have to write an "extension", which is quite a process..), sure (but hella complex), no
    - atom
      - TODO: was this actually "completely hackable"?
    - sublime
      - yes, yes, *yes (limited to api)*, *no?* (shareware)
    - helix
      - TODO: move this down with the main contenders..?
      - no (can request 'n discuss), yes, **not yet (but even then, limited to the api/interface provided to the scripting lang)**, yes, sorta (limited to api)

    these generally pass the four pillars, even the fifth(!):
    1. **textbringer**
       - *passes all pillars*
       - *the program itself is entirely written in ruby*, though certain libs/gems may use "C extensions" for high-performance bits (and just plain solid libs?)
       - has the wild potential of ruby libs
       - has the vast potential of C libs
         - TODO: C ffi vs C extensions?
           - it's probably a good idea to limit what is exposed for each C lib anyway..
    2. **lem**
       - *passes all pillars*
       - *entirely written in common lisp, thus perhaps the only editor (listed here) to claim to be "completely hackable"*
       - not the best library eco-system, but possibly the best one in the lisp world
       - common lisp has C ffi
         - though, that does make things complicated..
    3. **emacs**
       - doesn't pass the extra pillars, but is so exceptional that it forced everyone to write in it's own language!
       - now has *"C modules" (as emacs-lisp doesn't have any C-ffi)
         - though if it can be done in emacs lisp, that is highly-recommended..
       - now has native compilation
         - TODO: is this truly native, or just bytecode??
       - TODO: how does parainfer-rust-mode work?? just a binary?
       - a bit of the core is written in C
         - most of it being the lisp compiler
           - which may one day be ported to guile compiler
             - which then would enable running code in various prog langs
               - that would be wild.. emacs just gets better 'n better..!!


* conclusion

z. focus, *the new notepad.exe*, to just simply write/express, *zen*, *extremely fast*, *zero cognitive load*, and has *the most innovative design ideas*
  - a small project, written extremely well in jai, designed really well too (like a game designer)
  - *come back to this for text editor design (and programming?) ideas..*
  - def use once i get my hands on that game engine..

0. emacs (doom-meow), *for everything, 4 lyfe*
  - *restrict yourself to insert-mode for a more zen experience*
    - TODO: turn off normal-mode?

1. text-bringer, *for the love of ruby!! <3 <3*
  - *a cute little grassroots hobby project i feel i can contribute to, really make mine, and enjoy it too!*
    - *the project's scale is perfect: vanilla emacs, terminal only*: basically helix without the modal-mode, but instead of rust/scheme, all ruby!!
      - because it uses vanilla emacs as a base, it *complements well with doom-emacs*, without having to learn/remember another set of bindings, nor altering/configuring another set
  - would be really fun to write plugins for this.. considering its libs
  - *actually has unlimited potential*

t. helix, for a snappy batteries-included terminal editor with great defaults, including great default key-bindings and key-maps
  - STATUS: on hold until the scripting / plugin system comes out
    - keep it as *the default terminal editor* for now..
  - *has the potential and is in good position to compete with others once the scheme plugin system is out..*
    - taking it's sweet time to do this.. but has great leaders
  - great for crafting your own key-bindings

n. micro, just to replace nano
  - (only because focus doesn't work in the terminal)
  - (and because, unfortunately, textbringer/ruby sucks at packaging programs..)

d. zed (if not, vs-code), for a quick beautiful sane defaults complete ide, to focus on the work, and for ai workflows, and for multi-player


upcoming (buggy):
 lem, if you want to help re-make emacs in common lisp, or just *to try cl*
  - *has great potential.. with a good amount of contributers..*
  - it's also completely written completely in common lisp, likely making for a much cleaner code-base
  - unfortunately, i don't feel there's enough reason to create yet another lisp editor..
    - though, surely, the lisp people know better of the benefits of common lisp over emacs lisp than me..


that is all.



* the list

from simplest to most feature-ful (by default/out-of-the-box)

** TODO to try

who knows what ideas lie beyond..


also worth trying sublime text again..

*** hobby/passion projects <3
usually spear-headed by one person, in a more niche language, thus making it harder to build momentum

**** 4coder
  - part of the handmade-hero movement
    - therefore written in C, and also therefore **can potentially be extended using any programming langauge**


*** open-source momentum
has the momentum of bigger language-based-dev-communities

(empty)




*** other / experimental

is this even an editor..? or just some way to make use of small-talk??

**** glamourous toolkit
  - TODO: try it for the sake of smalltalk!!
  - kind of **the emacs of smalltalk**, but made in ~2020?, after 6 years of dev, 14 years of research
    - "It seems an editor/database query engine/[code] browser with a object oriented language Pharo as control/scripting language, while emacs is an editor with emacs-Lisp as the scripting language."
  - *the moldable development environment*: uses the features of smalltalk, especially it's built-in IDE, as tools to create your own specific applications: like for code-base exploration/documentation, build an editor, etc.
    - https://lepiter.io/feenk/what-exactly-is-glamorous-toolkit-v1-0--7sex44dze2dqlocqxwfz8ju0i/
      - "Our goal is to make systems explainable by means of custom tools created for each problem. Glamorous Toolkit makes this possible by making the creation of custom tools inexpensive and seamless."
      - "A central component in GT is Lepiter, the knowledge management system."
  - built on Pharo, though it's a project of it's own
    - renders crisply to retina displays compared to Pharo's native ui
    - "GToolkit uses a completely parallel graphics stack to standard Pharo. The VM and library ecosystem are still there but the UI is rebuilt from scratch on a modern vector based toolkit... The productivity of the GToolkit developers is impressive."















** stupid simple, fast editors

the future is simple
the future is stupid
less features
less learning
more writing

can learn EVERYTHING very quickly
  - ~5 minutes for micro, ~30 for focus

can use these anytime, and for anything, including simple text files

also great for just writing shit down (what else are text editors for..??), without distraction, without fighting with your editor

basically notepad (and nano) replacements

overview:
0. **focus (editor)**
  - NOTE: still early in dev
    - lsp in next version (0.4.0)
  - finally. a god damn text editor that doesn't slow down the marvel of contemporary machinery!! gamers make the best shit.
  - great little design nuances
  - themes suck
s. micro
   - the perfect replacement for nano
     - finally, something for writing *git commit logs*

*** focus (editor)
  - *the best text editor experience i've had in quite some time*.. made me try sublime text
  - *incredible speed, incredible defaults, incredibly simple, lives up to it's name and induces focus*
    - **learn everything in 5 minutes: find file via fuzzy search, set up workspaces, command prompt, config**
      - very well designed find file in workspace and open file via path
    - some sane defaults (and great sense of design) include:
      - great, simple key-bindings
      - infinite undo-history for all files during the session, even after closing it..??
      - *multiple cursors made simple, and intutive!*
        - when selecting text, if >= 3 chars, highlight matching text, c-d to add cursor to next highlighted matching text
        - also works well with the plain interactive search (select text, c-f, enter, s-enter)
      - buffers are seperate from "editors"
        - buffers -> the recently opened files retain on the file picker (on top if you have it set on a workspace), i don't even know how to close them.. thus retaining undo-history
        - editors, i think, are opened buffers (which you can close at any time, which sorta just suspends it..)
      - jumping the cursor back after highlight or viewing
        - a cursor jump counts in the undo-history
      - *saving config hot-reloads it*
      - diff on the scroll bar
        - actually having a scroll bar..
        - *i forgot how gooood smooth(?) scrolling felt..!*
      - scroll bar as mini-map
        - size of scroll-bar = size of buffer?
        - a line for the cursor
  - gpu-powered gui, *no terminal interface*\
    - this makes movement particularly standout
      - *great smooth scrolling*
        - (also, fuck terminals)
        - great movement on c-down/up
      - great little view mode (c+a+arrow keys)
  - **made with jai**

*** micro
  - go(lang)
    - i'm already not interested.. lol. i much prefer products by the rust folks..
      - go programs often have a similar fate as google products: they are made just as quickly as they are abandoned
      - though, go does have the terminal/text-editing libs..
  - UPDATE: I TAKE THAT BACK, THIS IS CUTE
  - actually a direct replacement of nano, that is: *TINY in SCOPE*
    - (terminal-only)
  - you can learn all of the key-bindings in 5 minutes
  - it's actually quite feature-ful: buffers (as tabs), pane-splitting, commands (about 20, lol.. <3), even plugins!
  - no word-wrap
    - probably a plugin, lmao
  - *just works as you'd expect/want a terminal text editor to work*
      - (this entry was written using micro)


** semi-hackable

usually via api + scripting lang architecture

making them have great potential for plugins

i think this design is a good middle-ground, as they provide a way for people to hack at it (write functions, plugins), yet avoid jumping into the text editor rabbit-hole

helix is most promising.

i missed out on sublime's reign..



overview:
0. helix
  - NOTE: once the gui and scheme scripting is out, i think it'll become my favorite..
  - a contemporary kakoune implementation in rust, with **sane defaults**
  - works in terminal (and thus great for remote terminal use)
    - but because of this, doesn't feel as good as gui editors... terminals are just a pain
  - a good step towards emacs
  - scheme scripting coming soon!!
    - but just scripting, the core is still rust..
2. sublime text
  - much loved for being fast, and handling big files
  - popularized the zoomed-out view
  - has lsp and ctags!
    - **ERROR: the ruby LSP was buggy as of 10/2024, creating multiple interpreters and leaking memory**
    - i filed an issue
      - https://github.com/sublimehq/sublime_text/issues/6523
        - **LSPs aren't maintained by sublime :/**
  - has aura theme!!
  - **shareware, bugs you about buying a license**


*** terminal
**** helix
  - STATUS: still developing gui-front-end, scheme scripting and plugin architecture, but off to a great start as a simple terminal editor
  - *sane defaults, just works, fast (rust)*
    - **great sane defaults with the most essential features already built-in, config-free(!!): tree-sitter, lsp, dap**
  - kakoune bindings by default (in addition to emacs bindings when in insert-mode..)
  - **the best key-bindings/keyboard-interface of all past worlds: vim, doom-emacs, and kakoune**
    - *NOTE: despite this, the functions behind the bindings can be quite stupid, compared to the smarter functions by emacs, which just comes from years of progress..*
    - doom-emacs's intuitive pop-up menus and leader-key key-chords
    - modal key-bindings, but compared to vim: more intuitive, lower learning curve, less key-bindings, and perhaps even less key-strokes
    - kakoune style more interactive workflow: selection -> action flow (vs vim’s action -> selection flow): wd vs dw
  - "helix for vscode" extension to ease transition / aid in using both at the same time
    - TODO: ...no pop-up menus tho..?
  - emacs-style buffer navigation: file picker, buffers and buffer list, jump markers and jump lists
    - **requires a bit more cognitive load..**
      - often have to use terminal to navigate file-system, then opening helix is begin a "workspace" at the current location**
  - terminal versoin still suffers from a lot of terminal clunkiness
    - mouse input, scrolling, etc. all just feel meh
    - **the ui just doesn't compared to gui, making it lack much sense of ui design**
  - **because the core is meant to be rust, and every other feature in scheme, it still lacks very basic features as of 10/2024**
    - file/buffer/symbol tree
      - the buffer navigation is favored
    - zen-mode
  - scheme scripting
    - !!!, finally, get to use lisp :)
    - https://github.com/helix-editor/helix/pull/8675
    - until the scripting feature is out, it lacks a lot of things that would likely become scripted plugins: file manager, more advanced debugging, etc.
    - though it will have lisp scripting, it is written in rust, and thus not really malleable as a program written entirely in a scripting a language, and definitely nowhere close to a program written entirely in lisp. in hackabilty, it's worse than vs-code, which is written entirely in a scripting language: javascript
  - rust
    - truly a force of reckoning those people

*** gui
**** TODO sublime text
  - BUG: ruby lsp
    - this stopped me from working in it (see [[conclusion]])
    - WARNING: **lsp plugins are not maintained by sublime, thus still relies on community, which is much smaller than vs-code, emacs, nvim**
  - **the best simple gui text editor, replacing notepad++**
  - **designed for speed and simplicity**
    - **written in C++, extensions written in python**
      - TODO: python can interop with C++??
      - *if only it used ruby.. :/. it's actually quite an ideal editor..*
    - **30mb, fast, simple**
      - thanks to this, imo, it destroys both atom and vs-code
  - **great defaults**
    - took a few minutes to setup lsp, just use command pallette -> install packages
      - just as seamless as vs-code! i only had to install the theme manually
      - config files are seperated by extension, as opposed to vs-code, which has it all in a single file
    - looks great too, and has aura theme
  - all the standard features: file explorer, zen mode, etc.
    - **the product is complete**, nothing to add, just fix bugs for a long long time
  - extensions in python
    - terminal, git, etc.
      - because the extensions are written in python, the cross-platform terminal (terminus) had to be written in python too :/
  - *perhaps the most loved text editor pre-vs-code, the real victor vs atom, but eventually lost to the momentum of vs-code's open-source community*
    - perhaps used to require more effort to install extensions..? now seems just as easy...
  - **shareware (as in winrar closed-source bug you until you buy a license)**
    - **closed-source**
    - **$100 for a 3 year license, or, bug you from time to time :/**
    - this def killed it..
    - TODO: sublime merge is another app that's really well regarded too, perhaps also shareware..?
**** (vs-code)
see [[vs-code]]



** completely hackable editors

since it's inception, humans have since attempted to re-create emacs, but none have survived

i'm content with having found and being able to help create a minimalist version of emacs via textbringer, in ruby!

i'm not so interested in lisp to deal with lem..

NOTE: all of these are terminal editors first, with an optional modular front-end gui
  - which i think is indeed the way to go, to start the project simple, and master the core of the program



overview:
0. **emacs (doom)**
  - OMG. FUCK TERMINALS. THIS IS ALL YOU'D EVER NEED!!
    - replaces: text-editor, shell, file-manager, git app, knowledge-base, e-mail, chat, browser (text)..
  - **great discoverability makes it very quick to understand and extend**
  - potential is unlimited, written in lisp, **one tool-set to rule them all**
    - https://www.reddit.com/r/emacs/comments/1fh999a/is_emacs_still_the_one_in_2024_or_how_did_we_end/
  - **meow, the best key-bindings**
    - doom with evil-mode in particular makes vi-mode seamless across all these packages
  - great way to build up own leader-keys / key-chords
  - great way to build up functions too
1. textbringer
   - *PERSONAL NOTE: worth having as a simple personal editor, one that i can actually understand as a whole and can contribute to*. like haxe, it feels *grassrootsy*, really understanding the tools that i use: text editor, language, game engine
   - *a tiny passion/home-brew project made by one japanese guy*
   - replicates vanilla emacs quite well, in addition to providing the basics: windows, completion, plugin-system, etc.
   - *written entirely in ruby, with C extensions used by a few gems*
   - *ruby feels far better to work with than lisp, far more elegant too*
     - *great to pair with dragonruby and web dev*
   - *could really specialize an entire editor for a single language*
e. lem
  - WARN: BUGGY as of 10/4/2024
  - *truly completely malleable* as it is entirely written in common lisp
  - seems like a great way to learn common lisp
x. kakoune?
  - helix solves it's problems by providing the much wanted batteries
  - for the unix dream
    - great for using/learning unix tools for everything
      - you must glue together unix tools such as fzf to the editor using infamous kakscript
    - also great for using any language write to tools to do anything with kakoune (thanks to it's client-server model)
      - ruby + kakoune <3??
    - conversely, these two systems prevent it from having a healthy plugin eco-system (in favor of improving the unix eco-system instead)
x. nvim
  - TODO: is this actually completely hackable? or semi-..?
  - painful config, terrible lsp plugins, zero discoverability, no design nuances, stupid fanatics-riddled bindings and community



*** textbringer
  - UPDATE: it's terminal-only, quite bare, a clone of vanilla emacs, seems like a one-man hobby project by a japanese kid-now-adult, but surprisingly complete..!!
    - https://github.com/shugo/textbringer/issues/153
      - i messaged the maintainer here.. asking about limits
    - NOTE: uses emacs key-bindings by default, and there's no pop-up display (which-key), so you had better completed your super-saiyan emacs training!!
  - *an emacs-like machine using ruby*
    - *this sounds like heaven..*
      - *i would write plugins for this all day..!!*
  - there's also a plugin for a mail agent and a mastodon client!
    - this is probably due to *ruby's great library system*..
      - actually, this makes a big difference..
    - *you probably could also use "C extensions" so.. well, damn, with these two library eco-systems, you can do everything!!*
      - though, at the cost of creating C interops (extensions or ffi)
  - describe-class/method uses ri
    - seems similar to helpful functions (helpful-callable/var/etc.), bringing up a list of functions/vars to search docs for, within the source code
    - ri might be standard, in the std lib, compared to pry..
  - eval_region
  - it actually has more than i thought..
    - find file, buffer list
    - re-map key-bindings, create key-maps, and even modes and plugins!!
      - *this puts it on the level of helix, but infinitely more hackable..!!*
  - sounds like the core of it uses C.. but github shows 100% ruby.. hmmm
      - i had to take the time to build "C extensions"
        - maybe they were in seperate gems..
  - gem install textbringer, then run txtb

id actually keep this as an alt terminal text editor.. for when i just want vanilla emacs.. but in ruby. though, theres not much reason for it, as you could just execute shell commands which can be a ruby script (shell-command / m-!) or apply a ruby script on a selected region (shell-command-on-region / m-|), both which can be done in most editors including helix, or better yet, keep a buffer and repl/process open and usee the the ruby robe plugin to interact with it (eval code/region, introspective ri docs, completion based on introspection etc.). its all a bit indirect, but surely not bad.. considering you get the rest of emacs..
  - TODO: what benefit does it have over emacs' ruby-mode (robe?)? as long as the text editor (emacs) provides potential for deep integration (do things based on introspected info, eval, etc.), what would textbringer bring, save the difference in languages?.. though, *i would much much prefer writing and having ruby extensions over lisp..!!*
    - ..maybe that's enough reason!

however, if for some reason much of what you're doing is text (including data??) wrangling, in ruby, this is the perfect scratch-pad!! it just needs the act/execute-command-on-region function, so that you can run custom commands on regions of text. who knows how far it can go..?? i mean you can require anything.. you can require nokogiri, create a function/command using it, run it, output (via puts) to the buffer, then continue by using that as input.. *the buffer then becomes the source of i/o for the program~~!!* instead of stream-based shells, which output (to another program) to the shell's display area (echo), programs (or regions of code) in textbringer output to the buffer. then again.. *if you can save vars, you can store whatever data you need into the text-editor-program*.. it could be an awesome interactive data munging thing.. i believe the repl can take in entire massive programs.. i mean, it's the standard CRuby interpreter/vm, no? then you can create new commands using any libs!! i'm' not sure how much you'd' want to inject into the text-editor's' process, but people seem to love emacs for it..!!
  - TODO: create shell-command-on-region function!
  - TODO: try eval a var, and look for it
  - TODO: try eval def, and look for it
  - TODO: re-visit why he chose define_command over normal eval def, beyond the docs, which don't work..
    - "definable anywhere"

C extensions, unfortunately is not as simple as say, in go or zig.. otherwise, it would be awesome to quickly throw in C programs, and play with that.. in ruby, dynamically!! :o *now that would be the ultimate media making program.. the pain-point is how easily it integrates with C..* *..perhaps it should've been written with mruby instead, or.. dragonruby..??* LOL
  - TODO: try creating a C extension for a pop program... let's say.. tree-sitter, and some completion thing (fzf?), based on introspection
    - now that's some good homework..!! :D
  - re-create which-key, but with ascii art :)

TODO: now if only it worked with dragonruby.. hmmm

*** lem
  - UPDATE: unfortunately, *buggy as shit: crashes when a pop-up window is open and you alt+tab away :( i was very close to really getting into writing lisp too!!*
    - TODO: try terminal version.. that seems to fare better..
  - still... quite a great introduction to lisp, as there aren't too many functions (unless you're hacking at the core of the editor..), and you can quickly write your own functions and map them to commands 'n keys, all in a few lines, all in one file... simple..!
  - https://www.reddit.com/r/emacs/comments/1b4a2tq/what_do_you_guys_think_of_the_lem_ide/
    - emacs default key-mappings
    - sane default plugins included: Dired-like file explorer, Projectile-like project-orientation, Paraedit-like structured edit... sounds like it basically learned and took the good things from emacs with it
  - *completely written in common lisp (sbcl?)*
    - (emacs has a C core, particularly for it's display, but mostly just for it's compiler)
    - **and thus can be extended or completely altered in common lisp too :)**
    - fast, compiled
    - modular front-end: sdl2 for gpu-powered gui, ncurses for terminal
    - **great CFFI, thus easily allowing easy access to all C libs**, "which makes the world your oyster"
      - why doesn't emacs have it?
        - https://www.reddit.com/r/emacs/comments/16396v0/why_doesnt_elisp_have_a_c_ffi/
          - "I've been wondering why there isn't a C FFI which would eliminate the need for new C code to be written for every library integration, and which would allow everything to be written in elisp.""
          - "Political Reasons...However, I do agree that CFFI would have been helpful, not because it would make for less code, but because it would enable people to implement extensions without needing to wait for devs to make it available through the official release.
            Observe that tree-sitter was available as a module before it was available in the core, but for some reason, modules are not a thing in the Emacs community."
          - "*As for FFI it is handy but it lacks compile time checking. It's not always easy to use ie converting pointers and C types. Emacs also has Emacs C modules which works nicely if you need to interface with C."*
    - smaller, more manageable code-base
      - doesn't plan to become an OS
    - common problems of new projects: lack of docs, bugs, etc.
  - made specifically for common lisp, though it can support any lang
  - made by a Japanese person!

*** classics

notably, most current text editors still use the key-bindings from these two editors: neovim for modal text editing and emacs for non-modal. So, once you learn one of them, newer editors often provide bindings for both, emacs for default (insert-mode) and an optional extension for vi-like modal bindings (normal-mode)

however, the bindings of vim's hjkl is dependent on qwerty keyboards (and therefore inferior to emacs)

both originally were terminal apps and still can be used as such, though now, emacs can be built with a native gui, and neovim supports adding one (neovide, written in rust)


TODO: merge
emacs:
  - gets better with time.. and it's been 60+ years..?
    - thanks to it's implementation
nvim:
  - becomes a more hideous frankenstein over time..

**** emacs
  - UPDATE: surprisingly efficient.. i've never seen my shitty old chromebook display 20 hours of battery life.. wtf??
  - much more than a text editor, it's often lovingly called an OS! based around the concept of text buffers
    - **this has the great benefit that everything is written in the same language, morever, the most dynamic language of all time (lisp). Otherwise, you'd have to use an entire set of tools, wherein each tool can be writtern in a different langauge, have different opinions, and just not work as seamlessly together: terminal, terminal multi-plexer, text editor, git tui, file-manager tui, knowledge-base tui, and so on.**
      - **at the moment, for me, all of the tools i use are now written in rust, which is infinitely harder to edit than lisp, let alone develop.** The language itself is complex, along with it's memory-management mode, plus, you have to compile it.. It's all a pain. Whereas with emacs, you just need to know one language, no memory-management
      - a fzf like search-engine integrates with many other features and plugins seamlessly:
        - find file
        - search (grep) text
        - find displays (buffer, window, workspaces..)
        - completions
        - introspect dynamic run-times
          - and therefore commands (functions of emacs)
      - e-shell
        - NOTE: can also just start a native shell immediately via (async-)shell-command..
        - spc-o-e
        - *incredible, providing auto-complete, etc. without config like fish shell, and retains the bindings and theme of emacs*, thus replacing fish and wezterm
          - *emacs >>> terminal emulator + shell (+shell config) + file navigator + lazygit*
      - dired
        - not quite yazi, but since it's integrated with emacs, i feel *no seperate terminal app can compete*
      - also, simply, **none of the other languages are as dynamic as lisp**. For every program written in a systems lang (including rust), an interface (api) is required, and then another dynamic language is used on top fo that (lua, a lisp). In that case, why not just use a dynamic langauge to begin with..?? tools.**
      - i think this thought continued to this reddit post i made:
        - https://www.reddit.com/r/emacs/comments/1fh999a/is_emacs_still_the_one_in_2024_or_how_did_we_end/
  - elisp
    - actually interesting to use, and dirt simple (especially when compared to the cryptic syntax of vimscript!!)
  - probably incepted, if not popularized, many great text editing ideas (because it's so easy to extend / write your own functions):
    - vundo
      - visual undo tree
    - kill-ring
      - interactive paste function
    - expand-region
    - interactive tab
    - etc.
  - mature (possibly the oldest of all currently used code), well-written plugin eco-system
    - org-mode
      - i'm orgin' baby!
      - **the ultimate knowledge-base software, simple yet powerful**
      - *the shift-tab/tab workflow is so natural to my mind.., it aids me to focus, and just be more organized*, as then everything is forced to be under a heading
      - this lends well to being in habit folding/unfolding code, and just navigating code in general
      - **org-babel**
        - can combine programming languages, using the output of one as the input of another, perhaps similar to the much much later jupyter notebooks
        - probably the basis of jupyter notebooks..
    - magit
      - **the best git experience**
      - though i still use github gui app, this def seems worth trying/learning..
        - TODO: magit-diff
    - auctex
      - the best latex experience
    - slime (common lisp), geiser (scheme), cider (clojure)
      - **the best lisp dev environments**
        - naturally..
      - portacle is an emacs config set up for common lisp dev
    - particularly great for other dynamic langauges too
      - ruby (python?, javascript?)
        - LSP doesn't make use of the info via introspection..??
  - "m-x is godsend"
    - run any command (function?) that exists in the program
  - **meow**
    - **the best key-bindings of all!**, even better than helix/kakoune!!
    - **meow-doom** integration
      - **the best starter-kit combined with the best key-bindings!!**
        - THIS IS IT!! IT DOESN'T GET BETTER THAN THIS!!!
  - pre-configs
    - **doom-emacs**
      - a great starter config that makes a really nice onboarding experience
      - *i really really liked this, found it very quick to find and precisely just what i needed*
      - **intuitive space-bar menu to ease learning**
      - **have choice between emacs (good) vs evil-mode / vim-keybindings**
      - this guy truly is a blessing..
        - *most people go on to make their own text editor, but why not simply modify an existing great one, that has stood the test of time..?*
    - prelude
        - a light-weight starter kit closer to vanilla emacs, in case doom is too much, or if i want to make my own
    - minimal_emacs.el
      - another minimal/light-weight starter-kit
  - x/slow startup time
    - UPDATE: emacs 28 added **native compilation**..!
      - https://www.youtube.com/watch?v=bhjO22s6snU
        - how it was made, presented by it's maker
    - from 18+ seconds to < 3 seconds (6x+) to load doom-meow with 170+ packages on my ancient shitty chromebook
      - UPDATE: ~5-13? seconds first load, ~2 seconds after that, for 170 packages and 50 modules via native compilation on the same shitty old chromebook
      - might as well take that time to reflect a bit..
  - terminal and gui modes
    - *UPDATE: OMG, muuuuuuch better after getting gui to work, and quicker too! <3 <3*
      - yeah, *fuck terminals!!*
    - *use emacs on servers!!*
      - emacs bindings are used across shells (bash), terminal text editors (nano, pico?, micro, etc.) and even most contemporary text editors (vs-code)
  - every person that i've personally met that uses emacs is a great great programmer/problem-solver/doer
  - emacs itself is a deep pot of speghetti, and as there are no other great alternatives (that can compete with it's power/flexiblity/ease-of-extending), they get so deep into it, that there's no reason to use another tool
    - 1.7 million lines of code
      - 30% in C
        - this is primarly for the elisp implementation, which may, in the future, be replaced by guile lisp
          - which then in theory could be extended in any language
      - ~1500 primitives??

  https://batsov.com/articles/2024/02/27/m-x-reloaded-the-second-golden-age-of-emacs/

**** KILL nvim (neovim)
  - NOTE: i must have tried this soon after lua support was added, and people were still migrating, as were plugins
  - NOTE: also, i could've benefitted greatly by simply by using a pre-config (lazyvim?)
  - "With the 0.5 release of Neovim on 2 July 2021, it gained built-in support for the LSP, Tree-sitter, and more complete Lua support – including the support for configuration scripts written in Lua instead of VimL."
    - really slow to catch up to the times
    - as of 2024, 40% is still written in vimscript
  - *horrendous amount of time wasted starting out from scratch, reminiscent of the terrible linux config experience, but worsened by archaic language and the unprofessional open-source community it attracts*
    - terrible experience setting up lsp, as there were 3-4 various plugins (deoplete? neoplete??), all of them require config, all worked half-assed, with CoC having the best results and being general. best to just use the built-in lsp with lua, but, meh. even that required config
  - a very very bad learning curve and on-boarding experience, especially from vanilla neovim. bad for learning the key-bindings. bad for setting up for development. bad for finding good sources to do everything. just plain bad.


** big fat gui editors with features by default

these can be quite big.. and eat memory.. and bloated.. and surely a pain to maintain
  - (though, so is emacs..)
  - zed at ~400mb
  - probably the same for vs-code..
  - lapce might be the smallest here..

vs-code is less than semi-hackable, as the process of writing an extension isn't simple..

lapce, i'm not so sure about..



overview:
0. **zed**
  - I FOUND IT!! I FINALLY FOUND IT!!!
  - **just works**
    - **opened a ruby file, asked to install, and boom! lsp installed.**
  - lightning fast, making it hard to find reason to even use focus editor..
  - looks amazing too
  - combines slack, multi-player, ai, terminal, etc. but at 150mb and low cpu and low startup-times, still quick enough to fit here
2. lapce
  - vs-code in rust
  - quite behind zed, but not a startup-business, so it's still worth having as an open-source alt
*. vs-code
  - last resort, in case of specific extensions
  - everything *just works* with "batteries-included": file manager, git manager, terminal window, debugging window, beautiful themes (aura!), zen-mode, etc.
  - has multiple key-bindings extensions including one for helix and kakoune
  - **eats up cpu, memory, laptop battery, etc.**


*** zed
  - *NOTE: ruby actually worked immediately, without any configuriation/customization*.. which is something no editor has ever done..
    - (makes sense, given it's makers..)
  - *batteries-included, just works*
    - it's actually incredible..
  - *windows binary not built for you..??*
    - possibly an attack on windows, as atom was killed by vs-code, and github was bought out by microsoft
    - https://github.com/TakumiBC/zed-windows/releases
      - this repo uses github actions to build it for you
    - **seems to priortize mac os > linux > window**
      - i'm not sure about the reasoning for this..
  - vs-code-like all-in-one ide features (terminal, file explorer, version control, etc.)
  - **ai-focused**
    - this is how it makes money, which is a model of funding i'm totally okay with!
  - **multi-player**
  - gui/gpu-rendered
    - NOTE: this restricts computer hardware to those with a decent gpu
      - though, as it uses and requires vulkan, though, any integrated gpu of a proper laptop from the past 10 years should be fine..
        - just not on my N4000 processor chromebook (netbook), lmao
          - (even after enabling gpu support in crostini)
          - in vulkaninfo and the prompt, it shows my gpu as 'llvm-pipe', which is a gpu emulation
            using cpu, and it absolutely destroys the cpu usage
            - yet, debian shows mesa-vulkan-drivers installed.. hmmm
            - TODO: gpu drivers missing..?? or maybe it uses chromeos to display, so it doesn't show correctly in the linux container..??
              - yep chromeos/crostini problem, it takes a bit more effort:
                - https://www.reddit.com/r/Crostini/comments/rsseb9/comment/hqqkw10/
                - https://gist.github.com/Usulyre/bb33f77b225b8d9336c1f9e744114fba
              - anyway, maybe time to update a major version of debian..
          - i also tried setting env var 'ZED_ALLOW_EMULATED_GPU=1' (and  0) to no avail (as the prompt mentioned)
    - somehow **looks even more beautiful than sublime and even vs-code by default..!**
      - and has aura theme extension(!!) (had to manually install for sublime)
        - and it looks great..!
  - rust
    - **extensions must be written in a WASI language**.. i think..
      - *given that vs-code already has a ton of plugins, i don't know how many people are willing to re-write everything in assembly-script..* or the other systems langs..
      - https://zed.dev/docs/extensions/developing-extensions
      - https://zed.dev/extensions
      - *this def makes it harder to write extensions, but at least it'll be of higher quality, as the language itself will filter out programmers, plus, it won't suffer from memory problems*, which is what usually happened when you install too many plugins..
  - from the makers of atom (and tree-sitter) at github
  - free for personal use "forever"
    - ai costs extra

*** lapce
  - STATUS: felt quite in development when i tried it last, with very few extensions/languages
  - yet another sublime/vs-code copy in rust
    - already has advanced features: modal, lsp, remote dev, built-in terminal..
      - focus on remote dev vs zed's focus on collaboration..
      - *tough direct competition with zed, though zed does seem rather closed-source..*
  - incredible speed
  - *"Plugins can be written in programming languages that can compile to the WASI runtime (C, Rust, AssemblyScript)"*
    - *this is it's biggest difference*
      - TODO: research WASI
      - TODO: but then you'd still have to compile every little function down to WASI..??
    - AssemblyScript resembles javascript

*** vs code
  - made using electron (web stack rendered by chromium/node.js). and therefore:
    - PROBLEM: **heavy, uses a lot of RAM and CPU, eats up laptop batteries**
  - so dominant that it made most other editors abandonware
    - cross-platform, open-source, community-oriented, electron/web-style-dev, all helped it sky-rocket past previous-gen text editors
      - **by far the most extensions thanks to having the biggest community one-click install**
        - NOTE: this is the main reason to use it
  - has extensions for all of the classic key-bindings
    - "helix for vs-code" is good, merging helix bindings with vs-code bindings and gui cursor, but missing the pop-up menus
  - *plugins are a bit of a pain to make*, especially compared to the simply writing a function in lisp, thus creating a barrier between you and and the ideal editor experience
  - simple, easily-recognizable os-like gui: tabs, show/hide panels/windows, etc.
  - 2016


** complete IDEs

mostly langauge-specific
  - and therefore limiting for general-use, when using many languages, in addition to simple writing / note-taking
  - only useful for big projects written in a single language, though,  nowadays, a single project can be written using multiple languages!..

generally adds these features: **integrated interactive debugger, profiler**, advanced code completion, advanced refactoring, better file navigation (notably *great go to definition functionality*, especially for more difficult to implement dynamic langs), tasks runner (including tests), database integration
  - though, nowadays, with LSP an DAP protocols gaining popularity, only the most advanced features make IDEs stand out


overview:
  - vs-studio
    - for advanced debugging / monitoring features
  - jetbrains IDEs
    - language-based
     - $$


*** language-specific IDEs by JetBrains
  - seems to fill the gap vs-studio has left with other languages
  - widely considered the best IDE for nearly every major language except javacript and C#
  - quite special for having good IDEs for dynamic languages like ruby and python
    - https://www.reddit.com/r/ruby/comments/11ji4u7/rubymine_or_vs_code_extensions_for_debugging_in/
      - "I keep trying to switch off of Rubymine and I keep going back. Debugging in Code is good enough, like no issue, once you find the right combination of articles to help you set it up. Autocomplete, intellisense, and similar are much worse, whether you use Solargraph or Sorbet + Ruby-LSP, and there are essentially zero refactoring actions. But the real killer feature for me is that Rubymine let’s me search, add breakpoints in, or jump to a definition in gems used in my application."..."But the real real killer feature is that it all just works, no hassle. Sure it’s a little sluggish sometimes. Sure the interface is a lil heavy. Sure the plug-in ecosystem is way less active. I got work to do, damnit."
  - recently seperated into language specific IDEs:
    - https://www.jetbrains.com/ides/
    - *intellij*
      - java, jvm langs?, the standard for it
        - i think this was their first/main editor that started their business
        - also helped that eclipse fucking sucked
    - *rubymine*
      - ruby, the standard for it
        - though, i wonder how it compares with emacs' ruby-mode/robe..
    - *pycharm*
      - (python)
    - etc.




https://pawelgrzybek.com/the-joy-of-learning-helix-and-probably-other-modal-terminal-based-editors/
  - todo: read

*** vs studio
  - the standard advanced IDE with the most features
    - it's combo with C# set the standard for IDEs
  - seems to be mostly focused on C/C++/C# compared to other langs..??
  - microsoft
    - therefore took a long time before making vs-mac


** history, and some old favs

NOTE: i missed out on the era of atom and sublime.. by the time i got back to the computer, vs-code was out
  - notably, sublime lives on! and is much cherished..

*** kakoune
  - PROBLEM: no plugin eco-system, by design
  - https://github.com/mawww/kakoune/blob/master/doc/design.asciidoc
    - the **DIY** unix editor, **modular**
      - a new classic in it's own category
    - **designed for interactivity**
      - **display edited text in real time, as opposed to vim's longer key sequences**
      - **select/highlight *then* action workflow**
    - **strictly adheres to the unix ideal**
      - pipe selections (via |) to unix/shell tool and replace selection with output, such as sort
      - select/"keep-pipe" (via $) using a unix tool, such as grep
        - note: these two are implemented by helix
      - **fifo buffers, a file/buffer that is read by kakoune, that an another program is outputting to, asynchronously**
        - this is one of it's main features
      - no plugins, rather, has `%sh{...}`(??) and socket interfaces and .kak bash scripts
        - **though great in theory, sucks in reality, as external programs/processess must be able to read the buffer and send something back, through the client/socket interface, and somehow work well together**
          - **tree-sitter, lsp, dap support suck**
            - helix included these to overcome this limitation of kakoune, stunting kakoune's community
        - must write scripts (.kak) to glue / provide api to other programs
          - should mostly just be wrappers to small console/cli programs
          - *kak script is notably cryptic*
        - can use shell expansion within kakoune command-line %sh{...}
        - can easily hook up fzf, yazi/broot, fd, ripgrep, etc.
          - **in <=50 lines of config**
        - **makes it rather unportable**
    - minimal design
      - only text editing, nothing else
        - not even built-in language support (must write a `kak` script file), no built-in lsp nor tree-sitter
          - this is def what killed it
          - there is an lsp plugin (kak-lsp), but no tree-sitter (phaazon is writing one, still in dev as of 10/2024)
        - no system-clipboard, no surrounding-pairs, no nothing
          - though, there are likely plugins for these things..
    - **linux only?**
    - **terminal only?**
    - 2011
    - source: "why kakoune" site
    - source: great answer in reddit comment on: "anyone still using kakoune?"

*** atom
  - DISCONTINUED, and replaced by vs-code
  - set many standards:
    - **the electron framework** (see the relation in it's name?)
    - **tree-sitter** was also developed by github for the project
  - **hackable to the core**
    - unlike vs-code
    - TODO: looks into this..
  - ...people don't seem to have liked this one.. probably for the same reasons they don't like vs-code.. (electron/browser)
    - sublime text, it's direct competitor during it's time, was favored due to the performance of C++/native (and just good programming 'n design skills)
  - though historically important, basically replaced by vs-code, since microsoft had acquired github..
    - **github ended maintenance on it at the end of 2022**
  - **made by github!!**

*** a few little basic gui classics
komodo-edit
  - my fav from college ~2007
    - i found this trying to find something for python..

notepad++
  - a windows classic, same as ever, still cute and functional for an old 90s thing

notepad2
  - a personal classic
    - a replacement for windows notepad
  - TODO: try notepad4

kate
  - a linux classic?
    - no, this is newer KDE stuff..

textmate
  - a mac classic?

*** vim
  - maybe made vi extensible..? added the horror that is vimscript..??
  - written in C and vim script
    - and vimscript is terrible
    - best to try various starter configs with sane defaults

*** vi
  - introduced modes (normal, insert, visual/select, command)
    - *adds quite a heavy cognitive load*
    - *heavily key-board-oriented* input user interface
      - *i personally feel more comfy using a touch-screen/mouse/keyboard combo*
    - it's legacy is based on it's concept of modes and composable key-mappings: [#]actions->motions









* PROJECT textbringer dev


only 200kb?? i guess because it doesn't include the ruby compiler, nor the std libs... yeah, i recall using 'gem install' so it's all in the libs
  - try packing it with traveling ruby!

make a minimalist org-mode
  - def a great beginner parser project!! :D
    - and in ruby!
  - could start with markdown first..
    - START HERE

make textbringer more accessible, ideally to the level of focus editor and helix, but limited to terminal, and *focused on ruby magicks :D*
  - start by offering a very simple alternative to the notoriously hideous emacs key-chord bindings
    - x/make the config simple too, like focus, also hot-reloadable
      - vs hackable.. as the whole thing is a ruby program.. introspect and search for the right vars 'n functions..?? i mean, that's what i do in emacs.. peer m-x completions and describe-vars..
        - just provide a little guide in the config file to where useful settings in the program may be... which objects, or naming patterns for various settings
        - *this is actually a great project to really learn how ruby works..*
    - are arrow keys not bound by default or is it a terminal problem??
      - TODO: download 'n try on wezterm
      - START HERE
  - even with emacs bindings i'm having troubles..
    - TODO: add escape key as alternative to c-g to escape the mini-buffer (key sequence input, m-x, find file, etc.)
      - again, might be a terminal problem..
  - at least add which-key?
    - TODO: maybe instead just show bindings after pressing tab.. to keep it minimal, less distracting pop-ups
      - START HERE
  - focus editor has a ton of little design ideas to copy, as a great zen starting base


(just installed wl-clipboard for textbringer, yay!!)
  - FIXME: "No suitable type of content copied"
    - hmmm, damn
      - FIXME: and a bug if you do it twice, LOL, gotta love it.
        - it's interesting that it inserts text into the terminal like that though..
          - TODO: hmm, if c-/ is undo, what's redo..? not c-s-/ nor m-/ ..
            - at least need a reminder of bindings after using m-x..!


* key-binding concepts and comparison

main editing key-bindings

emacs
  - everything uses these (since bash 'til nowaday's vs-code 'n zed!)



modal key-bindings

meow > my custom helix bindings (even more kakoune-like) > helix >> nvim
  - NOTE: emacs is special, as it's focus is on insert-mode, as it doesn't add another (distractful) layer of key-bindings on top of that..
  - text editing only
  - *NOTE: hjkl is not keyboard layout agnostic!!*, thus it's actually better to stick to emacs' mneumonic key-bindings, even if it's a bit unweildy..



leader-keys / key-chords
  - general leader-key-bindings for functions


meow-doom > doom's evil bindings > helix > emacs > nvim(?)
  - meow provides a minimal start, made to provide space for personal customization, including doom's sane default emacs bindings (c-c / spc) and emacs' original key-bindings (c-x, c-c c-, c-h)
    - this way, you can learn the way of emacs, and have the space (literally and space-key) to create your own set(s) of key-mappings
    - NOTE: modules can have whatever bindings they choose, making emacs feels rather inconsistent, difficult to grasp
      - though, at least they should be based around emacs' original key-bindings, hopefully lessening the cognitive-load..
  - doom's evil-bindings provides a complete package based around vim bindings, of everything you'd ever need, altering emacs original key-chords and creating more maps and key-bindings on the space-leader-key
    - it can feel a bit cluttered, with too many bindings, not enough room!
    - it also provides optional alt-bindings for nearly everything else in emacs (beyond the main buffer), making the bindings consistent across everything in emacs (especially the hjkl keys for movement):
      - completion via the mini-buffer (c-j/k to move down/up)
      - frequently-used modules like dired
      - info?


** TODO some readings
  - note: typed the words since copy/paste in terminal isn't working.. :/
  - phaazon kakoune philosophy
    - the person builds a lot of pop text editor functions for kakoune, using unix cli tools
  - phaazon more hindsight vim helix kakoune
    - interestingly went to kakoune after helix, but ultimately uses both
  - esrh.me switching to meow
    - just details the improvements over vim, and even doom
  - rrajath ditching evil for meow
    - not much writing, but def has a solid emacs config!
      - moved to minimal-emacs.el





* is emacs still the one, in 2024? or: how did we end up here? what was the story of your journey? - a reddit post by me!

https://www.reddit.com/r/emacs/comments/1fh999a/is_emacs_still_the_one_in_2024_or_how_did_we_end/

is emacs still the one, in 2024? or: how did we end up here? what was the story of your journey?
i just got a (like-)new laptop(!!), after happily living off an ipad mini 2 for a long long time, and, for the previous few months, an old chromebook. With the chromebook, i was using--and learning--linux, and the ways of linux (via chromeos's-lxd-vm-"crostini"-container-thing). It felt like being a programmer in the 1970s. Terminals? Unix? Bash?? Looks like Perl! Fish--now we're in the 80s, baby! Dotfiles? Nvim!? Nvim configs? *barf*. Now that i've got a proper windows laptop from the lovely Taiwan, i am immediately delighted to toss out unix (*nix?) for powershell. This may be the one time i'd happily conform to Microsoft's strict 'n consistent naming conventions (im-a-bit-unconventional).

after surveying the lands of programming after not doing any for a decade, i've fallen on helix. It is written in rust, and hopefully it will have scheme scripting soon(!!), which'll make a fun entry into the world of lisp, for me, and hopefully for others too. Unfortunately, it's under heavy dev, and doesn't even have a file tree yet :/ . In addition, i replaced windows terminal---which actually just worked; it just suffered from a bad generated json config file :shrug: --with wezterm (zellij has some cargo without windows, and besides, wez seems cool), which came with defaults i didn't like (i had to change it all to use the alt-modifier-key, and remove a bunch of duplicated mappings), but at least i could easily config it, as it uses lua for scripting.

then the problem came. I had to edit something in the program, helix, the text editor. In order to make that edit, i had to set up and build for rust on windows (thank goodness for scoop install rust/up-msvc and the vs-studio installer helper). Not bad, but ugh. I guess it'd be the same if it were written in sbcl?.. Then a deeper problem came. I wanted to do something beyond the functions that the program provided. In helix, there is a config file, .ini-like in syntax (if that's still a thing..), that enables you to map a sequence of functions to a key, for example: X = ["goto_first_nonwhitespace", "select_mode", "goto_line_end", "normal_mode"] # TODO: make it extend to next line, like x does But what about custom functions ("commands")? (perhaps it's expected i write a separate program that pipes to/from a shell?.. but for every little function..??)

as more languages are used, as more programs are made (--or re-made!), more and more, i feel the force that is leading me towards lisp (smalltalk too!) and emacs. Just one language and one program to rule them all!, providing infinite extensibility and seamlessly communicating between them all, without a foreign-function-interface. No need to separate the terminal, terminal-multiplexer, text editor; nor the knowledge-base, version control, grep; nor even the browser, e-mail-app, music-app, chat-app; nor even the os... But emacs in 2024? Sounds like a lot of.. cruft, unwanted baggage. It sounds just like my very recent experience with unix! It's a rabbit hole that i've been avoiding.. though, contradictorily, me trying doom emacs, loving the immediate intuitiveness of the pop-up dialogs and showing what function is being used, is kinda how i ended up with helix to begin with?.. :thinking:

i was recently looking into an editor for common lisp, to just try a lisp, and though there's portacle, a config for emacs, i ran into a lispy editor called lem. I presume *because* it's written in lisp, one can easily write functions ("commands")--real functions with arguments 'n all!--,in addition to hooks, and even an entire "extension"/"major mode". All of this, in one simple language. *muah*

i feel with lem that i am at the edge of the rabbit hole; and i'm... still avoiding it.

I'd kinda have to start fresh with the basic emacs key-mappings, or, just go all in with doom emacs, and maybe can use the meow-mode as training wheels.

...anyway, i just wonder, is this the general feeling that lisp and/or emacs users have towards the rest of the languages (save smalltalk) and dev-tools? Was my journey similar to your journey to lisp/emacs? Like, why bother with all the crap when you can just have one thing that just works? Forever. In one simple language. A powerful language that maybe i could even make games with, and web-sites too? Am i crazy to start using lisp 'n emacs in 2024?

i want to hear your journeys. Or anyone's journey!

(recently, i had to choose some frameworks to help me make stuff i've been wanting to make for a long long time: keep jekyll/ruby for my stupid simple personal static site, currently trying luxe/wren for games (used to use haxe--not simple!)--at least until untitled-j-blow-engine/jai comes out--, and phoenix/elixir for web... top all that off with some powershell 'n ruby scripts, and, well, i think you'd understand why i'm feeling the need for simplicity! :cry:)

related / currently reading:
https://www.reddit.com/r/emacs/comments/1brnmds/why_use_emacs/




