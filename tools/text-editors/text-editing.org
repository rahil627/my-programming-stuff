#+title: Text Editing

* watch tha gods

can quickly gather ideas by simply watching pros at work

** TODO amir rajan

i'm sure he's got some wild tricks..

** j blow

conclusion:
actually [his development method is] dead simple. nothing fancy. he has a mental model of the program--because he wrote it--somewhat recently. he has a mental model of the game, game engine, and programming language! he simply can't be bothered with dealing with stupid things like text editors, or config'ing emacs. hence, **he needs things that don't require any thinking, that's more intuitive, more physical**: a mouse, probably a touch-pad too

funny enough, he doesn't need emacs at all. He could just be using any ol' text-editor that has split panes

https://www.twitch.tv/videos/2241008697
  - **the essential process of programming**
    - it's quite refrshing to see, just pure focused programming, no distractions, simple (and therefore minimal)
  - TODO: not sure if i watched this for only a moment or what
      
https://www.twitch.tv/videos/2249653469
  - // @Tags
    - *an easily-searchable syntax for tags. or generates some docs? perhaps prints out all the tags, along with file, function, line, etc.?*
      - TODO: might be a feature in Jai..?
  - *duplicate pane*
    - very useful for jumping between two points in long files
  - buffer jump by name (no pop-up, vanilla)
  - lots of searching..
    - and replacing..--not refactoring either!
  - delete to end of line
    - kill-line
  - *uses a mouse!*
    - i'm not the only one!
  - giant font size, but mostly because he "can't be bothered in figuring out emacs" to decrease the font-size by less than an increment
  - debug via visual studio break-point, add watches, step-through/make another break-point
    - later, he says the debug process for jai is basically the same as C/C++, just without the complexity of advanced features such as templates/inheritance
      - TODO: no inheritance?
    - also provides some wisdom for debugging: *avoid using any fancy language features because it will make debugging way more difficult*
  - uses bare-grep, a simple gui app
    - really exemplifies how simple--no, *bare*--he likes things :)
  - rant against web data serialization formats: just use a binary file
  - **"it's not often that i do a single task that takes over a week"**
  - *has a massive todo-list*
  - actually answers a question that he surely gets often: make a game or game engine? his answer: *basically, just focus on the bits of the engine you need, just enough so that you can execute the game you want to make*
  
  - **three kinds of debugging methods**:
    - bottom-up
      - don't know what's wrong at all, but know what each line is doing; step through lines of code (the worst case)
    - top-down/narrow-down debugging
      - know how the system works, can narrow it down, jump around places where there's likely the problem
    - divine intervention, must tell you the problem, intuition
      - similar to the light-bulb feeling that comes when you know the answer to a puzzle
      - similar to rob pike's advice
        - https://www.informit.com/articles/article.aspx?p=1941206

  - **clean up code**
    - will pay off later as it will be easier to debug and implement new features

  - **don't do stunt code** (use complex language features)
    - almost never need to
      - very, very few cases for performance/memory


* is emacs still the one, in 2024? or: how did we end up here? what was the story of your journey? - a reddit post by me!

https://www.reddit.com/r/emacs/comments/1fh999a/is_emacs_still_the_one_in_2024_or_how_did_we_end/

is emacs still the one, in 2024? or: how did we end up here? what was the story of your journey?
i just got a (like-)new laptop(!!), after happily living off an ipad mini 2 for a long long time, and, for the previous few months, an old chromebook. With the chromebook, i was using--and learning--linux, and the ways of linux (via chromeos's-lxd-vm-"crostini"-container-thing). It felt like being a programmer in the 1970s. Terminals? Unix? Bash?? Looks like Perl! Fish--now we're in the 80s, baby! Dotfiles? Nvim!? Nvim configs? *barf*. Now that i've got a proper windows laptop from the lovely Taiwan, i am immediately delighted to toss out unix (*nix?) for powershell. This may be the one time i'd happily conform to Microsoft's strict 'n consistent naming conventions (im-a-bit-unconventional).

after surveying the lands of programming after not doing any for a decade, i've fallen on helix. It is written in rust, and hopefully it will have scheme scripting soon(!!), which'll make a fun entry into the world of lisp, for me, and hopefully for others too. Unfortunately, it's under heavy dev, and doesn't even have a file tree yet :/ . In addition, i replaced windows terminal---which actually just worked; it just suffered from a bad generated json config file :shrug: --with wezterm (zellij has some cargo without windows, and besides, wez seems cool), which came with defaults i didn't like (i had to change it all to use the alt-modifier-key, and remove a bunch of duplicated mappings), but at least i could easily config it, as it uses lua for scripting.

then the problem came. I had to edit something in the program, helix, the text editor. In order to make that edit, i had to set up and build for rust on windows (thank goodness for scoop install rust/up-msvc and the vs-studio installer helper). Not bad, but ugh. I guess it'd be the same if it were written in sbcl?.. Then a deeper problem came. I wanted to do something beyond the functions that the program provided. In helix, there is a config file, .ini-like in syntax (if that's still a thing..), that enables you to map a sequence of functions to a key, for example: X = ["goto_first_nonwhitespace", "select_mode", "goto_line_end", "normal_mode"] # TODO: make it extend to next line, like x does But what about custom functions ("commands")? (perhaps it's expected i write a separate program that pipes to/from a shell?.. but for every little function..??)

as more languages are used, as more programs are made (--or re-made!), more and more, i feel the force that is leading me towards lisp (smalltalk too!) and emacs. Just one language and one program to rule them all!, providing infinite extensibility and seamlessly communicating between them all, without a foreign-function-interface. No need to separate the terminal, terminal-multiplexer, text editor; nor the knowledge-base, version control, grep; nor even the browser, e-mail-app, music-app, chat-app; nor even the os... But emacs in 2024? Sounds like a lot of.. cruft, unwanted baggage. It sounds just like my very recent experience with unix! It's a rabbit hole that i've been avoiding.. though, contradictorily, me trying doom emacs, loving the immediate intuitiveness of the pop-up dialogs and showing what function is being used, is kinda how i ended up with helix to begin with?.. :thinking:

i was recently looking into an editor for common lisp, to just try a lisp, and though there's portacle, a config for emacs, i ran into a lispy editor called lem. I presume *because* it's written in lisp, one can easily write functions ("commands")--real functions with arguments 'n all!--,in addition to hooks, and even an entire "extension"/"major mode". All of this, in one simple language. *muah*

i feel with lem that i am at the edge of the rabbit hole; and i'm... still avoiding it.

I'd kinda have to start fresh with the basic emacs key-mappings, or, just go all in with doom emacs, and maybe can use the meow-mode as training wheels.

...anyway, i just wonder, is this the general feeling that lisp and/or emacs users have towards the rest of the languages (save smalltalk) and dev-tools? Was my journey similar to your journey to lisp/emacs? Like, why bother with all the crap when you can just have one thing that just works? Forever. In one simple language. A powerful language that maybe i could even make games with, and web-sites too? Am i crazy to start using lisp 'n emacs in 2024?

i want to hear your journeys. Or anyone's journey!

(recently, i had to choose some frameworks to help me make stuff i've been wanting to make for a long long time: keep jekyll/ruby for my stupid simple personal static site, currently trying luxe/wren for games (used to use haxe--not simple!)--at least until untitled-j-blow-engine/jai comes out--, and phoenix/elixir for web... top all that off with some powershell 'n ruby scripts, and, well, i think you'd understand why i'm feeling the need for simplicity! :cry:)

related / currently reading:
https://www.reddit.com/r/emacs/comments/1brnmds/why_use_emacs/



* key-mappings / key-binding

TODO: see or possibly merge my key-mappings notes in my meow-doom-emacs [config]

TODO: see or possibly merge my key-mappings notes in [helix]

TODO: merge bindings from vi note on my iPad..?


TODO:
remap holding down caps lock to alt
use modes, as they are far more intuitive, showing you shortcuts every-time you activate a mode. naturally, you will customize those modes over time, removing what you don't need, and adding what you want
put shortcuts i forget on my custom mode



basic ergonomics:
just move or swap some useful keys around
  - simple, yet major

on a windows keyboard, swap alt with control on the os level
  - much more ergonomic, for both hands! mac os style!
  - on windows, use powertoys to re-map keys

map caps lock to escape key
  - especially for vi-like key-mappings

TODO: map holding caps lock down to the further mod key
  - https://github.com/microsoft/PowerToys/pull/32545



**modifier keys require more cognitive load compared to leader-keys/key-chords, especially without a pop-up display.** It's sort of like object-oriented programming, the mind is better able to off-load the cognitive load to the object: the leader-key/minor-mode.

key mnemonics aren't really as useful since key-layouts can entirely change, though, perhaps not so useless, as you can still use the differently-positioned keys. Also, the other keyboard layouts aren't entirely different; sometimes, just a few keys are changed, particularly the home row only has a few changes.


pop-up menus / **minor-modes** / leader-keys:
  - i prefer the word minor-mode for this idea, as pop-up menu doesn't signify the complete idea
  - just to think about a bit..

my additional modes:
terminal controls
buffer controls
window pane/view controls (window mode in helix)
  - combine with buffer controls?

helix modes:
https://docs.helix-editor.com/keymap.html#minor-modes
command
  - better to go straight to command picker
space
  - all pickers
goto
goto next/prev section
match/surrounding chars
view
  - sticky-mode
  - haven't used yet...


** merged from [vs-code]


classic-style movement:

TODO: wtf is the f-key?? there's a function key..?

c+left/right
  - previous/next word

f+left/right
  - beginning/end of line

c+backspace
  - delete word

f+up/down
  - beginning/end of buffer (page up/down)

alt+left/right
  - *go to previous/next place you went to (includes other files!)*
    - TODO: this one is a notable exception..
    - most of the time, we move lines down/up, not words/symbols right/left

alt+up/down
  - move current line up/down




** merged from [key-mappings]..
keys-bindings:


  - https://stackoverflow.com/a/7411851/225689
    - a-z vi mnemonics
      - actually really, really good!
      
  - https://michael.peopleofhonoronly.com/vim/
    - visual image / cheat-sheet

a: append
b: beginning (of current or previous word)
c: change
d: delete
e: end (of current word)
f: find (next given character on current line)
g: go (used as "leader" for many commands)
h: left (only makes sense on the keyboard used by vi's author, same for jkl)
i: insert
j: down
k: up
l: right
m: mark
n: next (occurrence of last search)
o: open (new line below current line)
p: put (paste)
q: quote? (record a macro in given register)
r: replace
s: substitute
t: toward (next given character on current line)
u: undo
v: (enter) visual mode
w: (next) word
x: x-out (delete a single character)
y: yank
z: fold (it's visual, it looks like a folded sheet of paper)


- alt mnemonics:
  - append/add
  - begin/back
  - 'til/toward
  - visual-mode/vi-mode
  - paste/put
  - quote? (to record a macro)
  - z looks like it meant to be folded
  
- changes from vi to helix:
  - **surprisingly very few changes!..:**
  - mark -> match-mode
  - substitute -> select-mode
    - no need for substitute char/line with x/select line bounds
  - x-out (delete a single char) -> select line bounds
    - originally delete char right/left..
  - z (fold) -> view-mode







windows os re-mappings (for logic, not ergonomics):
  - maybe can add an additional mapping for copy/paste to windows key
    - by default:
      - w+c - co-pilot
      - w+v - clipboard tab of a a new little input app
      - w+p - project(or) for secondary display
      - w+y - unmapped?
  - ...think of other controls

some interesting windows key mappings:
  - see all shortcuts
    - https://support.microsoft.com/en-us/windows/keyboard-shortcuts-in-windows-dcc61a57-8ff0-cffe-9796-cb9706c75eec#windowskey
      - just skimmed through, not thorough, but i don't feel there are too many useful shortcuts..

  - w - start menu search
    - full of shit now.. use w+space instead
  - w+space - powertoys run (launcher)
  
  - w+left/right - snap window to left/right
  - w+c+left/right - next/prev workspace

  - w+tab - tabs and workspaces view
  
  - w+a - action center
  - w+t - taskbar
  - w+b - system tray
  
  - w+d - hide/show desktop
  - w+m - minimize
  - w+, - peek, hold down win key to keep peeking

  - w+v/. - clipboard/emoji picker





** default komodo edit bindings ~2007

merged from [komodo-edit-cheat-sheet]:

NOTE: although ancient--i think i used it in a class for python, back when python was very new..--, the key-mappings are quite standard, very emacs-y

Komodo Default Key Bindings
Windows/Linux Scheme

Code Browser:
Locate current scope... = Ctrl+K, Ctrl+L

Code Intelligence:
Find Symbol = Ctrl+K, Ctrl+F

Debugger:
Clear All Breakpoints = Ctrl+F9
Disable/Enable Breakpoint = F9
New Session = Ctrl+Shift+F5
Run Script = F7 = Ctrl+F7
Run to Cursor = Shift+F10 = Ctrl+Shift+F10
Show Current Statement = Alt+*
Start = F5 = Ctrl+F5
Start/Find/Hide Default Interactive Shell = F12
Step In = F11 = Ctrl+F11
Step Out = Shift+F11 = Ctrl+Shift+F11
Step Over = F10 = Ctrl+F10
Stop = Shift+F5

Editor:
Back = Shift+Backspace
Backspace = Backspace
Beginning of Line (first char/first column) = Home
Cancel AutoComplete = Escape
Copy = Ctrl+C = Ctrl+Insert
Cut = Ctrl+X = Shift+Delete = Ctrl+Shift+X
Delete = Delete
Delete Word Left = Ctrl+Backspace
Delete Word Right = Ctrl+Delete
End of Line = End
Go to End of Document = Ctrl+End
Go to End of word = Ctrl+E
Go to Line... = Ctrl+G
Go to Next Bookmark = F2
Go to Next Line = Down
Go to Previous Bookmark = Shift+F2
Go to Previous Line = Up
Go to Top of Document = Ctrl+Home
Insert Newline = Return
Insert Newline (align with current line) = Ctrl+Shift+Return
Insert Newline (continue comments) = Shift+Return
Insert Newline (no favors) = Ctrl+Return
Insert Next Key as Literal Character = Ctrl+M
Join current and next lines = Ctrl+K, Ctrl+J
Move Back Part of Word = Alt+Right
Move Forward Part of Word = Alt+Left
Move Left One Character = Left
Move One Character Right = Right
Move One Word Left = Ctrl+Left
Move One Word Right = Ctrl+Right
Page Down = Page_Down
Page Up = Page_Up
Paste = Ctrl+V = Shift+Insert
Paste and Select = Ctrl+Shift+V
Redo = Ctrl+Y
Reflow paragraph(s) = Ctrl+Q
Remove All Bookmarks = Ctrl+Shift+F2
Repeat next keystroke N times = Ctrl+K, Ctrl+U
Scroll One Line Down = Ctrl+Down
Scroll One Line Up = Ctrl+Up
Select All = Ctrl+A
Select Next Character = Shift+Right
Select Next Part of Word = Alt+Shift+Right
Select Next Word = Ctrl+Shift+Right
Select Page Down = Shift+Page_Down
Select Page Up = Shift+Page_Up
Select Previous Character = Shift+Left
Select Previous Part of Word = Alt+Shift+Left
Select Previous Word = Ctrl+Shift+Left
Select to Beginning of Line (first char/first column) = Shift+Home
Select to Beginning of word = Ctrl+Shift+W
Select to End of Document = Ctrl+Shift+End
Select to End of Line = Shift+End
Select to Next Line = Shift+Down
Select to Previous Line = Shift+Up
Select to Top of Document = Ctrl+Shift+Home
Toggle Bookmark = Ctrl+F2
Toggle Overtype/Insert Mode = Insert
Transpose Current and Previous Characters = Ctrl+T
Trigger preceding autocomplete list or calltip = Ctrl+J
Undo = Ctrl+Z
Zoom Font Size Down = Ctrl+Shift+-
Zoom Font Size Up = Ctrl+Shift+= = Ctrl+Shift++

Find:
Find Next = F3
Find Next Result = Ctrl+Shift+F3
Find Next Selected = Ctrl+F3
Find Previous = Shift+F3
Find in Files... = Ctrl+Shift+F
Find... = Ctrl+F
Incremental Search = Ctrl+I
Incremental Search Backwards = Ctrl+Shift+I
Replace... = Ctrl+H

General:
Close Window = Ctrl+W = Ctrl+F4
Edit Properties = Alt+Return
Least Recently Viewed File = Ctrl+Shift+F6
Most Recently Viewed File = Ctrl+F6
New File (default type) = Ctrl+Shift+N
New File... = Ctrl+N
Next File = Ctrl+Page_Down
Open File... = Ctrl+O
Open Project... = Ctrl+Shift+J
Previous File = Ctrl+Page_Up
Refresh Status = Ctrl+K, R
Save = Ctrl+S
Save All = Ctrl+Shift+S

Help:
Alternate Help on Selection = Ctrl+F1
Help... = F1
Language-Specific Help on Selection = Shift+F1

Macro:
End Recording = Ctrl+K, )
Execute Last Macro = Ctrl+K, _
Start/Resume Recording = Ctrl+K, (

Source Code:
Comment Region = Ctrl+3
Complete Word = Ctrl+Space
Complete Word (backwards) = Ctrl+Shift+Space
Convert Selection to Lower Case = Ctrl+Shift+U
Convert Selection to Upper Case = Ctrl+U
Find All Functions = Ctrl+F8
Find Next Function = F8
Find Previous Function = Shift+F8
Jump to Matching Brace = Ctrl+]
Select Block = Ctrl+B
Select to Matching Brace = Ctrl+Shift+]
Un-comment Region = Ctrl+Shift+3

Source Control:
Add File = Ctrl+K, A
Add Folder = Ctrl+K, Shift+A
Commit Changes = Ctrl+K, C
Commit Changes in Folder = Ctrl+K, Shift+C
Compare = Ctrl+K, D
Compare Files in Folder = Ctrl+K, Shift+D
Edit = Ctrl+K, E
Remove File = Ctrl+K, O
Revert Changes = Ctrl+K, V
Revert Changes in Folder = Ctrl+K, Shift+V
Update = Ctrl+K, U
Update Folder = Ctrl+K, Shift+U

Tools:
Run Command... = Ctrl+R

User Interface:
Browser Preview = Ctrl+K, Ctrl+V
Focus on Editor = Ctrl+Shift+E
Show/Hide Code Browser Tab = Ctrl+Shift+C
Show/Hide End of Lines = Ctrl+Shift+7
Show/Hide Output Pane = Ctrl+Shift+O
Show/Hide Projects Tab = Ctrl+Shift+P
Show/Hide Toolbar Button Text = Ctrl+Shift+B
Show/Hide Toolbox Tab = Ctrl+Shift+T
Show/Hide Whitespace = Ctrl+Shift+8
View Source = Ctrl+K, Ctrl+S
View/Hide Indentation Guides = Ctrl+Shift+5
View/Hide Line Numbers = Ctrl+Shift+4
Word-wrap long lines = Ctrl+Shift+9

Snippets:
<b> Bold = Ctrl+K, Ctrl+H, B
<i> Italic = Ctrl+K, Ctrl+H, I
<u> Underline = Ctrl+K, Ctrl+H, U
<br/> Break Line = Ctrl+K, Ctrl+H, Return
<h1> Header 1 = Ctrl+K, Ctrl+H, 1
<h2> Header 2 = Ctrl+K, Ctrl+H, 2
<h3> Header 3 = Ctrl+K, Ctrl+H, 3
<h4> Header 4 = Ctrl+K, Ctrl+H, 4
<h5> Header 5 = Ctrl+K, Ctrl+H, 5
<h6> Header 6 = Ctrl+K, Ctrl+H, 6
<li> List Item = Ctrl+K, Ctrl+H, L
<ol> Ordered List = Ctrl+K, Ctrl+H, Ctrl+O
<ul> Unordered List = Ctrl+K, Ctrl+H, Ctrl+U
<p> Paragraph w/Dialog = Ctrl+K, Ctrl+H, Ctrl+P
<p> Paragraph = Ctrl+K, Ctrl+H, P
<table> Table 1 row 1 col = Ctrl+K, Ctrl+H, Ctrl+T
<tr> Table Row = Ctrl+K, Ctrl+H, R
<td> Table Cell = Ctrl+K, Ctrl+H, D
<pre> Preformated Text = Ctrl+K, Ctrl+H, T
<A> URI Link w/Dialog = Ctrl+K, Ctrl+H, Ctrl+A
<A> URI Link = Ctrl+K, Ctrl+H, A
<form> Form w/Dialog = Ctrl+K, Ctrl+H, Ctrl+F
<input/> Form Input w/Dialog = Ctrl+K, Ctrl+H, Ctrl+I
<select> Form Select w/Dialog = Ctrl+K, Ctrl+H, Ctrl+S
<option> Form Option w/Dialog = Ctrl+K, Ctrl+H, O
<textarea> Form Text Area w/Dialog = Ctrl+K, Ctrl+H, Ctrl+Q

----------
End of Document:
