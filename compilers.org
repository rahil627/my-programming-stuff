

may overlap with [programming-languages], [programming-concepts], and possibly more..

* process

systems langs (C, C++, rust, go, zig, etc.) -> target platform assembly
  - gcc, msvc, go build, etc.

high-level lang -> llvm ir -> target platform assembly
  - via llvm

high-level lang (optional: -> LLVM for optimizing) -> generated C (to link to consoles, mobile) -> target platform assembly
  - LLVM dropped C backend in v3.1  
    - this project revived it https://github.com/JuliaComputingOSS/llvm-cbe
    - however, this sounds impossible for any non-trivial program


* platform-specific

WARNING: for iOS and many consoles (except switch?), "cannot execute writeable regions", thus cannot use JIT compilation

mobile
  - iOS uses C(/objective-C)
    - yet somehow haxe's C++ could be used..??
  - Android uses Java
    - mainly for ui crap, for game dev, they just need access to the renderer..
      - not sure if java's C interop (jni) is used..

consoles:
  - all consoles are targeted via C/C++ compilers
    - as a direct path from high-level language to console hardware architecture is crazy..\


* some basics

from the end of the [[re-writing the ruby parser]] article

a parser is the part of the programming langauge that reads source code and converts it into a format that can be understood by the runtime. At the high level, this involves creating a tree structure that represents the flow of the program. When looking at source code, you can often see this tree structure in the indentation of code.

TODO: just finish and note that paragraph under background, i've read the rest..


* re-writing the ruby parser

TODO: link goes here..
  - dunno how to paste from system clipboard..
  - ohh right, there was a little output in the terminal about this..!!

CRuby's original parse.y was 14k loc!

as of 2023, there were 12 actively maintained parsers, 6 run-times, 6 tools (tree-sitter, etc.), creating a very fractured eco-system, as libs actually use different parsers, and as each time ruby updates, so do the parsers. At the time, only 2 non reference (CRuby) parsers supported pattern matching completely correct.

7 of the top 10 parsers use hand-written recursive descent parsers, and only 3 scripting langauges still maintain a parser generated by Bison (LR parsers), which is meant for context-free grammars. Ruby, and Python too, at times require a bit of context, context-sensitive. In order for Bison to parse Cruby, a whole bunch of context/logic/state has been pushed into the lexer. Most of the programming community has come to the same conclusion about their own parsers, and therefore have moved on to recursive descent. Also, it's possibly to reap the benefits of error-recovery.

in a small todo file by Matz on 0.95, he wrote in one line: hand-written parser(recursive descent)

re-designed and basically standardized the ruby syntax tree, for the first time. Also created serialization api so that other implementations such as JRuby and TruffleRuby can use and deserialize the syntax tree. With a standard syntax tree, then the community can start building tools that will work acorss all implementations.

error tolerance works via recovery, filling in missing keywords and nodes (parts of expressions)

the new perser ships with a language server and vs-code plugin

it has no dependencies: it is self-contained. This allows languages with good ffi/bindgen (rust/zig) to access tthe parser, and enable people to write ruby tooling in other languages.

it can parse 50k files from shopify in 5.5 seconds with 11mb max memory!

in order to support libs that use other parsers, and thus programs that use those libs, they began experimenting generating the syntax trees that other parsers create, which results in better performance
 

* C And C++ Interops
Linking/Including C++ libs into a C host program is possible but not advisable due to *the non-standardization of name-mangling*, however you can "spend a few days writing a C-style wrapper for the C++ library."
  - the other way around, i think works fine though(??)


> C++ can call C functions, `extern "C"` exists.
> C cannot call C++ function "out of the box".

"...for every single function (and all the overloads of that function).":
#+begin_src cpp
extern "C" foo_some_method(Foo &foo) {
  foo.someMethod();
}
#+end_src


