


long int vs int
Standard guarantees only that int is at least 16-bit and long is at
least 32-bit and sizeof(int) <= sizeof(long).

So for example on typical 32-bit platform are int and long both 32-bit,
on 64-bit Linux can be int 32-bit and long 64-bit etc






for (int i=1; i<10000; i+=2) //dont forgot about that third parameter






if you only know one [type of] language, no matter how well you know it, you're not a great programmer. - imperative (java, C++, python), functional (haskell, erlang), concatenative (factor, forth, cat, joy), logic (prolog, mercury), dataflow (labview, estereel, lustre, verilog, pure data, max/msp). shows languages are radically different







int x=0;
int *p = &x;//p holds the address of x
int &r(x);//r is a reference to x
//From this point *p == r == x
*p = 3;//change x to 3
r = 4;//change x to 4
//Up until now
int y=0;
p = &y;//p now holds the address of y instead.

references - must delete?
pointers - 
smart/shared pointers - in C++ only? auto_ptr?

initializing a reference
class Foo
{
public:
    Foo(Bar &rBar) : bar2(rBar), bar3(NULL)
    {
    }

    Bar bar1;
    Bar &bar2;
    Bar *bar3;
}

What is evil is making a reference to a dynamically allocated object and losing the original pointer.








if(condition1){if(condition2){if(condition3){//do something}}}
vs
if(!condition1||!condition2||condition3) return 0;
or
try{...}
catch(exception e){//do stuff}

swallowing exceptions and displaying message boxes is bad because you don't know when some other code is going to call yours and have no idea an exception occurred.

naming convention: booleans isEnabled


