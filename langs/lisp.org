

* common errors

invalid-read-syntax ")"
  - surely the most common error..
  - if you get this doing eval in emacs, try to run eval at different points in the code.. supposed to be at the end of the expression.. but it often behaves differently..
    - FIXME: maybe also a cursor bar style problem..?
      - try eval a few extra chars to the end of the expression..

FIXME: NOTE: cursor bar on left side of parens triggers hint, yet it highlights matching parens when on the right side, maybe a problem of curosor style..
  - shit, some syntax actually is a blessing, at least in the case of ruby, where there are no delimited chars, save whitspace



* notes

see emacs.org/dynamic langs

TODO: merge from vanilla emacs notes



#+begin_src elisp
(if (condition)
    (then-only-runs-one-expression)
    (else)
;; thus functions that handle multiple cdr(?) are useful
;;   - TODO: surely there's another way though..
;;     - i tried a list of exps: ((exp) (exp2) ..), but that didnt work..
(if (condition)
    (setq sym "something"
          sym-2 "something else"))

(cond (case
       (do-stuff))
      (case-2
       (do-stuff)))
;;  - switch?


#+end_src



it seems you can define a function (defun) within a function, and then call it..

i'm having trouble passing in a list of &rest args for some reason.. maybe just set a temp var to pass in..??


--

(defun ra/post-config ())
  - can use / in the name? for name-spacing?
  - requires (), even if empty :/


;; TODO: wtf is with these elisp comments?
;; one ; confuses the formatter
;; two ;; seems the way to go..

;;; denotes a heading that can be folded
  - i really like this feature, even if it's un-related to code--solely used by the editor / formatter..

*** some basics

defun in a defun test

#+begin_src elisp
(defun ra/test ()
  (defun ra/test-inner ()
    (which-key--echo "hello"))
  (ra/test-inner))

(ra/test)



(defun ra/test-hello ()
    (which-key--echo "hello"))

(ra/test-hello)
#+end_src



*** symbols

people generally use setq over set, for the convenience, as it is what is expected coming from other languages
  - the q stands for quoted, and you don't need to quote (') the var
  - exception: if the value is another symbol (not a literal), you can use set to set it to another symbol

https://www.reddit.com/r/emacs/comments/7jyv0o/whats_the_difference_in_setq_and_set/

lisp has “symbol” concept.

in “normal” languages like python php perl java etc, they have “identifiers”.

in lisp, these “identifiers” are “symbols”. The difference is that, the lisp identifier can be evaluated or stay unevaluated.

if symbols are always evaluated, they are just like identifiers in other non-symbol language.

but in lisp, identifier can be held unevaluated. When identifier is held unevaluated, it becomes an inert thing, somewhat like a string.

(setq x 1)

(message "%s" x) ; prints "1"

(message "%s" 'x ) ; prints "x"
;; this is printing the symbol itself
;; that is, the identifier x is unevaluated

To hold evaluation of a identifier, you “quote” it. Like this:

'x

(quote x)

Normally, you write

(set 'x 1)

meaning, you set 1 to the identifier x. You want to quote the symbol, because, otherwise, x will be evaluated, but that usually doesn't make sense, unless its value is another symbol.

while

(setq x 1)
will quote the 1st arg, the x, for you automatically.


* install lisp

emacs-lisp
  - included within emacs!


** sbcl

scoop install sbcl
sudo apt-get install sbcl

(exit) to exit sbcl, lol


*** install quicklisp

#+begin_src sh
sbcl
curl -O https://beta.quicklisp.org/quicklisp.lisp
sbcl --load quicklisp.lisp
#+end_src

#+begin_src common-lisp
(quicklisp-quickstart:install)

;; FIXME: debugger invoked on a QUICKLISP-CLIENT:SYSTEM-NOT-FOUND in thread
;;   #<THREAD "main thread" RUNNING {10048D01B3}>:
;; *features*
;;  - shows quicklisp installed.. hmm



;;(ql:add-to-init-file)
;; it's installed, but still throws an error :/
;; FIXME: (SB-C:COMPILER-ERROR SB-C::INPUT-ERROR-IN-LOAD :CONDITION #<SB-INT:SIMPLE-READER-PACKAGE-ERROR "Package ~A does not exist." {10013619C3}> :STREAM #<SB-SYS:FD-STREAM for "file /home/ra/.sbclrc" {1001360543}>)


;; just trying crap..
;; Load #P"/home/ra/quicklisp/setup.lisp"


;; System "lem" not found


;; TODO: urgh, try roswell?? lol
#+end_src



* install a lispy editor

emacs
  - yay!
  - emacs lisp

lem
  - an editor completely written in common lisp!
  - has several front-ends: ncurses, sdl2, etc.
  - https://github.com/lem-project/lem
  - learn to use it!
    - https://lem-project.github.io/usage/usage/

helix
  - (coming soon..)
  - scheme scripting
    - though rust at it's core, interacting via api
  
x/portacle
  - an emacs config specialized for common lisp
    - meh, i already learned doom-meow-emacs..
  - https://portacle.github.io/
  - scoop install win-portacle
    - "couldn't find manifest"

* learning resources:

https://github.com/GustavBertram/awesome-common-lisp-learning
  - *lisp koans*
    - https://github.com/google/lisp-koans

*land of lisp*
  - an old book that *teaches lisp by making games (or pieces of games..)*, in that cute old way when people took the time to write books well

*let over lambda*
  - a book about macros!
  - https://letoverlambda.com/
    - first 6 chapters are online, maybe in the process of being uploaded..??

https://gigamonkeys.com/book/
  - practical common lisp, formmated for digital viewing
  - not bad for a reference book..

on lisp
  - bottom-up programming, including functional programming, rapid prototyping, interactive development, embedded languages, and CLOS

https://github.com/rabbibotton/clog/blob/main/LEARN.md
  - learn by using CLOG, a gui that uses the browser as it's engine??
  - sounds like good immediate feedback..
  - it has a lot of examples and tutorials, but i'd rather stick ot the std lib


