

* TODO dark magicks (to explore..)
  - see starred repos under the category "dark magicks"
    - drb
      - *dRuby is a distributed object system for Ruby. It allows an object in one Ruby process to invoke methods on an object in another Ruby process on the same or a different machine.*
    - tombenner/ru
      - "Ruby in your shell!"
    - [adamwiggins/s-mage]/rush
      - "Ruby replacement for bash"
    - pry
      - "A runtime developer console and IRB alternative with powerful introspection capabilities."
        - TODO: i wonder why this hasn't made it into ruby yet.. or did irb catch up?

** TODO ai?
  - ruby-openai/mistral-ai
    - only needed if you pay for it..
    - (likely officially use python..)
  - huginn
    - "Create agents that monitor and act on your behalf. Your agents are standing by!"
      - might as well do this yourself.. and make it maintainable, readable..
      - it's just generated scripts and a task-scheduler, with some common "actions".. maybe some way that flow together..


* emacs bindings (..they never end!! :/)

spc-k-k
  - +lookup/documentation
    - NOTE: requires inf-ruby running
  - when on a word, and if it has docs on it
    - go to docs
  - when on a word, but doesn't have docs on it
    - choose other sources
      - *NOTE: this threw me off for some time.. maybe i do need to begin reading the manual..* emacs actually is complex..
  - when on an empty space, search module/method

spc-c-s
  - inf-ruby
    - irb in a buffer?
    - kinda works like lisp, in which you can throw in pieces of code to the dynamic runtime, to test bits; or, inspect it to see source 'n docs
      - it's a really cool workflow, especially for testing regions of code..
      - can just send a region of var declarations, some functions/modules/classes, then run 'em interactively

spc-c[ode]-d[ocs]
  - robe-docs
    - NOTE: requires inf-ruby running
  - module/method
  - seems to use ri as it's source..


* lang notes

NOTE: mostly from dragonruby (compatible with mruby)

method!
  - '!' denotes the object is altered/mutated

#+begin_src ruby

args.state.lasers << (laser a) # execute (this) first??, or to make it more clear that this is a function..? is there an order of precedence?
args.state.in.move_vector = (get_move_vector)

#+end_src

** TODO MERGE from dragonruby

#+begin_src ruby

# NOTE: merged from another file..
# NOTE: only merge what's practical to gamedev..

# TODO: see ruby crash course in repl.rb

# advanced

## seeems super useful, can use right now

options = { font_size: 12, font_family: "Arial" }
merged_options = { font_size: 10, color: "blue" }.merge(options)
puts merged_options.inspect
# Outputs: {:font_size=>12, :color=>"blue", :font_family=>"Arial"}
  # merge hashes!!

module StringExtensions
  refine String do
    def shout
      upcase + "!!!"
    end
  end
end

using StringExtensions

puts "hello".shout  # Outputs: HELLO!!!
  # extensions or "refinements for scoped monkey-patching"
    # very very useful!!


user = { name: "Alice", age: 30, address: { city: "Wonderland", zip: "12345" } }

case user
in { name:, address: { city:, zip: } }
  puts "#{name} lives in #{city}, ZIP: #{zip}"
else
  puts "No match"
end
# Outputs: Alice lives in Wonderland, ZIP: 12345
  # hash pattern matching!! very useful!!
  
  
  
  

# from samples, or from ai but i've seen it before


numbers = [1, 2, 3, 4, 5]
squared = numbers.map { |n| n * n }  # Squares each element
evens = numbers.select { |n| n.even? }  # Selects only even numbers
puts numbers.any?(&:even?)  # Outputs: true
puts numbers.all? { |n| n > 0 }  # Outputs: true
unique_numbers = numbers.uniq
  # data transformation
  
people = [{ name: "Alice", age: 30 }, { name: "Bob", age: 25 }]
person = people.find { |p| p[:age] > 28 }
puts person[:name]  # Outputs: Alice
  # TODO: merge into above examples


if object&.method
  # Do something if object and method exist (not nil)
end
  # safe navigation operator (&.)

enemies = [{ type: "goomba", alive: true }, { type: "koopa", alive: true }, { type: "goomba", alive: false }, { type: "koopa", alive: true }]
alive_enemies, dead_enemies = enemies.partition(&:alive) # splits into alive group and the rest
  # tuple(?).partition
  
names = ["alice", "bob", "carol"]
capitalized_names = names.map(&:capitalize)
  # symbol to proc shorthand
  
numbers = [1, 2, 3, 4, 5]
sum = numbers.reduce(&:+)
puts sum  # Outputs: 15
  # use & to convert a symbol to a block
  
  

  
  





# from ai:

## the more intersting ones for games

str = "hello"
str.freeze
str.upcase!  # Raises an error: can't modify frozen String
  # freeze an object to make it immutable!!

lazy_enum = (1..Float::INFINITY).lazy.map { |x| x * x }.take(5)
puts lazy_enum.to_a  # Outputs: [1, 4, 9, 16, 25]
  # hmmmmm
  
  
def fibonacci(n, memo = {})
  return n if n <= 1
  memo[n] ||= fibonacci(n - 1, memo) + fibonacci(n - 2, memo)
end
  # this one looks interesting for optimizing calculations..
  
class ExpensiveCalculator
  def initialize
    @memo = {}
  end

  def expensive_method(x)
    @memo[x] ||= x ** x
  end
end

calc = ExpensiveCalculator.new
puts calc.expensive_method(3)  # Outputs: 27
  # hmmmm
  # TODO: move this to snippets


(1..10).tap { |x| puts "original: #{x.inspect}" }
        .to_a
        .tap { |x| puts "array: #{x.inspect}" }
        .select { |x| x.even? }
        .tap { |x| puts "evens: #{x.inspect}" }
  # tap method-chaining.. hmmmmm
  
  
  
def call_block
  yield if block_given?
end

call_block { puts "Hello from the block!" }

proc_example = Proc.new { |x| puts x * 2 }
proc_example.call(3)  # Outputs: 6
  # blocks 'n procs, hmmmmm


class Example
  def hello
    "Hello, world!"
  end
end
example = Example.new
puts example.__send__(:hello)  # Outputs: Hello, world!
  # using send to call a method by name
  
  
  
  
  
  
  
## the more standard stuff

a, b = b, a
  # swap vars
  
text = "The quick brown fox"
modified_text = text.gsub("quick", "slow")
puts modified_text  # Outputs: The slow brown fox
  # quick string manipulation

case [1, "hello", 3.0]
in [Integer, String, Float]
  puts "Matched!"
else
  puts "No match"
end
  # pattern matching
  
  
  
result = Integer("not a number") rescue nil
puts result  # Outputs: nil
  # inline exception handling
    # neat!!
  
  
result = begin
           1 / 0
         rescue ZeroDivisionError
           "Cannot divide by zero"
         end
puts result  # Outputs: Cannot divide by zero
  # exception handling
  
user = User.new.tap do |u|
  u.name = "John"
  u.email = "john@example.com"
end
  # tap for cleaner code
  # don't quite understand this one..








## functional stuff

class MyClass
  def say_hello
    "Hello!"
  end
end

obj = MyClass.new
method_obj = obj.method(:say_hello)
puts method_obj.call  # Outputs: Hello!
  # get the method









# basics

# imports
require 'path/to/file_name'
  # relative to working directory
require_relative 'file_name'
  # relative to the current file!
autoload :SomeClass, 'some_class'
  # lazy load
    # The 'some_class.rb' file will only be loaded when SomeClass is accessed
SomeClass.new

include 'ModuleName'
  # can include to top-level context
  # or to classes


## branch, assignment
return if args.state.player[:cooldown] > 0
  # statement if condition

return unless args.state.player[:cooldown] <= 0
  # if not

# WARN: the only values that can fail conditional checks are false and nil

return if args.state.c.init # returns true?

||=
  # Whatever is on the left OR assign to the right
  # "Here's a fun Ruby thing: args.state.rotation ||= 0 is shorthand for "if args.state.rotation isn't initialized, set it to zero." It's a nice way to embed your initialization code right next to where you need the variable."

# WARN: don't use booleans with ||=
||= false
  # will never work but that's usually ok since what was in the variable before is nil which is as good as false in most cases
||= true
  # but the real trap is ||= true which will always overwrite the value with true not only the first time 
  # since a ||= b is just  a = (a || b), actually a || (a = b) (slightly different) which in case of true will never end well ðŸ˜›  because false || true will always be true ðŸ˜›


# functions
def attack damage, enemy
  # don't forget the comma!
end

def attack damage:, enemy:
  enemy.health -= damage
end

attack 3, goomba
  # order-based args
    # re-factoring can easily break the order
attack damage: 3, enemy: goomba
  # keyword args
    # far more scalable
    

def f(arg) end
f (a: 22, b: 33)
f {a: 22, b: 33} # same

def f(a:, b:) end
f (a: 22, b: 33)
f {a: 22, b: 33}
hash_arg = {a: 22, b: 33}
kw_arg_function hash_arg # deprecated in v3/v3.1 mruby
kw_arg_function **hash_arg # workaround

hash_gen_keywords {a:, b:, c:} # -> {a: a, b: b, c: c}

make_laser args, a
make_laser args, {x: x, y: y, w: l, h: l, dx: dx, dy: dy}

# DragonRuby's recommended use of parenthesis (inner function has parenthesis).
puts (add_one_to 3) # inner
puts add_one_to(3) # "conventional"
puts(add_one_to 3) # outer
puts(add_one_to(3)) # all
  
# method chaining
player.x = player.x.add(dx).clamp(0)
  # there are many methods added to objects to allow expressing things this way



# hashes and arrays
Array is one of the most powerful classes in Ruby and a very fundamental component of Game Toolkit.

An Array is an ordered, integer-indexed collection of objects, called elements. Any object (even another array) may be an array element, and an array can contain objects of different types.

Arrays in ruby are dynamic.

A Hash has certain similarities to an Array, but:
An Array index is always an Integer.
A Hash key can be (almost) any object.




,**hash
,*array
  # These are splat operators, they'll deconstruct your hash/array into arguments for a method. 

# destructure
array = [10, 20]
x, y = array # destructuring here is position based

# using spread (reverse splat?) for remaining
player = [5, 5, "Player 1", 5, 5] # x, y, name, w, h
player_x, player_y, name, *player_size = player # 5, 5, Player 1, [5, 5]

# splat operator

## for args
target = { x: 50, y: 50 }
def move_to(x:, y:)
  # moves player to x, y
end
move_to(**target)
  # hash splat

target = [50, 50]
def move_to(x, y)
  # moves player to x, y
end
move_to(*target)
  # array splat

old_hash = { a: 1, b: 2 }
hash = { a: 5, **old_hash, b: 6 } # => { a: 1, b: 6 }
  # args replaced by order of precedence

old_array = [2, 3, 4 , 5]
array = [ 1, 2, *old_array, 5, 6] # => [1, 2, 2, 3, 4, 5, 5, 6]
  # not for arrays tho..

"hashsplat is useful for moments when ~'a lot of the things i want to output are similar'"


def greet(*names)
  names.each { |name| puts "Hello, #{name}!" }
end

greet("Alice", "Bob", "Carol") # Outputs: Hello, Alice! Hello, Bob! Hello, Carol!








## hashes
screen ||= {0, 0, 720, 1280} # error
screen ||= {x: 0, y: 0, h: 720, w: 1280} # hashes need keys


## arrays







# structs
Person = Struct.new(:name, :age, :job)
john = Person.new("John Doe", 30, "Engineer")
puts john.name, john.age, john.job
john.age = 31



Person = Struct.new(:name, :age) do
  def birthday
    self.age += 1
  end
end

john = Person.new("John", 30)
john.birthday
puts john.age  # Outputs: 31
  # can add methods?? so.. it's a class..?





# classes

## anonymous
ghost_class = Class.new do
  def hello
    "Hello from the ghost class!"
  end
end

obj = ghost_class.new
puts obj.hello  # Outputs: Hello from the ghost class!
  # ghost class aka eigenclass aka anonymous class
  
  
str = "hello"
def str.shout
  upcase + "!!!"
end
puts str.shout  # Outputs: HELLO!!!
  # singleton method (per-object basis)
  # wow... this is interesting, and made really really simple
  
  

## normal/declared
class MyClass
  class << self
    def class_method
      "This is a class method"
    end
  end
end

puts MyClass.class_method  # Outputs: This is a class method
  # singleton method
  
  
obj = "I'm unique" # can use any object..?
class << obj
  def unique_method
    "Unique method!"
  end
end

puts obj.unique_method  # Outputs: Unique method!
  # singleton class..! whoa.. 


class MyClass
  def self.class_method
    "I'm a class method"
  end

  private_class_method :class_method
end

if MyClass.method_defined?(:class_method)
  puts "Class method is defined"
else
  puts "Class method is not accessible"
end
  # so there are private methods..





# everything in an object  
,**methods defined at the "top level" are defined as instance methods on Object, so they're inherited by everything.** The top-level context itself is a special instance of Object called "main"; by defining these methods with self., they become singleton methods of that top-level context (which is where DR looks for them), and they are not inherited by every other object in the system.

The "surprising outcome" is specifically that Object ends up being the owner of these methods, the effect is that you can call add with an implicit receiver (as in within an object), but that Object.new.add(4, 6), and [].add(4, 6), and Module.add(4, 6), and $gtk.add(4, 6) all also work.

def tick
  # ...
end
  # if on the top-level context, will be inherited by *everything*
  # use self to avoid this:

def self.tick
  # ...
end








# from getting started tutorial
   
args.outputs.labels << [580, 400, 'Hello World!']
  # The "<<" thing says "append this array onto the list of them at args.outputs.labels)
  
args.state.rotation ||= 0
  # shorthand for "if args.state.rotation isn't initialized, set it to zero." It's a nice way to embed your initialization code right next to where you need the variable.
  #  - amazing..!

args.state.laser.trash ||= true
  # nested field mades on-the-fly..?



# loops
# loops are quite different..
array = ["a", "b", "c", "d"]
array.each do |char|
  puts char
end  

array.each do |char, i|
  puts "index #{i}: #{char}"
end

3.times do |i|
  puts i
end

(0...4).each do |i|
  puts i
end
  # range block exclusive (three dots), excluding last number
  # 0-3, 4 matches the number of elements in an array

(0..3).each do |i|
  puts i
end
  # range block inclusive (two dots), including last number
  # 0-3

#+end_src
** TODO MERGE meta-programming

#+begin_src ruby
# NOTE: merged from another file..
# NOTE: only merge what's practical to gamedev

# what i think of when i hear meta-programming

## the dirty stuff
  - eval, class_eval, instance_eval
  
class MultiMethodClass
  [:foo, :bar, :baz].each do |method_name|
    class_eval <<-RUBY
      def #{method_name}
        puts "#{method_name} called"
      end
    RUBY
  end
end

obj = MultiMethodClass.new
obj.foo  # Outputs: foo called
obj.bar  # Outputs: bar called
obj.baz  # Outputs: baz called
  # class_eval
  
  
def evaluate_code(code, context)
  context.instance_eval(code)
end

class MyClass
  def initialize(value)
    @value = value
  end

  def get_value
    @value
  end
end

obj = MyClass.new(42)
result = evaluate_code("@value + 8", obj)
puts result  # Outputs: 50
  # instance_eval
  
  

  
  


## mix-ins
obj.extend(ModuleName)
  # mix-in module dynamically
    # wow... incredibly simple..(!)
    
    
module ClassMethods
  def class_method
    "Class method from module"
  end
end

module InstanceMethods
  def instance_method
    "Instance method from module"
  end
end

module MyModule
  def self.included(base)
    base.extend ClassMethods
    base.include InstanceMethods
  end
end

class MyClass
  include MyModule
end

puts MyClass.class_method  # Outputs: Class method from module
obj = MyClass.new
puts obj.instance_method  # Outputs: Instance method from module
  # included hook used to add class methods
    #  i didn't quite understand, but it seems useful for modular coding!    
    
    
    
    
    
## class methods (functions) and attributes (data) 
class MyClass
  [:attr1, :attr2, :attr3].each do |attr|
    attr_accessor attr # doesn't have to be in top-level of a class??
  end
end

obj = MyClass.new
obj.attr1 = "Value"
puts obj.attr1  # Outputs: Value
  # dynamic attributes
    
    
class DynamicMethods
  def self.create_method(name)
    define_method(name) do # i think define_method is a keyword
    # or define_singleton_method
      "This is method #{name}"
    end
  end
end

DynamicMethods.create_method(:hello)
obj = DynamicMethods.new
puts obj.hello  # Outputs: This is method hello
  # dynamic method definition
  # i have to think about this some more..
    
    
    
class GhostMethods
  def method_missing(name, *args) # i think method_missing is a keyword
    puts "You called #{name} with #{args.inspect}"
  end
end

obj = GhostMethods.new
obj.anything_you_like(1, 2, 3)  # Outputs: You called anything_you_like with [1, 2, 3]
  # seems like for mistake handling
  
  
  
class TrackMethods
  def self.method_added(name)
    puts "New method added: #{name}"
  end

  def sample_method
    # Does something
  end
end
# Outputs: New method added: sample_method
  # method_added
    # seems good for debugging when methods are added






## DSL
class Person
  attr_accessor :name, :age

  def self.attributes(*names)
    names.each do |name|
      attr_accessor name
    end
  end

  attributes :height, :weight, :eye_color
end

john = Person.new
john.height = 180
puts john.height  # Outputs: 180
  # DSL
    # don't quite see it.. yet.
    
    
    
    
    
# other neat stuff

class DynamicCaller
  def say_hello
    "Hello!"
  end
end

obj = DynamicCaller.new
puts obj.send(:say_hello)  # Outputs: Hello!
puts obj.__send__(:say_hello)  # Outputs: Hello!
  # dynamically call methods
  
  
class MyClass
  def my_method
    puts "Original method"
  end

  alias :original_method :my_method

  def my_method
    puts "Wrapped before"
    original_method
    puts "Wrapped after"
  end
end

obj = MyClass.new
obj.my_method
# Outputs:
# Wrapped before
# Original method
# Wrapped after
  # using method aliasing for wrapping old functions
    # great for altering a function without refactoring


#+end_src


* tool kit (in the std lib)

rubocop
  - formatter


** ri

ri --no-gems
  - CONCLUSION: *a good IDE (with jump to definition, class hierarchy panel, etc.) + AI are severely needed..*
    - *you cannot guess what the lib does by it's name.. :/*
      - open-source woes, though can be fun to name things..
  - interactive ruby docs
    - "ruby interactive?/introspection?"
    - *i'm guessing it's meant to be used as a lib to provide docs to other programs, namely, editors..*, moreso than being used on it's own..
  - for core + std-lib stuff: still 208 gems!
    - 250 with it
    - a few important gems such as nokogiri aren't in the ruby/std
  - module[tab, tab] to see classes
  - module::class[tab, tab] to see methods
    - class methods aren't organized by super classes :/
   - TODO: OR: maybe can just make a local copy of the ruby repo.. then try the emacs spc-k commands
type keyword, then press tab (in select mode)
  - not so good with modal text editing..



** irb
https://news.ycombinator.com/item?id=24637797
  - "Very similar to this idea, simply using â€˜irbâ€™ for one-off data munging and simple automations is very handy. Thatâ€™s one of my go to tools when I am not sure exactly what I want to do with the data, and being able to poke at the intermediate steps as I transform it is handy. If I then come up with a pipeline that is useful, it only takes a minute to copy paste what I figured out in IRB to a file and save it as an executable script for future use."




* ruby internals

see my notes on/in [compilers]

https://ruby-compilers.com/
  - this is a great little web-site for all your compiler needs..

  
see [play/ruby-limits.rb]
  - for an inquiry into how ruby data is stored
    - might as well just read the C code though..

TODO: should check out "ruby under a microscope" book
  - sounds like an "how it's made" episode.. with a bunch of diagrams 'n all..

these three are made by the same person:
  - prism parser
    - see [compilers notes]
  - syntax-tree
    - "Syntax Tree is a suite of tools built on top of the internal CRuby parser. It provides the ability to generate a syntax tree from source, as well as the tools necessary to inspect and manipulate that syntax tree. It can be used to build formatters, linters, language servers, and more."
  - yarv
     "A Ruby object layer on top of the YARV virtual machine"

- yjit
- CRuby

- JRuby
- TruffleRuby


* install ruby

"NOTE: While system Ruby installations exist (e.g., on macOS), it is generally recommended to use a version manager like RVM or rbenv for development to avoid altering the system Ruby and ensure compatibility with specific project requirements."
  - thanks ai..


** windows

rubyinstaller
  - windows is so much better..

or scoop!

Linking ~\scoop\apps\ruby\current => ~\scoop\apps\ruby\3.3.4-1
Adding ~\scoop\apps\ruby\current\bin to your path.
Adding ~\scoop\apps\ruby\current\gems\bin to your path.

*** maybe not the best dev experience

ruby on windows not the best experience, but damn good:

https://www.reddit.com/r/ruby/comments/12z4j3g/is_ruby_still_a_hassle_to_work_with_on_windows/
  - "Here's the deal: WSL2 is 100% compatible and has great performance.

  It's still not as good as just using a Ubuntu desktop which is what you should do unless you are forced to use Windows, but the biggest pain is that the only editors that really work seamlessly are VSCode and Vim.

  I'm sorry, but for Ruby VSCode is just a text editor without many features besides syntax highlighting. Most of the plugins feel like they just barely work, and there is really nothing to help with ERB. The debugging is unbelievably hard to get working. Solargraph is impressive, but is more like a little spice that occasionally shines through than something you can really truly rely on. None of the other language servers are even close. If all you want is a fast text editor, then you may as well use Vim.

  So if you want RubyMine you have to use JetBrains' remote features, which suck, or Linux native RubyMine in WSLg, which also sucks for many obvious reasons including that it feels slow and has many window manager glitches. (Yet I have been told many times on reddit that WSLg is just fine by apparent masochists.)"


    - Indeed, I would also argue that VSCode's JavaScript, TypeScript, and React features are on par with JetBrains' plugins in many ways, offering better help and feedback and perfectly usable refactoring. It feels very smooth and reliable. That's why people love VSCode.




    


  
** linux

it sounds like RVM uses pre-compiled binaries..
  
*** install mise (yet another language/run-time package manager)

https://mise.jdx.dev/getting-started.html

#+begin_src sh
sudo apt update -y && sudo apt install -y gpg sudo wget curl
sudo install -dm 755 /etc/apt/keyrings
wget -qO - https://mise.jdx.dev/gpg-key.pub | gpg --dearmor | sudo tee /etc/apt/keyrings/mise-archive-keyring.gpg 1> /dev/null
echo "deb [signed-by=/etc/apt/keyrings/mise-archive-keyring.gpg arch=amd64] https://mise.jdx.dev/deb stable main" | sudo tee /etc/apt/sources.list.d/mise.list
sudo apt update
sudo apt install -y mise
#+end_src

NOTE: this handles installing ruby-dev/el package, which is needed to build C extensions

*** install ruby using mise

https://mise.jdx.dev/lang/ruby.html

mise ls-remote [language/run-time]
  - check all versions available

mise install ruby
  - this will download the latest released version
    - (and not some old bullshit that linux restricts you to)
    - (by default it won't select preview/dev versions)
  - it runs make.. oh fuck..
    - SERIOUSLY, WTF
      - TODO: WHY NO BINARIES?
        - why delegate the task to make EVERY user crunch their computer, when they could provide binaries for the most popular OSs??

echo 'eval "$(~/.local/bin/mise activate bash)"' >> ~/.bashrc
  - load upon start of shell (to handle env bullshit for you)

ruby -v
  - test it out!

mise use --global ruby[@version]
  - to switch the version
  - this adds it to '~/.config/mise/config.toml'

mise use ruby[@version]
  - to use it in a directory
  - (this also adds it to '~/.config/mise/config.toml')
  
mise exec ruby[@version] -- ruby [command goes here]
  - to run commands from specific versions
*** if it fails to install

NOTE: i gave up.. this is def ruby's greatest problem

mise cache clean

try again
  - (mise install [lang])

    
other problems:
    
if it fails to build psych
  - sudo apt install libyaml-dev

  
* deployment

this is why portable programs are just wayyyy better.. arrrrgh..
  - surely there must be a way to atleast just pack the ruby parser with the program..??
    - see traveling ruby
  

* ruby in your shells (cli & pipes)


https://www.honeybadger.io/blog/ruby-unix-command-line/

# not so useful...
echo "puts 2+2" | ruby

# useful!
ruby -e "puts 'code goes here'" arg1 arg2 argN
ruby -e 'puts ARGV.inspect' apples bananas pears oranges
  - ["apples", "bananas", "pears", "oranges"]

# check web-page for a reg-ex using only ruby
ruby -e "require 'open-uri'; puts open(ARGV.first).read.scan(/starr/i).count" [some-url]

# piping 101
cat moby-dick.txt | ruby -e "puts STDIN.read"
(outputs entire text)

# combining with another unix tool for fetching
curl [some-url] | ruby -e "puts STDIN.read.scan(/starr/i).size"

# loop through lines and do something (print file extensions)
ls | ruby -e 'STDIN.each_line { |l| puts l.split(".").last }'
# same thing using -n to loop each line, and $_ meaning the current line
ls | ruby -n -e 'puts $_.split(".").last'



    
* some useful gems

sequel
  - database toolkit

ffi
  - https://www.rubyguides.com/2019/05/ruby-ffi/
    - grabs a function from C's std lib libc
    - uses VLC media player's lib (written in C)

opal
  - ruby to js transpiler

rubyinline
  - https://github.com/seattlerb/rubyinline
  - run ffi code inline (in a ruby code file)!




maybe not so useful..:

gui
  - TODO: i wonder if there's one that generates a simple web app, like that one python lib..
  - https://www.reddit.com/r/ruby/comments/10rugw3/2023_best_ruby_gui_library/
    - in general, ruby, like haxe, just doesn't have enough support for gui, as it would have to just bind Qt, GTK, or another cross-platform gui framework written in C/C++
      - TODO: or just C?
  - https://github.com/AndyObtiva/glimmer
    - DSL wrapper for many (retained) gui back-ends
    - similar to haxe-ui
  - https://github.com/vaiorabbit/ruby-imgui
    - imgui wrapper
    - the only useful one nowadays..






# start a new project

# create a Gemfile in the working directory with the following lines:
source "https://rubygems.org"
# gem 'gem-to-include'

# installs all gems using the Gemfile
bundle install
# make sure it's installed in the right place
# bundle info gem-name


# add a debugger
# ensure rdbg debug extension is installed
# control+shift+l in vscode, then click add config file, select rdgb
# press 'debug current file with rdbg', add command flags, then can add breakpoints 'n debug!


# use a LSP

# OPTION: using Ruby LSP (by shopify), rather still new as of 2023
# if the vs code extension doesn't exist, install it manually by file
# https://www.reddit.com/r/ruby/comments/124vb7i/vscode_now_has_documentation_for_ruby/
# https://marketplace.visualstudio.com/items?itemName=Shopify.ruby-lsp
# (in the version history tab)
# https://github.com/Shopify/vscode-ruby-lsp
# https://github.com/Shopify/vscode-ruby-lsp/issues/782
# no need to do anything! :)
# should start automatically once a ruby file is opened, or a project folder with it is opened
# if not, use command '>Ruby LSP Start'
# to debug use command '>Debug: Add configuration...'



# OPTION: using solargraph lsp
# create a Gemfile in the working directory with the following lines:
source "https://rubygems.org"
gem 'solargraph', group: :development # lsp
# gem 'gem-to-include'

# automatically add docs
# should have had this setup
# yard config --install-yri

# manually add docs
# re-generates docs for ALL gems
# run from anywhere?
# TODO: is this necessary to do every-time you add a gem??
yard gems

# generate docs for gems only used in the project? (to .yardoc/)
# run in project directory
yard docs





# making a gem
# use bundler
???





** formatters and linters

conclusion: stick to rubocop, as it ships with ruby

all of the formatters (rubocop, rubyfmt, prettier, etc.) are options in the main ruby vscode extension's settings
  - the crux of open-source.. :/
  - before the prism parser, they all used different parsers too! :/
    
rubocop does more than formatting, it's a deep *linter* that'll fix 'n optimize your code
  - !!

formatters:
rubocop
  - the first main one
  - **comes pre-installed with ruby**
    - welp, that's that!
rubyfmt
  - written in rust and very fast
prettier
  - based on javascript's prettier linter
    - urgh, and probably requires npm too!

formatting standards:
standard
  - a standard immutable config (because people can't agree), using rubocop
    - TODO: could try this out..
rufo
  - like standard but with a different taste/opinion













solargraph:
another lsp that's more featureful, but takes more effort to work: must use the yard gem to generate docs (as opposed to the standard rdoc, which the main ruby lsp uses)

https://www.reddit.com/r/ruby/comments/ml3zs2/which_one_is_a_better_vs_code_language_server_for/
  -  "Solargraph has more features. It can inference types and preview docs. But it requires building yard docs for all your gems, which can take a lot of time and be a big hassle."
  - The vscode-solargraph extension is designed to work well alongside vscode-ruby. I frequently use both, typically with `"ruby.useLanguageServer": false` so code intelligence features like autocompletion come from Solargraph.

    If you use vscode-ruby primarily for the debugger, vscode-ruby-debug is also an option.

# add this to the Gemfile
gem 'solargraph', group: :development

# install yard cli
# TODO: conflicts with 'gem install yard'??
sudo pacman -S ruby-yard

# generate docs for all ruby gems
# yard gems









can use binding.pry in code to break it and inspect everything up to that point
pry replaces irb (comes bundled with ruby)? or use both?
`cat filename`.capitalize
or
`cat filename`.pry # "goes into" the returned string, then can execute string methods
capitalize!
provides a very interactive way to use ruby, learning it's common methods along the way
can completely replace shell for most stuff


SUPER COOL STUFF

https://github.com/pry/pry#command-shell-integration
`ls -l`.split("\n")
  - normally use back-ticks for command substitution

file_names=`ls -l`
  - store it in a temp repl var

.cat #{Dir['*'].sample} | wc -l
  - use . to begin running a shell command (instead of using pry)
  - use string interpolation like syntax "#{string}", without quotes, to interpolate ruby code

.echo #{puts object} | rg '2' # searches the object.to_s

.echo #{p 'ls`.upcase() + `ls`} | rg doc
  - can even combine command sub with shell-mode



gem install pry-doc

# irb
# ruby's default repl irb is awesome, containing autocomplete!

# ri
# ruby's console app to search documentation
# Class#method
rdoc # re-builds docs?

# ruby comes with a web-server!
ruby -run -e httpd

# find maintained libs here
https://www.ruby-toolbox.com/
  - , great for choosing the best lib for a specific purpose (category)
https://github.com/markets/awesome-ruby

# debug
try the user castwide's (maintainer of solargraph) debug extension

https://marketplace.visualstudio.com/items?itemName=KoichiSasada.vscode-rdbg
  - can try? vs pry?







# just do it & ref

https://github.com/planetjekyll/awesome-jekyll-plugins
https://github.com/benbalter/
  - wrote most of the plugins thate are included by default for Jekyll
  - ***extremely* clean design**, beautiful really... i love it!!! :D
    - but i'm not really sure if that's better than just writing it all in a single main function..., if it were actually used as a class, it'd make sense... but i guess this is the ruby "everything is an object" way..?
  - for example: https://github.com/benbalter/jekyll-titles-from-headings/blob/main/lib/jekyll-titles-from-headings/generator.rb

then, after reading some plugins, you'll be able to read Jekyll itself! :o
https://github.com/jekyll/jekyll/tree/master/lib


## ref
https://github.com/ruby/ruby
  - open-source :)
  - https://github.com/ruby/ruby/tree/master/lib

https://hyperpolyglot.org/scripting
  - great to see where it differs and excels over python

https://github.com/markets/awesome-ruby
  - **github** (?? no way!!), gitlab, discourse, mastodon, jekyll, tons of web frameworks 'n templating languages... whoa... i didn't even know...

https://github.com/trending?l=ruby

https://www.ruby-lang.org/
  - official site

https://docs.ruby-lang.org/en/master/
  - official docs, also on github?

https://www.rubydoc.info
  - like a package manager, but for docs. includes the readme of each package

http://ruby-doc.com/docs/ProgrammingRuby/
  - a complete book, wordy, tons of examples, very comprehensive, looks great!
  - the page on "Object-Oriented Design Libraries" is great, as i've never heard about them
  - "built-in classes and methods"
  - "standard library"
  - "threads and processes"

https://en.m.wikibooks.org/wiki/Ruby_Programming
  - feels like an alt unofficial site




# tools
https://www.ruby-lang.org/en/documentation/
  - contains a list of IDEs, text editors, 'n plugins
  - for vim, vim-ruby and RSense are mentioned
    - RSense is also used for emacs
  - from a reddit post dated ~2020, RubyMine (JetBrains) vs VS Code, it seemed VS Code was taking over, along with simpler editors like atom, vim, etc., but it sounded like many people have problems, probably because of use of Ruby's complex features not working well with the language server...



useful libs:
https://docs.ruby-lang.org/en/master/English.html
  - basically, you can alias anything in ruby, so, you can pretty much make your own language! :D
https://github.com/pry/pry
  - next-level shell hackery



# why?
i prefer the syntax, expressiveness, clean 'n tidyness, and fun of ruby over python :)

its also a funny way to write very clean simple scripts in a more functional style

anyway, anything is better than bash!
-


basically, i just want to use Ruby for shell scripting, because bash is hella ugly, and i don't think zsh really fixes that due to compatibility with bash (posix). Fish is an interesting alternative, but, anyway, i think Ruby can be a cool general-use "scripting" langauge--basically glue for all sorts of every-day problems :)

# learn
# 1. learn x in y minutes
todo: get link


# 2. jump in

see the source code of Jekyll plugins
then see the source code of Jekyll


# useful links

https://www.ruby-lang.org/en/documentation/
  - main site, includes links to many now ancient classic tutorials, but it's better to just read Jekyll code, or something similar to what you want to do
  - **good from other langauge page**
  - **good ruby in 20 min page**
  - **how to use gems**: https://www.ruby-lang.org/en/libraries/
  - external links
    - tuts:
    - https://poignant.guide
      - comic-style, super adhd, but def special
    - https://pine.fm/LearnToProgram/
      - for complete noobs, just goes over the language, but good site style
    - http://rubykoans.com
      - good interactive exercise, but the content is boring, as it doesn't use any "standard libs" or external libs, or any *real use*
    - https://try.ruby-lang.org
      - contains many examples to quickly go through


https://en.m.wikibooks.org/wiki/Ruby_Programming
  - in addition to being a wikibook, it contains a lot of useful links




https://ruby-doc.org/core-2.5.0/Kernel.html#method-i-exec
https://ruby-doc.org/core-2.5.0/Kernel.html#method-i-system
https://ruby-doc.org/core-2.5.0/Kernel.html#method-i-spawn
https://ruby-doc.org/core-3.1.1/IO.html

kernal
- kernal contains most keywords, and base object methods?
  - exec, replaces current process to execute something
  - eval, interpreter
  - system, runs in a "subshell" (another process?)
    - i think this is the one you'd often use for batch files
  - spawn, "similar to system but it doesn't wait for the command to finish"
    - "The parent process should use Process.wait to collect the termination status of its child or use Process.detach to register disinterest in their status; otherwise, the operating system may accumulate zombie processes."
    - "has bunch of options to specify process attributes:"


# tutorials:

make sure you have a good set-up: vs code with ruby extensions, nvim with vim-ruby, or whatever, ad this it should be pretty easy to just get completion for everything for a "everything is an object" language

these three chapters look useful: otherwise, it's just the same ol' programming stuff... it's definitely much better to just jump into source code..

https://learnbyexample.gitbooks.io/ruby-scripting/content/chapters/Executing_external_commands.html
https://learnbyexample.gitbooks.io/ruby-scripting/content/chapters/File_processing.html
https://learnbyexample.gitbooks.io/ruby-scripting/content/chapters/Regular_expressions.html
  - https://github.com/learnbyexample/Ruby_Scripting

https://www.techotopia.com/index.php/Working_with_Files_in_Ruby



# commands
#!/usr/bin/env ruby
system('clear')
system('echo Hello $USER')



#!/usr/bin/env ruby

cmd1 = 'ls out.txt' # true if the file exists
cmd2 = 'grep "foo" out.txt' # false if none found
cmd3 = 'xyz' # nil because command not found

for cmd in [cmd1, cmd2, cmd3]
  puts "Command: #{cmd}"
  rv = system(cmd)

  # inspect method will display human readable representation of object
  puts "system return value: #{rv.inspect}"
  puts "Command exit status: #{$?.exitstatus}" # special var $? detils include PID/exit status/etc
  puts '-' * 30
end


# save stdout to a var
>> working_dir = `pwd`
=> "/home/learnbyexample/ruby_programs\n"
>> working_dir.chomp
=> "/home/learnbyexample/ruby_programs"

# use %x to use different delimeters, in case of character problems
>> nums = %x/seq 3/
=> "1\n2\n3\n"
>> puts nums # stdout
1
2
3
=> nil

>> foo = %x(echo `seq 2`).chomp
=> "1 2"

# only stdout is saved
>> files = %x{ls *.txt *.log}
ls: cannot access '*.log': No such file or directory
=> "out.txt\n"




irb command for repl



$ type env ruby
env is /usr/bin/env
ruby is /usr/local/bin/ruby

$ cat hello_world.rb
#!/usr/bin/env ruby

puts 'Hello World'

$ chmod +x hello_world.rb
$ ./hello_world.rb
Hello World



* resources 


meh.. just make stuff!



https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-python/
  - succintly lists differences with python
  - i def prefer ruby in just about every decision!

https://github.com/martinmurciego/good-books/
  - a few ruby books, along with a few others




practice:
https://try.ruby-lang.org/
  - simple little interactive lang tutorial

https://learnbyexample.github.io/books/
 - practice examples 'n exercises for common cli stuff using ruby! :D  - ruby -e 'command' can be used to replace grep/sed/awk, and more
  - ruby one-liners cookbook
    - https://learnbyexample.github.io/learn_ruby_oneliners/one-liner-introduction.html
  - ruby regex

https://github.com/defunkt/choice
  - example of writing a simple dsl to parse cli options



