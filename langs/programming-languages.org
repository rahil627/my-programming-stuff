
also see [compilers]

* some random notes

** TODO casey muratori's performance-aware programming [video] series

to make me hate ruby, and stick to haxe, without most features, lmao

https://www.computerenhance.com/p/table-of-contents

"This series is designed for programmers who know how to write programs, but don’t know how hardware runs those programs. It’s designed to bring you up to speed on how modern CPUs work, how to estimate the expected speed of performance-critical code, and the basic optimization techniques every programmer should know."

this is a huge series, but here' a few enticingly-titled ones:

often said:
*there's only two things that will improve the performance of a program: you can reduce the total number of instructions you're asking the CPU to do, or you can alter those instructions to move more efficiently through the CPU. That's really all you can do: reduce the number, or increase the speed.*

https://www.computerenhance.com/p/welcome-to-the-performance-aware
  - intro
  - "I needed a term to distinguish what we’ll be doing in this course from what we used to call “optimization”.
    - "It (optimization) refers to taking a particular program - often on a particular piece of hardware - and trying to maximize the performance. Typically this involved a lot of special-purpose knowledge about that hardware. It often meant getting really creative with how you manipulated parts of the hardware to get extra performance"
    - "But nowadays we have entered an era of software where there's a different problem... Nowadays, due to common programming practices, tool chains, methodologies - whatever you want to call the overall way in which we program - the average program tends to be extremely slow... Modern software is more like 1000 times slower than it should be."
    - "What's missing is a general performance awareness so that the software we produce can be more reasonably performant... just not be horribly inefficient."
    - "I would argue there is always a business case for performance-aware programming - learning how performance works and then making smart, reasonable decisions based on that. It pays tremendous dividends, either in terms of user experience or in terms of lower server farm bills, or a host of other things like that."
    - "It’s designed to give you all of the information you need to understand why software is either fast or slow, and to understand how the decisions you make affect the gradient of software performance. It’s an effort to try to get everyone back onto the same page where we're no longer writing software that's 1000x times slower than it should be, or 10,000x times slower than it should be."


https://www.computerenhance.com/p/waste
  - TODO: watch the video
  - *5 multipliers*
    - #1. waste
      - waste instructions

https://www.computerenhance.com/p/instructions-per-clock
  - "How many instructions is the CPU executing in a single clock cycle?"
  - "if you get rid of all the instructions you really don’t need, and you're left with just instructions you do need, there's still a great deal of variability in how fast the CPU can actually do those instructions."

https://www.computerenhance.com/p/clean-code-horrible-performance
  - TODO: watch the video (i read the transcript)
    - as a recap, and fun
  - this one's transcript is much longer
  - replacing an extremely simple use of polymorphism (class inheritance + virtual methods) with structs and a switch statement led to a 2x increase, and using a table (a const array) led to 15x increase, and with optimization via AVX (SIMD stuff), 22x
    - note: this is just a very very simple example program run 1000x
    - *THIS IS KINDA INSANE..*
  - moreover, writing in a more data-function way, it's easier to see patterns, and so at one point he was able see and combine the math, which otherwise would've been two tables, or two switch (or worse: two class virtual methods)

*classes are "indirection", because they are allocated on the heap, requiring a pointer to goto it*

*virtual/inherited methods are an "indirection", because every-time they are called, they must look up (at run-time) which function to call*
  - from wiki
    - "Whenever a class defines a virtual function (or method), most compilers add a hidden member variable to the class that points to an array of pointers to (virtual) functions called the virtual method table. These pointers are used at runtime to invoke the appropriate function implementations, because at compile time it may not yet be known if the base function is to be called or a derived one implemented by a class that inherits from the base class."
    - virtual method table = vtable
  - from wiki on multiple dispatch:
    - "In more conventional, i.e., single-dispatch object-oriented programming languages, when invoking a method (sending a message in Smalltalk, calling a member function in C++), one of its arguments is treated specially and used to determine which of the (potentially many) classes of methods of that name is to be applied. In many languages, the special argument is indicated syntactically; for example, a number of programming languages put the special argument before a dot in making a method call: special.method(other, arguments, here), so that lion.sound() would produce a roar, whereas sparrow.sound() would produce a chirp."
      - "the vtable method uses the function name and not the argument type as its lookup key, and does not scale to the multiple dispatch case."
      - dynamic dispatch seems kinda rare: most notably CLOS of common lisp and julia

TODO: it might just be better to read various lang compilers to see how bad this all is..


** TODO a diary entry by matz in 20040807

textbringer system clipboard woes :/


** j blow on mookash podcast about jai
  - *C macros straight up replaced a string, making it powerful, as you could just replace half-identifiers, half-expressions, or anything. It doesn't have to be compilable code. But that's also what made it completely un-debuggable. Non-hygenic: global variables in the namespace are used, and must be careful.*
    - hygenic macros, have it's own name-space
  - send as a syntax tree, and can move nodes around, similar to lisp
  - why choose to have both macros and compile-time execution?
    - to have the ability to invoke it anywehre in the middle of a program, in addition to a separate place elsewhere
  - **problem not having static typing: type an undeclared identifier, and it takes a half-hour to debug, because i tried to use it but it was an empty string, whereas in a statically-typed langauge it takes a 1/10th of a second.**
  - *the first computer class he went to at Berkeley used Scheme!! but debugging it was a tremendous waste*
    - *this is by the way of the SICP book, that's what his first class was, and he would NOT teach that way, at all.*
  - linux sucks, because open-source sucks.
    - yep, but nowadays, propietary windows and mac suck too!
      
  - ... (another session)
    
  - ~55m explains why C++ sucks
    - redundant information is duplicated a thousand times (headers) and then compacted (linked) together.. why?
    - made jai because he was suffering from C++, especially during the dev of the witness
  - current "creativity"/effort wasted on javascript, javascript frameworks, etc.
    - even ai people are just "script kiddies"
    - even most language makers now rely on llvm
  - *pillars: joy of programming / low friction, performances, simplicity, for good programmers*
    - scheme is an extremely simplified lisp, but it's simplification causes problems
    - *"i don't know anybody who knows the whole language [C++], that's how complicated it is"...i stopped at around C++ 11 or 13 and stopped looking at new features*
  - jai is complex
    - making macros simple is hard, and making it "cross dll boundaries"
    - *have much more expressive power than C++ by a large margin*
    - just not as simple as he wants it to be, yet
  - great rant on people making shit and posting it on hacker news with a stupid product name
    - *like the syntax of the language, he doesn't care, and can change it easily*
  - in addition to making braid: anniversary addition, made a meta quest 3 simulation game with the engine he plans to release commercially, along with the language
  - 1:37m
    - godot is like unity, use ui to make a game, for his engine, though there's an editor and entity fields it's programmer-centric.. (vague)
  - just two people working on the langauge
    - rafael luba is the other one
      - TODO: also was interviewed
        - did a bunch of random systems programming contracts
  - 2024 layoffs, worst in the history of video game industry
  - how to hire
    - technical: just talk about programming stuff for 90 minutes
      - can more quickly talk about programming than actually doing some code test
    - motivation: can see/feel it
      - casey muratori via chris heckler, does a mock interview to show another method
  - why no branding for the game studio (thekla)?
    - it's parasitic
    - *the goal is to give the best experience we can with the limited human capacity that we have*
  - design of games
    - requires a strong direction, a ferris magnet that makes sure all the pieces are aligned
  - what are you searching for in games?
    - that changes in every game
      - in this one, *game mechanic combinatorics*
        - *game designers have known for a long time now, that when game mechanics interact with each other, it generates more possibilities, and more fun, essentially*
          - *the opposite, just having mechanics that don't interact at all, just becomes a drag*
            - TODO: see indicade 2011 video with Jon and Mark, for that one 4d game
        - *does this level observe some new space of the combinatorics? does it use the objects to generate a new situation we haven't seen before? is that situation interesting? are we able to make that situation simply? or is it too contrived, which would end up making a bad level?* and as with making a language, it may be we have to make a big, contrived ugly thing, then refine it down later, as we understand what's necessary to do it simply
        - but again, as every game idea is different, the criteria that leads decisions are different
  - is the witness about understanding patterns?
    - TODO: gave a talk in indicade panel for 10 minutes about it
    - puzzle game design
      - not just a stream of "a-ha!" moments/realization, but must have more meaning behind it
  - *why make games?*
    - i don't know
    - *at first, ideas are new and exciting*, but after working on it for years, it gets old



** TODO MERGE: other notes

## Jon Blow's opinion
https://www.youtube.com/watch?v=4t1K66dMhWk&t=3635s
  - Jon Blow's rant on rust
  - **the main problem of programming languages, especially for games**:
    - most langauges that aim for being memory safe use a garbage collector that doesn't allow you to manually alter memory.. (and you want memory safety for when a reference/pointer is pointing to a memory that was de-allocated or re-used, or worse: the page of memory was removed by the OS causing a page fault and thus crashing the app)
        - crashes are actually better than not-crashing and being silent about having the wrong data in memory
      - smart pointer (reference counting? ew.) doesn't solve it, as you wouldn't want to authorize the class holding the reference to keep that referenced thing alive
      - weak pointer doesn't solve it either, as the systems to nullify it would get complex and add cost, and adding checking for null adds more chances for errors, until you add some sort of pointer system, which ends up costing the same as looking up an ID
      - example: object a is following object b, thus needs a reference to it
      - one common solution: a container of entities is stored, then looked up (hashmap or array). this guarantees memory safety at the cost of an object a looking for object b (within the container) every frame(!!)
      - a more complicated solution: in an ECS, dynamic arrays ("vec") of components are stored, this guarantees memory safety at the cost of an object looking for a component of object b every frame (in some generated index of a dynamic array)
      - the main point of the video: rust's borrow checker didn't save the programmer from memory problems, rather, the programmer simply refactored the code in a way that the borrow checker won't check (pointers were changed to indicies of a dynamic array): the borrow checker is confused and doesn't know that the programmer is allocated memory theirself (via dynamic arrays). (or does the programmer simply turn off the borrow checker?? lmao!)
      - **in the Witness, it's literally just an array of indexes (or array index?)**
      - **in the sokobon game, the id uses 32-bits, the top bits for user id and the bottom bits for the entity id, and use a hashmap for it, because that would be a really big array, because the high-bits are set**

https://www.youtube.com/watch?v=y2Wmz15aXk0
  - **the idea of using a scripting language in a game was a failed experiment**
  - scripting languages are "slow, bug-proned, impossibile to debug"
  
  
## some thoughts
see [app-frameworks], [game-engines]

**writing the core in C/C++ is perhaps the best option, as you get the best of both worlds: manual memory management for the core, and a light-weight scripting langauge on top (Lua, Wren, mRuby?), or, people can create high-level bindings in their favorite langauge of choice**

as long as the language can transpile to C/C++, then it should, in theory, work with just about any device (desktop, mobile, embedded, whatever). The problem is that it'll have to link to the libraries that each platform uses, which is likely C/C++/obj-C (exception: Android must go through java jni). If the application doesnt need to use the platform's libraries at all, however, i guess a binary is enough (apps/games for web assembly, desktop).


## libraries matter
libraries, including frameworks, engines, matter. a lot. Although you could use just about any language to solve just any solution, certain languages are better suited for certain *areas* in programming. This occurs naturally: someone wants to make something, solve something, they *hopefully* try to choose the right tool for the right job: the right language. Thus, the **language is just a tool** to do a job.

Over time, people who use the language will create libraries, *hopefully* many of which are open-source, thus buidling up a huge collection libraries specific to that language. **That resulting library, the contents of the library, is really an effect of the language itself, along with the community behind it, it's pop frameworks, etc.** If the language was created for intense math, then intense math libraries will likely be the result. The langauge in itself, has some influence, but not as much as the frameworks and libraries that already exist. It's hard to justify re-making those too. Rust is the only exception, and it took 30 years after C++.

Languages often have their own package managers: haxelib for Haxe, RubyGems for Ruby, NuGet for C#. Just by looking at the package manger, you can get a pretty good idea of what that language is mostly used for, and the power of the big frameworks in it. So, in RubyGems, the Rails web framework is a huge force, and much of Ruby is indeed used for web dev, along with general scripting / cli. In Haxelib, game 'n app frameworks such as OpenFL and NME are by far the biggest forces, with game frameworks and game-related libraries following after). **I think checking what libraries are in the package manager (or awesome github repo), is a good way to compare languages, instead of comparing the features of the language itself**, as it's the people that make the languages, not vice versa.


# important changes in dev tech
## WebGL is dead. Long live native dev.
with WebAssembly/WebGPU? now, can just skip the whole HTML5/WebGL crap and basically run native apps (machine code?) in the web-browser :o :O luckily, i've never cared about web-targets, but now it's finally really dead! :) No Flash. No HTML5/CSS/WebGl. *Long live native dev*.. maybe

## Microsoft "<3" games, linux, open-source
.NET *Core* is like a whole new revamped open-source cross-platform beast. In the past, Microsoft/.NET was tied to Windows, and so the guy that started the linux GNOME project, created Mono, an open-source cross-platform runtime for the .NET world. Eventually, Microsoft about it, likely for hundreds of millions of dollars. Later, Microsoft made it official, stuffing it in the new .NET Core. *The C#/.NET stock is rising...* Thus, app frameworks like Avalonia and Uno can compete with Google's Flutter, and the game frameworks like Unity and MonoGame (based on Microsoft's own XNA) are still very popular game engines. Microsoft is doing well. All of that, alongside **open-sourcing VS Code (including spec'ing the LSP)**, **buying github**, and **allowing one to install linux within windows (WSL)**, and just the fact that Windows always had a monopoly on games. Microsoft has always been closer to games than both Google and Apple have ever have ever been, and now it's really showing.

## move from dynamically-typed to static-typed
"imo, not having static typing is a real pain for anything bigger than a small script, as it introduces a lot of potential bugs" - CRobes, from the haxe discord

**i don't know the reason why this exists, save a very minor convenience of not physically typing the type keyword, which is mostly avoided by *type inference* anyway...**

i'm just guessing in the special case of server-side: where perhaps it makes more sense for a server to run easily-editable-scripts as opposed to a single executable, which must be compiled every-time you want to update it
  - but then again, is it that hard to compile..??

AS2 -> AS3/haxe (a whole new language and compiler)
js -> ts (transpiles to js)
php -> hack (type checker bundle?)
python -> mypy and others (type checker)
ruby /w sorbet (type checker)



TODO: merge to another file
### dynamic vs static typing

#### dynamic checking vs static checking
https://stackoverflow.com/questions/9154388/does-untyped-also-mean-dynamically-typed-in-the-academic-cs-world/9166519#9166519
  - "dynamic typing" is just a bad term, it should be dynamic checking (or perhaps lazy checking?)
  
https://stackoverflow.com/questions/1517582/what-is-the-difference-between-statically-typed-and-dynamically-typed-languages
Statically typed programming languages do type checking at compile-time.
Dynamically typed programming languages do type checking at run-time.

#### strong vs weak type systems
a strong static system is good at catching type errors at compile-time (and prevents them from happening run-time)

TODO: however, it sounds like a dynamic type systems leads to more run-time checking... somehow??

thus, it doesn't really matter if it's static-typed or dynamic-typed, the implementation of the type system dictates how good it raelly is
  - https://erik-engheim.medium.com/why-use-a-dynamic-language-over-a-statically-typed-one-fb434994e2b6
    - "However all statically typed languages are not created equal. Some like e.g. C has a weak type system, and numerous type related bugs are not caught at compile time. This has significantly worse consequences than in dynamic languages: you get undefined behavior, which it is hard to trace down the root cause of. Dynamic languages tend to fail more cleanly giving you a clear stack backtrace of where something went wrong with a descriptive error message."
    - **"The beauty of dynamic languages is that objects carry with them a lot of information about themselves which is lost in a statically typed language. That means you can introspect the system at runtime with great accuracy."**
      - C# reflector..? can't you do that with C++ when debugging..?
    - **"that is why levels in computer games and character behavior is almost exclusively written in dynamic languages.".."Designing the gameplay however is a highly iterative and experimental process. Doing this in a statically typed language, where every change requires a recompile would be an immensely frustrating and slow experience."** ... "Data science and scientific computing in general is dominated by dynamic languages such as Julia, Python, R and Matlab. This is for much the same reason as dynamic languages dominating game development (gameplay part). You are often doing a lot of exploratory coding, experimenting with data." ... In computer games **you have lots of data in the forms of levels you don’t want to reload each time you need to make a change. Hence a language that lets you keep running in a known state while doing code changes is immensely valuable. The same challenge applies to data science. You have huge datasets you are working on which takes time to load into memory.**


#### benefits of each?


https://softwareengineering.stackexchange.com/questions/122205/what-is-the-supposed-productivity-gain-of-dynamic-typing
  - dynamic typing 
    - is arguably **more suitable for interactive, REPL-like programming for rapid prototyping, real-time debugging of running program instances or even live coding**
      - *this is where the real magic happens..*
    - Better polymorphism - dynamic languages are potentially more likely to encourage the creation of polymorphic functions and abstractions, which can boost productivity and code re-use. Clojure for example makes great use of dynamic polymorphism in its many abstractions.
    - Easier to "hack" techniques such as duck typing and monkey patching can get you results very quickly (although might confuse you later on...)
    - Prototypes - prototype based data / object models are in my view more powerful and flexible than statically typed inheritance heirarchies. Dynamic languages are more likely to allow or encourage a prototype-based approach, Javascript being a great example.
    - **It's more concise - A lot of extraneous boilerplate code can be removed if everything is dynamically typed - type declarations, typecasting logic etc.**
    
  - static typing
    - Auto-completion - **static typing can also give more information to the IDE so that auto-completion of code or documentation lookup is more effective.**
      - hmmmmmm... this is big..
    - Better compile time checking - static typing can enable more errors to be caught at compile time. This is a huge advantage, and is arguably the best thing about statically typed languages overall.
    - Encourages Better design - being forced to think about the types of values in your software up front can push you towards cleaner, more logical solutions. (I say can - it's still possible to design really bad code...)
    - Discourages hacks - you have to keep type discipline in your code, which is likely to be an advantage for long term maintainability.
    - **Type inference - in some languages (e.g. Scala) this can get you many of the conciseness benefits of dynamic languages while still maintaining type discipline.**




# a little info
see meta-programming.txt

https://en.m.wikipedia.org/wiki/Dynamic_programming_language :
In computer science, a dynamic programming language is a class of high-level programming languages, which at runtime execute many common programming behaviours that static programming languages perform during compilation. These behaviors could include an extension of the program, by adding new code, by extending objects and definitions, or by modifying the type system. Although similar behaviors can be emulated in nearly any language, with varying degrees of difficulty, complexity and performance costs, dynamic languages provide direct tools to make use of them. Many of these features were first implemented as native features in the Lisp programming language.

Most dynamic languages are also dynamically typed, but not all are. **Dynamic languages are frequently (but not always) referred to as scripting languages**, although that term in its narrowest sense refers to languages specific to a given run-time environment.











** my reddit post about jai vs ai

https://www.reddit.com/r/Jai/comments/1gw9odi/is_it_not_too_late/

i'm late on this but.. it'll never be too late to replace the mess that is C++, and every other language that is poorly designed but happened to became popular, langs that abstract with a high cost (see how inefficient julia's run-time is, or try compiling crystal). Servers cost money, and more importantly, environmental minerals. Think of it as a much better designed chisel, a chisel that humans and robots can both benefit from using. AI isn't on the same plane as programming languages, so it's strange to compare the two. We can now have ai generate C, but it's still C. The hardware's language hasn't changed much, seemingly gotten simpler too (risc)..! When a problem arises, you the human still have to deal with all of its problems. I think the hope is the trend will go from ruby/python/lua/java/C#/C++/C all to jai (or if gc, haxe, maybe nim?). C for humans, and ai too! And once ai gets some feelings, it'll be thankful for jai too. ;)

but i too had a inner hunch/feeling similar to you.. Jon can at times seem like an extremely hard-working and disciplined but narrow-minded caveman chiseling away somewhere on the side of a mountain in china an ever-changing tech land-scape. I view him as the more ascetic shaolin monk, a really great one, capable to go alone exploring 'n discovering and be successful wherever his mind goes. Imo most of this ai stuff is bull-crap investment bubbles, like the web before it, lmao.. but i can't deny its progress either. Designing a great programming language is great progress too tho, and will save everyone countless hours of grokking, debugging, compiling, thinking in abstractions, being lost, 'n so on, and more importantly, get us back to the good ol' days of programming, with a single-page cheat-sheet and a game console.

one example of how bad it is: how long and how many work-hours did it take for C# to get AOT compilation, since the release of Castle Crashers (i'm guessing Jon made Braid with C++, not C#..)? To re-create XNA (FNA and MonoGame)? For FNA to be able to compile to consoles? To re-create .net (mono/.net core)? How many compilers were made for it? How many compilers were attempted? (How many for ruby?) How much money was spent by indie game makers, many just kids with great passion, to pay someone to port their art projects to other devices? How much time was spent fighting the garbage collector's implementation, or the VM implementation as a whole? To me it's all wasted time and human effort. And the problem is at the language level. It was done by design. It was designed for windows. It was designed for a VM. A VM designed to be language agnostic that in the end only has 2 languages max, if you count F#. "The people" retro-fitted it to become cross-platform. The people are lost in the sauce. Jon is not. He can design it right from the bottom up, because he has made it to the bottom, and knows it well. It's not too late. It's never too late. In Jon i trust. :)

all that, and i haven't even got to the problem of the game engine. How much time has been spent fighting with Unity? That seems exponentially higher than the amount of time wasted fighting the language.. lol.

nowadays, ai does the wasted work, of re-creating yet another terrible web/gui/ai/language abstraction thingy, or yet another linux/package manager/terminal/emacs... but i guess that's a human problem.. xD

and until jai releases, i will continue to be thankful for haxe. Heck, i still will be thankful, as it has a garbage collector!


** a few thoughts to remember
*** all machines speak in C (and now llvm ir)

if the target machines include mobile devices and consoles, then the language must transpile to C, as it's very unlikely for it (the language) to have the man-power to create build tools (assemblers?) for every machine

though, it seems if the language supports llvm, then most targets are possible.. (+optimizing compiler)
  - https://llvm.org/

https://ziglang.org/download/0.15.1/release-notes.html#Target-Support
  
**** android
"The issue with Android is that it's very difficult to make a full-blown application without at least some Java. *The whole UI basically requires Java.* You can make an application component in C, but you need to compile it as a library that gets loaded into a Java application that provides the user interface to it. The closest you can get to a pure C application is if you handle all user interaction yourself, receiving raw touchscreen inputs and drawing shapes on the screen using OpenGL ES or whatever interface Android currently uses for that. Maybe since I last checked, someone has made some helper C libraries that could be used instead of the native UI system but I'm not aware of them. You'd have to look for those. I know of several libraries that are almost like that, but not quite: they're all C++."
  - https://www.reddit.com/r/cprogramming/comments/1494gut/native_c_compiled_binaries_on_android/
  - however, this may not apply to games, which simply directly use the graphics renderers..
  


*** hardware is optimized for C

only languages that are close to C/C++ can be optimized
  - a kind of myth, but it sure is much easie to reason about what's actually happenning
    - though nowadays, with such advanced hardware.. who knows..
  - JIT/VM can be faster, as it can provide more info the compiler and enable them to optimize for real-world patterns. Instead, the efforts of optimization are shifted toward the compiler, as opposed to the human.
    - i def prefer this approach..
  - see [programming-concepts]
    
*the further things get away from C, the less optimized it will be, because hardware is optimized for C, no other language, with the main problem being cache misses (fetching some data from RAM as opposed to one of the memory caches nearby the CPU), especially in the case of games.* *Haxe, being a language made by a game-dev, provides complete control over C, and is able to create macros to generate things like C-structs, C-arrays, and structure of arrays. That is a rare exception*. Otherwise, the *C-like languages (jai, zig, odin) are more cognizant of hardware*.
  - how do programs written data-oriented in ruby compare to c?
    - it looks exactly like dragonruby's examples: top-level data structures (hashes, arrays, structs) alongside top-level functions. it just avoids using objects (and thus extra method calls), as there's enough of that going on beneath
    
i feel ruby is the best language, but, it suffers from being farrrr away from C, far from the hardware. Even it's simplest data types: int, is 64-bit object, and can't be shortened to 8 bits, which would then be optimized by hardware (SSE, SIMD, etc.). The more abstraction, the more problems. It's human to want a nicely designed langauge, and ruby accomplishes that, but once things require good performance, it all comes down to C.. or a very good vm (think: jvm, v8, clr).

*ruby is in a constant battle between being the ideal language designed for humans, providing freedom and power in the neatest form, and being performant. It's not easy.*

though, you can write "C extensions" for the high-performance bits.. or write the core of a program in C, then choose an embedded ruby impl.. dragonruby, surely, is the best solution in ruby land..

*perhaps the generation of optimized C is the way to go, as Haxe does via hashlink vm/byte-code to C compiler. *Using the vm for dev, then generating C for release.*, possibly passing it through llvm for further optimizations.



*** another thought
likely re-occuring from 10 years ago, to now, again, as i revisit technology

(one bit, on language: about expression of artists via tech mediums, prioritizing language/tools that allow expressiveness, as opposed to most common languages, which prioritize conformity and/or strive towards a single way of writing / pure procedural.)

TODO: get from notebook


* TODO to try
https://tekkie.wordpress.com/2007/07/19/squeak-is-like-an-operating-system/
  - great read on smalltalk, which is, just a vm/runtime

*jai*
  - try to get beta
  - **the most practical one in this list**

experiments:
lively kernal
  - TODO: try it!!
  - build web gui within the browser..??
red
  - **this is the greatest things ever**
  - my dream lang
  - insane ambition on the language itself, but also a gui system
  - https://www.red-lang.org/p/about.html

classics:
*haskell*
  - *to experience the magic of functional paradigm*
  - *native compilation and garbage-collected!!*
*lisp (common lisp sbcl via lem or emacs-lisp via emacs)*
  - TODO: then can compare with ruby
  - *continue using doom emacs (and therefore elisp)*
  - try CLOG
    - like red (lang) but for web
  - try helix again with the scheme plugin system (maybe there's a git branch..??)
  - try lem again (scbl)
  - *try sbcl*
    - *try it for instances when i'd reach for a native-compiled lang*
    - a very interesting alternative to C and Go, with similar performance but infinitely more expressive power
  - **true zen programming**
    - god-like macros, "interactive" dev experience including debugging, 'n more!
  - looking at a basic cli program, i can see why lisp might not be the way..
    - https://stevelosh.com/blog/2021/03/small-common-lisp-cli-programs/
    - maybe roswell..?
      - https://github.com/roswell/
        - **cli scripting with lisp..! and windows support!**, maybe similar to babashka
    - compare that crap to ruby or this nim project that generates the cli portion of the program:
      - https://github.com/c-blake/cligen          
*smalltalk*
  - possibly provides the best programming experience
    - the dream is to be able to make games with it
    - "Smalltalk, most readable language, you can alter *any* part of it while it's running making the killer dev experience"
      - can't do that with any scripting lang..?
  - **glamorous tool-kit**


* TODO clean up

todo:
clojure-like repl:
https://github.com/clojure-emacs/cider/discussions/3422
https://www.reddit.com/r/Clojure/comments/sm80ed/why_is_clojures_repl_better_than_other_dynamic/

https://www.reddit.com/r/AskProgramming/comments/16njl3f/are_people_still_scripting_in_2023_decision/
  - i asked in /r/AskProgramming


ref:
https://madnight.github.io/githut/#/pull_requests/2023/2
https://github.com/dwyl/learn-elixir/issues/102
https://www.reddit.com/r/elixir/comments/zd9o07/comparing_phoenix_to_rails_in_december_2022/
https://www.quora.com/Is-learning-the-Phoenix-web-framework-easier-for-experienced-Ruby-on-Rails-developers
  - a great answer about thinking in the way of Elixir is *simpler*




* what do i want?
what langauge is best for my needs? what do i desire in a language?

see [game-engines], [web-frameworks], [app-frameworks], etc.
  - *note: there's no way to maintain libs, so there's no choice for certain domains*:
    - ai/ml
      - python
    - web
      - pop web langs and javascript
  - thankfully, i'm not interested in either of these things.. and don't even consider web as programming
        


*aimed for games/interactive media* :D
  - (and other "creative" applications that use various input/output hardwares)
  - and thus likely has these traits:

    
**have the option to add a provided garbage-collector**
**cross-platform**
  - web, android, iOS (+ iPadOS), desktop OSs, consoles, embedded devices
    - in that order
  - likely either *generating optimized C or llvm-ir*
  - (and therefore eventually compiles to machine code and creates a binary file)
    
TODO: merge with above
be designed to be cross-platform, or at least have that in mind
  - maintain a set of libraries for target platforms: *web > android > iOS* > desktop OSs > consoles > everything else, in that order
    - because there's not enough man-power to build assemblies for so many platforms, particularly non-desktop platforms, especially consoles, *it must rely on it's ability to transpile to C*
    - *transpiles to javascript*
      - *and the media framework/engine must transpile to canvas*
        
**feature-ful**
  - so, not google's langs (go, python, dart?)
  - *cost-free abstractions*
    - so i don't have to worry about not using certain features
    - *macros*
*simple/easy interops with C*
  - bonus if C++!!
*it should be pretty fast*
  - not python slow
*be conscious of memory*
  - shouldn't be so abstract that the memory usage becomes unconscious
  - should allow ways to allocate contiguous memory (value-types: C-structs, arrays, primitive data types, bits, etc.)
*provide a quick-compilation option* so that you only need to build/compile to optimized native code for the final product
  - VM or native compilation for x86-64 with compilation cache
provide an option for manual memory management
  - for handling intense memory changes (textures going in 'n out, etc.)
  - otherwise, *good C interops*


* answer

*game-devs know best, and have made some of the best langs*
 - they're also just much better programmers than most, similar to systems-devs, and have specific requirements: high-performance, cross-platform, and ability to do low-level stuff (memory management, inline, etc.)
 - these are surprisingly and refreshingly straight-forward languages too (save macros), not too much fancy stuff, explicit


0. jai
   - requires memory management
     - NOTE: i haven't looked at other langs with manual memory management
       - zig, odin, vlang, etc.
   - beauty in simplicity
1. haxe
   - <3 haxe
   - beauty in explicit-ness, and infinite macro/ast power
m. beef
   - similar to C# in syntax, but with a focus on manual memory management, including tools to help (IDE, profilers, etc.)
2. nelua
   - new but seems quite ideal for game programming, especially when compared to non-game-dev langs
s. dragonruby/mruby
  - to try/add a more interactive AND elegant dev experience--especially with emacs!!--, yet still be portable/cross-platform (host C program)

    
non-game-dev, general-use langs, either gen C or llvm-ir, with a gc:

3. C-gen scheme lisps (gambit, etc.)
   - actually quite a cool simple yet very-high-level/dynamic and powerful option..
   - seems further away from more procedural C, but who knows.. def seems much simpler to improve the C generator/transpiler than other langs!!
4. nim(?), x/julia, x/crystal
   - nim won the war in its generation, developing quite nicely.. though python-esque..
   - julia provides a more dynamic alt, with lisp macros, though ideal, at the cost of a huge, inefficient llvm-jit
   - crystal, as of 2025, is stuck in development hell (bad lsp support, slow compiler, no other compiler options??, etc.)

no path / not made for cross-platform:

x. ocaml, julia
   - ocaml's focus on native comp and vm makes it seem cross-platform is not important
   - julia's focus on dynamic/run-time features (and vm) would make cross-platform require quite a bit of change or restrictions from it's original intentions


surprisingly, i chose the right langauge all along..!!

<3 haxe


* conclusion
languages sorted by their use cases

** my personal tool-kit waterfall

ordered from most useful to me to least useful

*** my general-use langs

C
  - *the hand-made way*
  - *mostly to interop with C libs*
  - or *when things get hairy..*
  - knowing this is indeed most useful, as it's closest to how hardware (cpu) work
    
haxe (> nelua =? nim >> julia >> crystal != gen-C schemes)
  - *high-performance static lang with a garbage collector that can transpile to/generate optimized C (to target cross-platform)*
    - games, media.. *can make anything really*
      - unfortunately suffers from not having a popular, easy-to-learn media/game framework
        - can always try heaps again (and again).. :/
        - ceramic
          - only 2d?
  - a very simple std lib (especially compared to ruby's "modular" libs)
  - complete compiler options: interpreter, VM/bytecode, binary (via transpile to C/C++)
    - scripting?
      - has both vm and interpreter (..for macros..?)!
      - (also has hscript!)
      - TODO: test vs ruby
        - only comprimises verbosity for explicity clarity, which is not a bad deal..
  - *glue lang* / transpilers for all major libs: C, C++, jvm, js
    
jai (> beef >? nim)
  - *very-high-performance lang that allows precise manual-memory-management / low-level access*, along with options and tools
  - *very-high-performance apps or components*
    - games, media
      - *jon blow's engine*
    - embedded devices
 
lisp >> (julia >>) m/ruby (>>> m/python >>>> shell langs)
  - *dynamic lang with a garbage collector*
  - NOTE: julia may takeover here for big programs thanks to llvm-jit, but not being designed for cross-platform (jit, dynamic run-time, big binaries) and neither for scripting (designed for compilation) limits its use cases
  - NOTE: *lisp seems like a superior, more practical alt to ruby*: simple, powerful, interactive/dynamic, naturally small enough to embed and interpret, full of modular features (concurrency, clos, etc.), and can transpile to C! it's just very different in syntax and features.. and their libs suck
    - notably, *it's the only dynamic lang that also has a C transpiler / is portable. Otherwise, one of the mrubies may be the only other option here..*
  - *to experience a beautiful language*
  - *to experience dynamic run-time magicks*
  - *anything that would benefit from dynamic run-time magicks*
    - *interactive data-munging* (data-science)
    - *to add beautiful dynamic scripting to C libs* (ai, anything)
  - *embedded scripting* alt for lua, *to add beautiful dynamic scripting to core C programs for quick prototyping/playing*
    - has several mruby variants made for different sized chips
      - dragonruby
        - *for interactive and easily-malleable 2d game dev / proto-typing!!*
  - *scripting* (basic gui-less programs, cli apps, shell scripts), automation (used by task schedulers), devops, hacking
    - *superior alt for shell languages*
      - possibly easier/more convenient to install on all systems than bash 'n powershell
        - often auto-installs on linux, when a program uses it..
      - just restrict to use the std libs
      - file utils lib with shell-like aliases
        - mv, cp, etc.
    - github ci?, actions?, gitlab ci?
      - TODO: ??
  - *web apps (back-end) that don't have massive throughput*
    - ruby on rails for quickly making a complete web app
    - roda for simple, modular dynamic sites
    - jekyll (github pages) for static sites

*** special-use cases

elixir
  - *web apps (back-end), especially if it has high-traffic*
    - messaging apps, etc.
  - *anything that fits within a functional paradigm*
    - even better if it also requires *concurrency (actor model)*
    - data-munging
    
rust
  - *embedded devices*
  - *anytime memory-safety is crucial*
  - *a sane alt to C++*

*** no choice

sometimes, you just don't have a choice..

lisp
  - *embedded scripting lang for text-editors*: emacs (emacs-lisp), helix (scheme/steel), lem (common-lisp) text editors
    - unless i build upon textbringer (ruby!)..!!

javascript
  - *web browser (front-end)*
  - (io-heavy? web apps (back-end))
    
python
  - *data-science*: big data, ml/ai, math, stats, biotech, etc.

*** TODO trash
    
  eshell >>? bash and powershell
  - CONCLUSION: *ruby is particularly excellent as a scripting lang, possibly the most ideal shell scripting lang(..!), especially now with ai*, so there's *no need to use shell scripting langs, save for quickly starting processes*
    - https://news.ycombinator.com/item?id=40763640
      - "Ruby: A great language for shell scripts"
      - some discussion on this problem..
    - *ruby is even more portable*, as bash/powershell are OS-based, especially running bash on windows
  - *batch commands*
  - *file-manipulation*
    - much simpler than general-use langs
  - *starting/running other programs (spawning processes)*
    - aync / concurrently or sequentially
    - especially if done frequently
  - *simply piping cli stream-i/o (unix) programs together*
  - eshell?? lol
    - you could write scripts (functions) in emacs-lisp, using all of the existing functions of emacs and emacs-lisp..
    - but then you'd need emacs running.. though it would still be more portable than re-creating linux in a vm..
   - https://www.youtube.com/watch?v=9xLeqwl_7n0
     - eshell is actually kinda sick..
       - great integration with emacs
       - mix elisp with shell commands!
     - also, since it's a vm, it'll work anywhere..
  - NOTE: use bash/powershell over non-posix alt shells like zsh/fish/kitten for portability

    
** haxe and jai (and nelua?): the swiss-army-knives

UPDATE: jai is how a programming language should be: *minimal and modular*, with *complete power over the compiler* (and not just macros!), allowing you to edit how to the compiler works, with plenty of built-in compiler directives to start with. It's *just really well designed*: no bullshit, no agenda/ideologies, no magic (everything is explicit), no expensive abstractions/features, no extra features that can be created yourself (given access to the compiler and macros), and yet no restrictions either. Despite it being made by a game dev, it's *the most general-use language out there, all the way down to first-principles: the compiler*. *It's of no surprise that since the beginning, it's taken a game maker to design a good language.. Honestly, programmer-only-personality-types just suck at design.* It requires a person that is a great designer and programmer, with a great ability to execute.

UPDATE: nelua, like jai, seems to provide a ton of compiler power, but through lua, as that's what the compiler is written in. "The preprocessor allows you to write Lua code that runs during the compilation process. This means you can interact with the Nelua compiler, analyze code, generate new code, and modify the compilation flow based on custom logic." 

haxe is possibly *the most versatile language* out there.. with *several compiler options and transpilers for every major language, it seems there's no limit to what can be made with it*.. it's the ultimate glue language, with the feel of a scripting language (actionscript), yet with a great simple standard library that gives it a more zen-like procedural systems dev flow, and still yet fully-featured (*an all-powerful macro system*, ADTs, pattern matching, everything-returns-something/function-chaining), and full of optimizations too (both the jit/bytecode-vm and via C/llvm).. all of that with a rad little game-dev community around it, and pro game-maker saint nicholas as its leader! this to me is *straight-forward, simple programming*.

the VM already provides *introspection*, yet there's also *hscript*, a scripting language (interpreter, run-time eval), which *shares the same syntax* (thus little to no porting, to nor from the scripting lang, is necessary), in case you need to eval some code at run-time.

as much as i love ruby's syntax and expressiveness, it's really tough to beat this, which just feels far more simpler, straight-forward.. and with a *sane std lib*. to me, it's C# done right

the vs-code haxe extension likely already has good integration, with common lsp features (completion..), debugging (compile-time checking and run-time errors and breakpoints within vm that make use of introspection), and profiling (hashlink vm)
  - TODO: just gotta make an emacs plugin for my fav lang!


  
C
  - libs, very high-performance parts, optimization
haxe
  - very general-use, garbage-collected, VM + transpile to C + interpreter!!, hscript, compiler options.. options galore!
    - *games* and other *high-performance* apps
      - made by a pro game maker, so the language is designed to handle games
        - especially the hashlink vm and hashlink to C generation
        - though, i think the language was intially designed to be extremely general: cross-platform and cross-language.. i think it's finally honing in / cutting off crap on v5
        - NOTE: *the maker's studios' games run fine in just the VM*, so until the product is ready for release to a non-desktop-os, there's no reason to ever even compile to C
        - *C data structure macros*
    - can build a single bytecode file or a native binary (via C)
      - UPDATE: and a hxb: a pre-compiled haxe binary file..??
    - *scripting* (via 'haxe --run <module> [args...]')
      - though a bit clunky feeling compared to ruby..
    - *when you need libs or must integrate with existing code*: C, C++, jvm, js (php?, c# soon again) (via transpilers)
      - the ultimate glue langauge
jai
  - *manual memory management*, *C-level performance*, *simple* yet *gives the programmer all the power*
    - *the future*
    - *anywhere C or C++ are used*
      - games
        - made for games by a pro game maker, so the language is designed for it


*** suffers from lack of popularity/libs

*..though, you probably don't want to use most popular libs.. just write everything yourself!, especially now with ai..*
  - *haxe makes up for it via transpilers*
  - *jai doesn't even want a package manager!*
    - now that may be a restriction to the hand-made ideology!
    
  - web
    - why not?
      - haxe has great js transpiler!
      - no pop framework?, ORM? / database connections? can't it be automated?
      - probably doesn't have a simple concurrency pattern (fibers, beam)
        - though, i have no idea how the hashlink VM works..
        - ..but neither does ruby..
          - (it just has server libs that use concurrency libs)
      - tink/http -> haxe.http?
  - ai/ml
    - haxe seems to be weaning off the python transpiler..
    - just not worth fighting it..
      - you'd have to interface directly with the "C extensions" of python libs anyway, since that's where all the work is happening..


** the lispy ruby dream: magical dynamic run-time machines

why not aim for the best dev experience and the most expressive semantics?

these languages are lispy, in that they provide a good amount of run-time features, leading to a more interactive dev experience: build the program while it's running, iterating piece-by-piece.. build simple games/media apps, high-traffice web-sites, high-performance programs, scripts, text editor extensions, all interactively..! yep, you can have it all. this is the way for gamers that crave interaction :D.. but also for noob programmers (like me) whom would benefit from seeing the program's state at any time
  - pry at a point, introspect (anything and everything), add some shit (into the program up to that point), pry again?
    - TODO: though ideal for big constantly running apps like games, i'm not really sure if this is a better debugging experience than a normal systems dev lang.. how does it differ from breakpoints?

notably, ruby *hinders performance*, as there's apparently quite a bit of *overhead* from: the everything-is-an-object model (unlike lua?), which creates extra method calls, calling functions from C, and dynamic typing (type checking at run-time). In addition, the language itself is notoriously difficult to parse, hindering progress. in contrast, haxe, i think, only suffers from calling from C when using the VM option, and even that is mitigated when using the C transpiler/generation option. *of these, only common lisp (sbcl) and scheme (chez and C-generating schemes) excel*.. but then you're stuck writing lisp.. though, by the time you run into performance problems, you probably have learned quite a bit about programming!
  - TODO: what other overhead is there?

conversely notable, ruby and elixir are considered among *the most beautiful languages, in syntax and expressiveness*, nudging devs to use the languages' powerful features to *build neatly solved, highly-maintainable programs* as opposed to straight-forward procedural programs. This is exemplified by their libs. They also often tend to aim to be more readable, succint, clean, functional. Where static langs find their rougher beauty in C++-style enums/adts, generics, pattern matching, pre-processors, macros (lots), these languages opt for *composable modules/mix-ins, composable functions and function-chains, composable blocks and closures, and possibly even more magical dynamic object/function alteration and addition. It can get pretty wild..*
    
in the world of web-browser-as-gui, these langs excel in *having the best web frameworks*: phoenix, rails, roda. These are worth practicing if you plan to work on or with web products.


  
C
  - core programs (if using and embededed lang)
    - *game-engine*
  - high-performance bits for ruby (C-extensions)
  - classic C libs
    - *SDL*, stb
(crystal)
  - NOTE: not dynamic at all!
    - just happens to use ruby's syntax.. heavily
  - see [[the lost dream]]
(julia)
  - high-performance jit-llvm
    - UPDATE: aot compiler on the way.. maybe can do it, as long as you don't use any dynamic run-time features..??
  - data-science.. :/
mruby, mruby/C, picoruby (with C)
  - *embedded scripting/extension (interactive and beautiful)*
    - rust is tough to beat for embedded devices..
    - but in the case of apps that simply want to make use of existing C libs, and build a little core program using them, these langs can provide simple scripting and still reap all the benefits of ruby (dynamic run-time / interactive dev, beautiful language, modules, blocks..)
  - dragonruby (an mruby fork)
    - *game/media (interactive game dev)*
ruby
  - *web* (tiny to large projects), *scripting*, shell magic
elixir
  - *web (high-traffic/throughput)*, *actor model concurrency* (and parallelism?), functional-paradigm
lisp (common lisp, scheme, emacs lisp)
  - NOTE: possibly *the most versatile lang.. it may have solved all problems*. though fragmented into distinct "dialects", they still retain the same simple syntax. *one lang to rule them all*
  - *embedded scripting/extension (interactive yet simple and powerful)*
    - used by all great text-editors: *emacs*, *helix*, *lem*, *textbringer*
      - emacs is a dynamic run-time machine!!
  - *high-performance alt to C, with great C-ffi via generating C* (gerbil, *gambit*, bigloo, chicken, etc.)
    - *highest potential for games/media*
    - *embedded devices*
  - *very-high-performance programs* via native-compilation, without sacrificing language features (*sbcl*, *chez*)
    - both have C-ffi too
    - (sbcl may be the quickest yet powerful lang..)
  - *concurrency to C/native* (gerbil, gambit)
    - i think most lisps offer concurrency, since it's so functional in structure..
    - gerbil offers *actor model* on top of gambit's *light-weight os threads/processes*, both of which transpile to C
  - *a simpler, far more terse alt to java and erlang with easy concurrency* (clojure, lfe)


  
*** the lost dream (rip crystal)

although having ruby for scripting, crystal for native, and elixir for server-side sounds like kick-ass dream combo, as they all share similar syntax across--all ruby influenced--, unfortunately, they wouldn't share a single library :( (std lib and user libs). There is seemimgly zero interoprability between them (elixir can call erlang functions, crystal has good c api and can thus be called by ruby (via anyolite lib) but cannot use ruby libs). Beyond syntax, they aren't very much alike. Crystal is closer to haxe, a static lang relying on compile-time macros for meta-programming. Elixir is more functional, with some dynamic magic, but stuck with a big specialized VM. Only ruby (and mRuby) seems to have it's own unique style of built-in features, including meta-programming features. Thus, it's better to just stick to haxe 'n ruby (or lisp??) for most cases, and keep elixir for web, as a special-case.

in addition, compared to ruby, lisp is an entirely different language: in structure, key-words/functions, libs, and meta-programming. The only thing they share is the idea of a dynamic run-time, and thus able to provide a more interactive dev experience

with *the exception of lisp (gambit: limited libs/engines) to make games/media*, all you've got is mruby/dragonruby (limited performance, difficult debugging, seperated langs), julia (limited to desktop platforms--as of 2025), crystal (bad tooling, slow compiler, no interactive dev), and none seem really good for memory-optimization (allocating contiguous memory, cache hits).. yeah, *these langauges really just strayed too far from the hardware/C.. and they pay the cost of that*
  - also lisp takes time to get used to..
    - https://github.com/part-cw/lambdanative/blob/master/apps/uSquish/main.scm
    - example game using gambit with lambdanative (some cross-platform framework..)



** selected langs list

NOTE: i sorta abandoned this bit.. just stick to [[my personal tool-kit waterfall]]..
  - TODO: maybe can merge most of this crap to there

*** general langs

general-use / static-checked, generally compiled / automatic-memory-management :
haxe >= OCaml == nim /w gc >> crystal (> C# > swift /w gc > kotlin/scala) (>>> go)
  - UPDATE 2024: after all these years, nothing has really caught up to haxe (nor Ocaml)
    - only nim is catching up, but it lacks the game eco-system, more likely to attract scripting language folks
    - *OCaml supports concurrency and parallelism!* via several libs/implementations
    - haxe supports concurrency based on it's platform via a "unified api"
    - crystal is still neat
  - general all-round use, powerful, garbage-collected, **can cover every use-case (using C for manual-memory management and optimizations, and by controlling the garbage collector)**, statically-typed
    - for me, i much prefer having the ease of the garbage collector than worrying about memory. when i do need something that does allocate and deallocate lots of memory, it's the framework/engine that handles that, not me!
  - **haxe** is the ultimate "kitchen sink" garbage-collected language, **cross-platform in mind**, powerful (all advanced features), small Flash-game-oriented community, simple 'n succint actionscript syntax
  - most use either a llvm compiler or C compiler (directly or through C) and are comparable in speed (**magnitudes faster than scripting langs, at almost no cost in dev time over scripting langs**)
  - **resulting programs more easily portable due to compiled executable binary**
    - **THIS ALONE IS A BIG FACTOR**
      - **nobody is going to install a scripting langauge and a bunch of libs**
        - yet, somehow, in academia, they do.. surely for the dynamic run-time features (altering somethihng in memory)..?
  - all are powerful in features: meta-programming via macros, ADTs, pattern-matching, generics, etc. (except golang)
  - **many come with multiple compile options for quick dev: interpreter, bytecode/vm (haxe/hashlink), in addition to native (llvm or C) compilation options**
  - **of these, only haxe has solid game engines**
  - **haxe's hashlink** seperates it from the other languages, putting ahead for games / real-time apps
    - **provides an identical runtime that produces bytecode (register-based) or C, so that you can quickly develop your program using bytecode, and finally, when it's ready to be released, compile to C (via optimizing C compilers), with the expectation that it works the same as the bytecode version**
    - **complete interop with C, providing C functions to alter everything (objects, functions, bytes, etc.)**
      - **furthermore, macros for: C-arrays, C-structs, macros for structure of arrays, allowing you to write closer to DoD style of C/C++, yet still in haxe. it's the best of both worlds.**
  - **haxe's "shiro tech stack"** also sets it apart from other langs, providing **a set of modular tools specifically for games, including a scripting language identical to haxe for hot-reload, console multi-player code (closed-source), serialization, retained gui, game database, etc.**
  - probably the biggest difference between the game-used languages and nim, crystal, etc.: **games require a solid, performant, mature language**. haxe makes the rest of the languages seem like toys
  - **able to contribute to a tiny game-oriented community (haxe), and hang with them on discord :)**
  
  

general-use / dynamic-typed ("scripting"), dynamic run-time / automatic-memory-management:
**ruby** >>> python >? javascript
  - NOTE: *nowadays, its' just as easy to use a general compiled langauge*, but the top 3 scripting languages have massive, stable libs to do just about anything
  - LIMITS: real-time interaction (must write C), **no simple cross-platform compiled binary executable** (no packaging/bundling tool either), **concurrent programming limited to a single process by GIL** and **parallel programming was slapped on**, dynamically-typed and meta-programming (and therefore **more difficult to debug and provide auto-completion**)
  - **given all those terrible limitations, i still <3 ruby. it has my favorite syntax, and possibly is my favorite language**, and **that is enough reason alone to use it whenever i can, because what matters most is that: it makes me want to write code, it makes me want to go back to a project written in it, and it makes me happy.**
    - for me, it's **the easiest to read**, thanks to it having the **least verbose syntax**, and **it's more functional/module/mixin way leads to less OOP mess** (despite being more object-oriented by design), which plagued a lot of the mainstream languages of it's time
  - between a shell lang (powershell) and a general-use lang (that has an interpreter or bytecode/vm), it's pretty rare you'd often use these languages anymore...
    - **dynamic langs like python are still popular due to data-science needing run-time capabilities*
    - **FUTURE: however, if people are able to make a native compiler, that'll be game-changing... languages are mere implementations**
  - EXCEPTION: **dragonruby (game engine)**
    - a fork of mruby, but close enough, with many of it's features. it would be great use the scripting langauge i love the most for game-making, and then be able to use those skills to quickly write scripts. quite a few game engines use custom scripting languages, but none are nearly as powerful as ruby.
    - **run-time inspection** as opposed to compile-time inspection allows **"interactive programming"** which is quite interesting for games... **just open a dev console and can run any function or inspect any part of the game**, or, you know, **add/remove something without having to re-compile the whole game..!**
  - **perfect for quick, simple, everyday small scripting to pretty large size projects** thanks to it's **great battle-tested modular libs**
    - **it's mature libraries is what sets it apart from haxe and newer languages:** you simply can string together some libs and make something you need. very practical. very quick.
    - runs as simply as a shell script, no main class or extra files or anything needed, and looks beautiful too!
  - possibly **the most expressive** language
    - **attracts a *clean*-design-oriented cult commmunity with meta-programming abound (DSLs, etc.)**
  - **meta-programming built-in and object-oriented makes it a good comprimise between lisp (dynamic run-time) and smalltalk (everything is an object)**
    - **you can make your own custom speghetti! really good language to get lost in your own world with.. very *hacky*, making it perfect for personal projects**
  - recent Ruby 3.0+ interpreter speeds are among the quickest, and with the recent JIT, even quicker, so, along with writing some portions C code, there's really no performance argument (except for games)
  - **great simple-and-quick-to-get-started/prototype frameworks 'n libs: web-app (server-side), automation, devops, hacking**, not so great for non-tech user cli/gui apps.. (but neither are any dynamic runtime langs..)
    - community pioneered frameworks and products for web (rails, sinatra/roda), hacking (metasploit), sysadmin/automation (chef config management, jenkins ci, etc.), rake
    - **jekyll (github pages) for static web site**
    - **roda for simple dynamic web site**
    - ruby on rails for quickly making a large or rich web app
      - both now replaced by elixir's phoenix framework
  - **open-source language not run by a corporate giant**, yet used by and supported by giants (github) and japan!
  - **with Elixir, DragonRuby, mRuby can keep favorite syntax and use for nearly everything**
    - "mruby bytecode can be embedded in C code, and thus, can be compiled into a standalone executable," via normal c compilers (gcc/clang)
      - has a virtual machine too, for quicker debugging/execution
    

TODO: merge with above
# conclusion:
i love ruby, and will absolutely keep it for my own personal scripts, likely for my entire lifetime..! **it's perfect for scripts without dependencies**, only using the std lib. Once others must use it, or needs parallelism (web), i'd have to jump to a native-compiled language... *until maxime/yjit is able to make a native compiler that is..!* :D

# post-dragonruby update
yep. ruby is the one. i finally found it.


  
manual-memory-management with advanced features:
**jai** > nim (== D > swift) != rust > C++
  - NOTE: **for the case of games, i'd just wait for jai**, as it doesn't have the complexity of neither rust nor C++, nor the baggage of C++, yet still has some powerful meta-programming features
    - **by design, it's just simple in a beautiful and intutive way**, much like his games
    - until then though, stuck with C++ and rust
  - **C++ and rust have incredible libraries related to systems-programming**
  - **rust guarantees memory safety at the cost of following their memory-management model, and is just much newer (by decades!)**. But, it's not an end-all solution to memory-management, especially in the case for games
    - rust is slowly being accepted in major critical-code apps
    - rust actually seems close to haxe and ocaml, which makes it a nice jump
    - **rust is unfortunately amongst the most complex languages in existance**, and most code uses many of it's many features
  - **C++ has come a long way since i last used it, it's actually legit as long you program in a restricted C-like way, and is used by all game engines**
  - D, nim, and swift are notable for having the memory-management modular, allowing you to choose various ways to handle memory, therfore really allowing you to use one langauge for everything..!
    - D and nim especially, for allowing the option of using a garbage collector
    - but D and nim have tiny eco-systems, and swift is.. Apple
    
    

functional / concurrent (actor model):
  - and therefore perfect for web (server-side)
(haskell >) **elixir** > gerbil scheme > OCaml > **ruby** <? javascript/nodejs
  - **proof that the framework/practical use case means a lot more than the language itself..**
  - **phoenix, the current best and most beautiful scalable and easily-maintainable web framework**
    - suitable for both small web apps (roda) and massive web apps (rails)
    - makes great use of old tools to provide concurrency, and even provides an elegant way to handle it
      - **concurrent/parallelism for free**, since it runs on *awesome* erlang VM (BEAM). used for distributed, fault tolerant, highly available systems (such as Discord and WhatsApp)
  - functional paradigm
    - *perfect for data-munging*
    - and results in better written / more manageable programs because of it
    - and is my journey into it :)
  - can also be used to write beautiful programs with it! (merges the beauty of ruby syntax with functional paradigm)
    - pretty terrible for cli-apps though, as it requires installing the VM to run it (compiled to bytecode), has some start-up time (just 200ms..), and doesn't have a way to natively compile, so **limited to uses where a VM is constantly running (servers)**
  - *however, sometimes you don't want functional, or thinking that way is too obtuse, than ruby on rails is still the best of the bunch*
  - *javascript is very fast and great server-side because of it's non-blocking i/o event design*
    - but then you'd be using javascript and it's libs..
  - *haskell is kinda god-tier here..*



*** specialized langs
don't have much of a choice for these..

**javascript/typescript**
  - the standard browser language
    - can't seem to run from it, though i can keep trying!
      - haxe transpiles to js :)
  - **by far the worst libraries and least skilled programmers**
  - i'm told it's much much better than it used to be..


shell scripting langs
(*ruby*) >>> **powershell (v7+)** >>> fish > bash/zsh
  - *ruby makes such a great shell scripting language, it even derives a lot of terse syntax from it..*
    - ruby/python might be more portable than shell langs, since bash requires installing mingw/cygwin/wsl on windows and powershell requires being installed on linux/mac
  - see [cli-shells]
    - shell language, more like gluing, with the exception of powershell, these languages *suck*, feel old--no, *are* old, full of '$'s and even weird syntax for the most simplest if statement, so, only use them if you need a basic batch file (run a bunch of commands), or for shell piping (but it might just be easier to use a scripting language in most cases, even for simple batch scripts, as it's more popular and readable than all of the shell scripting langauges)
  - batch commands, extremely simple scripts
  - x/personal basic shell functions/"modules"/"cmdlets" (powershell > fish)
  - automation, especially for windows
  - powershell is now cross-platform (since v7?)
  - but powershell is really nice!
    - https://www.quora.com/Why-should-one-use-PowerShell-instead-of-Bash-on-Linux-or-other-scripting-languages-like-Python-or-Ruby-What-are-its-advantages-over-them
      - i agree with all of this.. powershell is really good for it's use, just think of it as a DSL for common shell stuff
  - *powershell is data-oriented*
    - not text-stream based


various custom scripting laguages (gdscript, etc.) and embedded scripting langs (*lua*, wren, **scheme**, *mruby, mruby/C, picoruby*, micropython) usually on top of C++
  - **mruby has the most beautiful syntax and powerful features**
    - dragonruby
    - *..but surely at a great cost..*
      - can't be worth it for high-performance apps..
  - scheme for the only thing more powerful than ruby: lisp macros
    - helix
  - *lua is exceptional for being the simplest and having the best implementation (luaJIT)*
    - love2d, defold
  - wren is simple 'n pretty, but rather mundane, but does have concurrency/fibers
    - luxe
  - elisp (emacs-lisp)
    - *doom emacs*
  - games, big apps, embedded devices
  - https://dev.epicgames.com/documentation/en-us/uefn/verse-language-reference
    - a good view of desires in a game scripting lang
          


  
*** special use-cases

manual-memory-management but simple / C-like / **embedded** / game engines:
  - with jai, i have no reason to use these, unless i need to do something embedded, and even then, maybe jai will work..
(**jai** >) zig > odin > **C**
  - **perfect for game engines**, particularly with raylib (since it's written in a C style)
  - **all machines and languages talk in C, so it's the most practical and most important one to know..! don't let the other languages sway you!!** one cannot keep running away from it ;) anyway, it's no worse than older C++! it's actually much much simpler..
    - especially hardware-level stuff: the OS for consoles, mobile devices, and embedded devices, and has libs for all of those devices
  - some languages transpile to C (haxe, nim), but these seem to go directly to assembly??
    - langauges that call C functions via FFI suffer a little bit in performance (in games)??
  - **knowing how C works is the key to optimization**
  - odin seems like it's made for games..!
    - suffers from bad tooling
  - **zig actually isn't simple, it has meta-programming!!**
    - suffers from constant changes in development
  - **word on the street says jai is better than both, with even better meta-programming!!!**

haxe
  - transpile and interface to several other languages:
    - https://haxe.org/documentation/introduction/compiler-targets.html
      - tier 1: **js**, hashlink (**bytecode**/**c**), eval (**interpreter**), *jvm* (bytecode), php
        - **that's basically all the output options you'd ever need**
      - tier 2: **c++**, lua
      - tier 3: c#, python
  - suffers from lack of community/libraries, though it is amongst the longest living of contemporary languages and constantly updated and improving, with a very very solid std lib
  
Ocaml
  - perfect for parsing/compilers (initially used by haxe, rust, etc.), and other problem/solutions that requires heavy pattern-matching, GADT, and benefit from warnings for cases not handled, warnings for mutable data too, strong typing
  - resulting programs are quite pretty thanks to it's functional paradigm side and concise syntax
  - ..i just personally really liked the feeling of it, seeing it in haxe's compiler
  - shares quite a bit of similarities to both haxe and rust, particularly, in syntax and features (pattern-matching, ADT)

haskell
  - *pure functional programming magicks*

lisp
  - *simple yet powerful macro magicks*, within a dynamic run-time

smalltalk
  - *a gui to see the dynamic machine at work!*





* list

order of notes:
simple summary
frameworks
the rest
owner

** dynamic langs aka scripting langs (dynamic run-time, dynamically-typed, automatic memory-management)

languages that have a dynamic run-time (meaning: *you can alter the program at run-time*; usually meaning: *eval, run/execute code while the program/process is running*), often dynamic typing (meaning: the type is unknown until run-time--since new code can be inserted/eval'd at any-time, there is no way to know the type until reaches execution), thus enabling the languages to have various program-altering features: *meta-programming* (meaning: *to alter the program in various ways, but particularly while it's running* (at run-time); which is beyond introspection, which doesn't alter anything, and beyond macros, which are executed at compile-time), and thus enabling them to *provide a more interactive dev experience*

other languages, such as haxe (hashlink vm), and i'm guessing C# and java too, all at compile code to bytecode (haxe, clr-ir?, jvm bytecode) first before feeding it into the vm (i'm guessing for optimization purposes..). Since the code has already been transformed into bytecode before execution, usually a pre-compiled file, there would be no way for newly inserted/evaluated code to interact with it (TODO: unless you make a way for bytecode to interact with it, or other bytecode..?).

thus, in order to compile code at run-time, you'd need a whole 'nother compilation process (hscript), which'll likely take longer to execute/run, as it's starting from a high-level language, not bytecode (likely, because who knows what optimizations may come up during run-time..! :) ).



TODO: to merge:
*eval(uation) are dynamic langs killer feature: it makes dev experience MUCH easier, and MUCH more interactive.* With this power, you can easily see what every region of code (expression, function, etc.) returns, making writing code / dev a FAR more tolerable experience.
  - NOTE: how does this differ from static lang dev?
    - breakpoint, introspect? that's not bad either.. but then you'd have to get the program to execute to that point..
      - goto?
    - hmm, maybe you can eval regions of code in the big VM langs (C#, java) too..??

furthermore, languages like ruby, provide ways to alter existing objects (monkey-patching?), not just altering data nor running existing functions, but adding methods/functions to existing objects, and more! (TODO: more!) 

*languages that are desinged to include the concept of "everthing (expression) returns a value", can doubly benefit here, as then you literally evaluate everything!* 





https://en.m.wikipedia.org/wiki/Dynamic_programming_language
In computer science, a dynamic programming language is a class of high-level programming languages, which at runtime execute many common programming behaviours that static programming languages perform during compilation. These behaviors could include an extension of the program, by adding new code, by extending objects and definitions, or by modifying the type system. Although similar behaviors can be emulated in nearly any language, with varying degrees of difficulty, complexity and performance costs, *dynamic languages provide direct tools to make use of them*. Many of these features were first implemented as native features in the Lisp programming language.

Most dynamic languages are also dynamically typed, but not all are. Dynamic languages are frequently (but not always) referred to as scripting languages, although that term in its narrowest sense refers to languages specific to a given run-time environment.




*** TODO some thoughts on native compilation vs interpreter/vm

TODO: merge with above

though static languages have made a popular return, thanks to it's type-checking, better debugging experience, and better performance, i still feel **scripting languages ease-of-editing-and-developing** make them impossible to rid. Furthermore, the **power and expressiveness of dynamic languages, especially lisp, but even ruby, make them my personal choices for nearly all cases nowadays. Dynamic runtimes are where all the magic and fun happens (though, static lang compile-time macros are cool too).** In the case of needing memory management / performance, just use C (though, probably not simple, depending on ffi/c-extension-api). The only major loss is the C++ and Rust libs.

in languages with a vm implementation or a simpler interpreter, **there is no build process. That means every user doesn't need to figure out how to set up build tools, nor how to build it, nor build it for multiple platforms. It just works everywhere. The only thing necessary is downloading the runtime (interpreter or vm/byte-code compiler), which is even often pre-installed on many os's, or easy to get from a package/installer**, in the case of python and ruby. Or, in the case of embedded scriptings languages such as lua, the runtime is already included within the program--no need to install anything (as in dragonruby). Ultimately, **all the user has to to is edit the file/program, and re-run the program.** It doesn't get better than that! **Whereas with a compiled langauge, **upon every single edit, they'd have to rebuild/compile the program**, in addition to having the compiler and build tools set-up.
  - **TODO: not true at all, need to use the fucking dreaded library systems (all are terrible) to download libs used by the program. You just pray that it works. That there's no version conflict. That each program has listed the versions of each library it needs. By the end of which, you have a ton of versions of the same fucking library..*
    - *yeah, okay, maybe binaries are better for the end user.. and with ci/cd github actions, it'll build automatically!*

*"no helpful IDEs. It's hard to reason about dynamic code before you run it, so it's very hard to write tools to help you reason about it."*













https://en.m.wikipedia.org/wiki/Scripting_language
  - TODO: still need to read through this...


https://www.youtube.com/watch?v=y2Wmz15aXk0
  - TODO: yikes...
  - jblow ripping the idea of **game** scripting languages apart

https://github.com/igor-petruk/scriptisto
  - TODO: write scripts in compiled languages!


TODO: see https://stackoverflow.com/questions/17253545/scripting-language-vs-programming-language


https://www.reddit.com/r/AskProgramming/comments/16njl3f/are_people_still_scripting_in_2023_decision/
  - i asked in /r/AskProgramming
*** TODO some other thoughts

TODO: merge with above

post-windows update:

see [cli-and-tui-frameworks] for similar thoughts on scripting vs natively-compiled

the biggest difference will be the libraries and the succintness (what makes it beautiful are it's main cons: dynamic typing syntax and libraries that use meta-programming). Go has a minimal yet powerful standard library whereas ruby's libraries are often over-engineered, and have a lot of character: often elegance, a bit of quirkiness, and a good amount of magic. In go, you just write/program straight-forwardly, like the languages itself. Also in go, there's a bunch of error handling code (by design) that takes up space and hinders readability. Both python and ruby (and even typescript) scripts will result in more succint, easier to read programs, but maybe not by a large enough margin to outweigh the ability to create portable executables for every platform, and provide easy concurrency. Haxe's standard library is closer to go, minimal-yet-powerful (thanks to it's maker's style), yet it's open-source-community libraries are often closer to ruby, full of meta-programming magic. Kinda the best of both worlds... unfortunately, haxe being much older than go, wasn't built with concurrency in mind, and didn't even get threads into it's std lib until v4 (not simple, considering it transpiles to several langs..).



  
*** some thoughts about the case of web dev

because so much computing is done through the web/internets, these blew up. *In the case of a web program, the end-user does not need a program on their computer system.* The program simply lives on the server. Thus, *any language can be used!*. VM langauges, including all scripting languages, are totally fine, as the vm is always running (code is fed into a running vm and in return it spits out html/js). Also in this case, startup time doesn't matter either (beam vm).

furthermore, *you can simply edit these while it's on a server. No need to compile or build anything (TODO: though, you'd probably want a deployment process..)* Just replace the file. This is how web-sites are being made, with massive amounts of people working on them, at the same time. Everyone can work on various files, and there's no reason for everyone to find a stopping point to re-build/compile.

also, since browsers have a javascript run-time, browsers themselves are dynamic run-time machines!! (hence the dev console in which you can run any function)


TODO: merge with above
*web is today's main gui..! So, in turn, ruby is actually more practical than all of those natively-compiled langs! Wild how that works.. <3*




*** YES Lisp
  - UPDATE: a little rough to read, but wayyy better than learning the syntax of yet another language!! Actually, i may prefer it over most languages.. especially when used as a scripting extension lang. The core of the program however, may be nice to have something more C-like..
  - second-oldest language, after fortran
  - **at the same the the simplest syntax yet the most powerful language (and fastest dynamic lang!) still!**
    - **a history of programming languages reveal that they are only *just* now catching up to Lisp, and still, they've only caught up to it's features, but not it's implementation which allow the real wild stuff (see below), in addition to creating a lot more complex syntax**
    - macro heaven
      - "Thus, **Lisp functions can be manipulated, altered or even created within a Lisp program without lower-level manipulations.** This is generally considered one of the main advantages of the language with regard to its expressive power, and makes the language suitable for syntactic macros and metacircular evaluation."
  - **the simplest sytax**: '(function arg)', that's it!
    - thus **easy to parse / interpret / compile**
  - **"interactive programming"**
    - eval/compile regions of code into the run-time
    - introspect all functions, vars, libs easily
      - this allows editors (emacs) to provide info upon hover
    - you're basically programming from within the program..
    - **"interactive debugging"**
      - aren't these common to all dynamic/run-time langs?
  - can be *very fast*
    - "Compiling to machine code was important in the history of Lisp. Not so for Python, Perl, Tcl, and Ruby."

      "...when it came time to standardize Common Lisp, the process included participants who were involved in delivering Lisp applications on "stock hardware"; CL is a language that was designed from the beginning to allow compilation to native code"
      - https://www.reddit.com/r/programming/comments/63vmh/ask_programmingreddit_why_is_lisp_faster_than/
  - *perfect for use as a scripting extension language*
    - text editors, games, big systems programs, etc.
  - can be used for everything??:
    - scripting, systems, embedded, and functional!
    - *the problem seems to be that it gets difficult to maintain once too large*
      - *similar to ruby, can easily make your own speghetti world, but with even more power*
  - *lacks libraries, especially when compared to the main systems languages*
  - "*Yes, they are different languages, working atop different platforms. They have different semantics, vastly different core libraries, etc. Yet at the same time, somehow, there's little mental overhead when switching between them.*

    *I don't have any difficulties moving between Fennel, Clojurescript, Clojure, LFE, Clojure-Dart.* But if I had to manage writing code and maintain multiple projects in Lua, Javascript, Java, Erlang and Dart - I would claim that my name is Guy Stele Jr. and I am a very smart programmer. Alas, I'm not that smart, that's why I chose Lisp."
    - covers javascript, jvm, beam, dart (ew), lua (why??)
      - just lacking clr?
    - embeds to C (many schemes)
    - is a native systems lang itself (cl, racket)
      - ..that really is everything..!!
        - *but i also think haxe's solution may be better..*

  TODO: merge with above
    - Lisp pioneered many ideas in computer science, including tree data structures, automatic storage management, dynamic typing, conditionals, higher-order functions, recursion, the self-hosting compiler,[8] and the read–eval–print loop.[9]
    - The name LISP derives from "LISt Processor".[10] Linked lists are one of Lisp's major data structures, and Lisp source code is made of lists. Thus, Lisp programs can manipulate source code as a data structure, giving rise to the macro systems that allow programmers to create new syntax or new domain-specific languages embedded in Lisp.
      - and so, every instruction is within parenthesis :o

**** dialects
***** Common Lisp
  - **the true way**
    - **true lisp macros**
    - "In my opinion, Common Lisp is the environment to develop informed opinions about the tradeoffs and benefits of other forms of Lisp.
While you can compare Scheme to Clojure and Clojure to Racket, Common Lisp embodies the alternatives against which each was developed."
  - "Yes, while macros have been cited as the cool feature of lisps, there are several other good things about *Common Lisp (SBCL in particular): stability; image-based development; dynamically scoped global variables (local variables are lexically scoped by default, yes!); conditions, restarts, and the ability to introspect the stack while it is still unwinded; CLOS, MOP, and multiple-dispatch; compile-time notes and warnings emitted by SBCL, performance provided by SBCL."*
  - a spec from 84 (finished in 94?) of which there are a ton of implementations
  - the web-site shows the extremely simple and bare syntax/features
  - impractical for web
    - TODO: why? libs? is that why clojure exists?
  - old, robust, industry-tested libraries
    - used in Deep Space and Mars Rover
  - https://awesome-cl.com/
    - awesome common lisp repo site
  - CLOS
    - a more generic implementation of objects, where all methods are generic, and classes are simple a collection of methods
      - this is very close to data-oriented paradigm.. just adding the cost of multiple-dispatch
    - uses multiple-dispatch, like small-talk, based on argument types
    - https://mendhekar.medium.com/the-finest-object-system-youve-never-heard-of-d2e26339b03c
      - a simple comparison
        - behavior and structure
          - "The problem with this design choice of merging structure and behavior is that the world of abstract information system design is very different from the physical world."
          - simula OO: usually end up creating more abstractions: inheritance (via interface/virtual methods or sub-classes)
        - dispatch: match the name of a method to a specific piece of code to run
          - simula OO: one dispath table per object
          - CLOS: quite complicated, there's an order of precedence, from specific/"specialized" to more general
        - can add methods to basic/internal types
        - generic functions are basically functions, and can be passed around
        - can modify existing classes by adding functions
        - meta-object protocol (mop)
          - sounds similar to metaclass, the things that create classes, or in this case, everything within the this system
          - can modify it everything
  - solid dev tools (SLY/SLIME/emacs)
  - trial game engine
    - used to make a little open-world 2d game: kandria
    - https://github.com/Shinmera/talks/blob/master/gic2021-highly-dynamic/paper.pdf
      - the person wrote this little overview on why common lisp for games
        - includes CLOS uses
    - https://shirakumo.org/
      - other software by that person and friends
  - **the CLOG web framework**
    - a totally awesome way to make websites in pure lisp!! (via websockets)
  - emacs itself has some cl-like things
    - cl-lib, EIEIO (a CLOS-like framework)


  
  - vs chez scheme
   - https://elmord.org/blog/?entry=20191114-sbcl-chez
   - *a better dev experience than chez scheme*
      - https://elmord.org/blog/?entry=20191114-sbcl-chez
        - *stack tracing, type annotations, uses less memory(!) at the cost of binary size(?)*
   - "This one is a matter of personal taste, but I just like Scheme better than Common Lisp. I like having a single namespace for functions and variables (which is funny considering I was a big fan of Common Lisp's two namespaces back in the day), and not having to say funcall to call a function stored in a variable. I like false being distinct from the empty list, and for cdr of the empty list to be an error rather than nil. I like Scheme's binding-based modules better than Common Lisp's symbol-based packages (although Chez modules are annoying to use, as I mentioned before; Guile is better in this regard). Common Lisp's case insensitivity by default plus all standard symbols being internally uppercase is a bit annoying too. Scheme has generally more consistent names for things as well. I used to dislike hygienic macros back in the day, but nowadays, having syntax-case available to break hygiene when necessary, I prefer hygienic macros as well.

     And yet… Common Lisp and Scheme aren't that different. Most of those things don't have a huge impact in the way I code. (Well, macros are very different, but anyway.) One things that does have an impact is using named let and recursion in Scheme vs. loops in Common Lisp: named let (similar to Clojure's loop/recur) is one of my favorite Scheme features, and I use it all the time. However, it is not difficult to implement named let as a macro in Common Lisp, and if you only care about tail-recursive named let (i.e., Clojure's loop/recur), it's not difficult to implement an efficient version of it in Common Lisp as a macro. Another big difference is call/cc (first class continuations) in Scheme, but I pretty much never use call/cc in my code, except possibly as escape continuations (which are equivalent to Common Lisp's return).

     On the flip side, Common Lisp has CLOS (the Common Lisp Object System) in all its glory, with generic functions and class redefinition powers and much more. Guile has GOOPS, which provides many of the same features, but I'm not aware of a good equivalent for Chez."

  
****** implementations
    - **SBCL**
      - the standard
      - **native compilation, extremely fast (compares to C!!)**
        - *i'd personally try this over go.. it's just lacking the updated libs..*
      - C FFI
      - it sounds like you can program in any way you want (paradigm) and that **the language itself is modular via extensions** such as CLOS (object-system) and meta-object protocol, kind of like lua's meta-table structures..
        - **CLOS is apparently wayyy more powerful than any object-oriented language, as you can change the structure of objects on-the-fly**
      - "what you get with SBCL is a 'full-stack' Lisp with a sophisticated AOT native-code compiler, supporting a very interactive development style and providing a blend of imperative, procedural, functional, object-oriented, and meta programming."
      - "Mature native code compilation (**including runtime assembler**), **type declarations that lead to optimizations in generated code**, *SBCL compiler can use declared types for compile-time type checks*, **read/compiler macros**, **extremely easy interface to C** (JNI is a pain in the ass), *multi-paradigm* and doesn't prematurely optimize like Clojure (I have no need for STM or immutable data structures in 99% of the things I do), **very powerful and flexible debugger**, **CLOS**, more sophisticated interactive development."
    - CCL/clozure
      - <= 20% use this
      - better C/obj-C interface
      - faster compiler
    - CLASP
      - newer, llvm, c/*c++ interop*
***** Scheme
  - this sounds *more in tune with the spirit of Lisp*, whereas other newer dialects just add more syntax/keywords/features, when *the point is to be simple, composable*
  - a minimal dialect
    - the core seems to be rigorously thought out and is now a standard used as a base for newer dialects
    - beyond the core, there are similarly rigoriously thought out extensions to the lang
  - less practical / battle-tested than CL, and less libs too, fragmented by the amount of implementations
  - small-size makes it fit as an embedded language for C/C++, or to transpile to C/C++
    - **because scheme is often used for special cases as opposed to as a general language, it's dialects are far more different, and therefore less compatible compared to the consistency of Common Lisp dialects, which are able to share a single library ecosystem (quicklisp)**
   - https://www.reddit.com/r/lisp/comments/15ulzm1/wtf_is_going_on_with_r7rs_large/
       - https://dpk.land/io/r7rswtf
       - https://medium.com/@kenichisasagawa/memories-of-scheme-8ecbb3e90df2
       - version R6RS created a split amongst the community, "it messes up the spirit of Scheme",
         - Scheme was trying to serve two purposes which couldn’t be accommodated in one report. Those who liked R5RS liked it because it was small and flexible; those who liked R6RS wanted something bigger and more practical for writing real, production programs on modern computers. Thus, they planned to revise the language again and split it into two parts: small and large.
       - *version R7RS small is closer to it's simpler R5RS roots, whereas R7RS large is closer to the "with batteries included" approach*
         - R7RS is still incomplete as of 2025
         - the chair of the steering comittee resigned in 2023, feeling it was hopeless

       - Scheme isn't dying, it's dead; its children live on.

         People don't use scheme, generally speaking, they use variants with bespoke libraries and implementation quirks. Guile, Racket, Gerbil, even Chicken and Chibi are platforms where non-portable code thrives. They may have Scheme roots, but you can violate or extend the scheme standards in many ways on every major implementation.

         Scheme needed an implementation of record, a universal package repository, a stable and consistent ffi, and what it got was some pdfs that implementors begrudgingly followed. Often loosely.
  -
    - The Scheme community has long held tension between people who want to use Scheme as a teaching language, versus those who want to use it for writing real-world programs.
- https://news.ycombinator.com/item?id=37164243
  - The former want the language to stay as minimal as possible with a tiny standard library so that there are fewer concepts and options for students to stumble over. The latter want a full-featured language (but still minimal, it is Scheme after all) with a large standard library of useful types and functions so they can get stuff done.

    These two perspectives are both reasonable but fairly incompatible.

    For most of its history, Scheme leaned towards education. Around the type of the sixth edition (RSR6), pulled somewhat the other way and the language and library spec got much bigger. This alienated a lot of folks who wanted to stay a small teaching language.

    For RSR7, they tried to resolve that by simply splitting the language in two: a small one and a large one. Then each subcommunity can have what they want.

    *Around the same time, the language PLTScheme renamed itself to Racket to clarify that they aren't trying to be beholden to the overall direction of the Scheme community. Racket is also a "large Scheme" in that it's a Scheme-derived language that tries really hard to be batteries included for all sorts of uses. It also can be "subset" into smaller languages for use in teaching.*

    My impression (from far on the outside) is that Racket has taken up a lot of the oxygen, which may partially explain why RSR7-large never managed to reach consensus and ship.

  - "Scheme is simpler in a lot of ways: functions are just another value, which means there's a lot less overhead when using higher-order functions (compare CL's (funcall (make-function)) with the scheme equivalent ((make-function)), **the language is literally quite a bit smaller (fewer rules, fewer functions, fewer special forms)**, and it's idiomatic to iterate with recursion instead of something like the (in)famously featureful loop macro.

    Do you like the functional programming style? Scheme. Do you want a large library ecosystem that Just Works? Common Lisp. Do you want a small language you can embed in a C program? Scheme. Do you want battle-tested industry tooling with decades of work behind it? Common Lisp. **Do you want a language that is designed from first principles and exhibits a simple, mathematical elegance? Scheme. Do you want to just get shit done and don't mind a few messy but pragmatic compromises? Common Lisp.**

    There's no wrong answer, though, both are lovely languages in their own way.)"

****** implementations

  - all use geiser package for emacs, though racket comes with it's own IDE
    https://wingolog.org/archives/2013/01/07/an-opinionated-guide-to-scheme-implementations
      - TODO: looks good.. 
    
******* natively-compiled
******** chez
- *best performance via native compilation*
  - "a few times slower than LuaJIT"
  - *all targets including ARM 64-bit for mobile devices..??*
- *solid C ffi*
- *lacks eco-system and tooling*
- "Well, I'm using SDL2, and a compiled library for audio, and ~10-20,000 LOC. I can load those in csi, but the interpreter is so slow nothing really works. And a clean compile takes 30 seconds or so. The binary runs OK, not as fast as Chez, but acceptable. But I can't do interactive dev in it.

  Chez is compiled when a module loads, and as you work in the REPL, so it's always fast. I can just load up my libraries and work interactively, or run the script and it has no noticeable compile time...In Chez I can literally just rewrite a function at REPL and it runs at full speed."
  - https://www.reddit.com/r/scheme/comments/vskb55/which_implementation_of_scheme_do_you_use_and_why/
******** guile
- uses GNU's run-time GUILE, in which guile scheme is the main language
  - TODO: maybe a product of Richard Stallman..??
  - *GNU provides a healthy community/eco-system*
- people seem to say that the *implementation is much simple, easier to understand, whereas racket's code-base is complex*
- *meant to be used as an extension language for C programs, embedded into C*
- JIT/byte-code, with pre-compiled byte-code
- had a big project of replacing the lisp engine/VM? in emacs with this run-time, which is more.. abstracted, enabling other languages to interact with it, among many other pros
  - *UPDATE: restarted work on this recently*
- slow on numerical code: "magnitudes slower than LuaJIT"
******** racket
- aka PLT scheme
  - Naughty Dog's GOAL lisp was based on this
- *uses a fork of chez*
- all-in-one tool-kit, thus the easiest to jump into and make stuff! great for practice, but also one of the best implementations in general
- "The language platform provides a self-hosted IDE named DrRacket, a continuation-based web server, a graphical user interface, and other tools. As a viable scripting tool with libraries like common scripting languages, it can be used for scripting the Unix shell. It can parse command line arguments and execute external tools."
- *fully-featured: parallel threads, native compilation, has pretty much everything*
- *"batteries included"*
  - IDE program included, so no need for the emacs barrier
    - though.. i happen to love emacs.. so..
    - people say that it doesn't feel as interactive as chez 'n guile
- great documentation
- **gui programming!**
- has a standard scheme mode to code in pure scheme
- used in more recent Naughty Dog games!
******** RIP MIT scheme

considered one of the best, now rotting


******* C-generating
******** YES gambit
      - "*the portable scheme*"
        - *since 1988*, gambit-C in 1994
      - "The Gambit Scheme system is a complete, portable, *efficient and reliable* implementation of the Scheme programming language."
        - *best performance, after chez*
      - generates C
        - *seamless C AND C++ ffi / inlined*
      - generates js
        - js transpiler no good, ships the whole std lib!
      - https://try.gambitscheme.org/
      - slow compiler (but fast binary)
        - stopped dev for a bit but came back
      - installs well on all OSs
      - *seems to adhere strictly to the scheme standards*
        - *offers various versions too (R4/5/6?/7)*
        - thus, *doesn't have as much built-in, making it more modular, as scheme is meant to be*
        - "It's *basically R5RS with extensions*, with a compiler that produces very fast code that integrates easily with C code. *It is not a development environment; it is a compiler and an interpreter.*"
          - *lacks eco-system (though black hole is coming up..) and tooling*
      - native cross-platform framework..??
        - https://github.com/part-cw/lambdanative
      - "We "freeze the entire world and traverse the whole fucking heap" every frame on QuantZ (written in Gambit-C) and it doesn't matter much.

        Gambit-C doesn't have a real-time or incremental GC, but GC pauses are pretty predictable in length and are short enough that it doesn't matter. Just be somewhat careful with the memory allocations and where you leave resources, and you'll be fine."
        ...
        "We just run the GC every couple of frames, and it takes a few ms but nothing too significant. We're somewhat careful about minimizing live data though, and long-lived static data gets allocated someplace where it won't be moved around by the GC all the time."
        ...
        - https://www.reddit.com/r/programming/comments/9ad60/comment/c0c073b/
          - *17 years old!*
            - added generational gc in 2007
        - maker of Quantz on reddit as Yome
        - https://store.steampowered.com/app/37800/Quantz/
        - direct3d for windows, opengl for mac/linux

******** MAYBE gerbil
- v0.18 as of 11/2025
- *built on gambit*
  - thus generates c and has a c-ffi
- batteries-included
  - web/http libs, module system, macro system
  - *actor system concurrency!*
- seems aimed at embedded!
- great performance
  - https://www.reddit.com/r/scheme/comments/176cg7m/gerbil_benchmarks/
    - *beats racket (and therefore chez..??)*
******** OK bigloo
      - "a practical scheme compiler", 1995
      - "devoted to one goal: enabling Scheme based programming style where C(++) is usually required"
      - *generates C, JVM, .NET bytecode*
        - lookin' like haxe..
          - i'd rather it just aim for C, and therefore gambit, but this makes it a great *glue lang*
      - has many language extensions: modules, pattern-mathcing, oo/classes, multi-threading, posix programming (pipes!), event loops, *multi-media libs* etc.
      - *best ffi and easiest to embed* of these three
      - great potential performance due to strict typing (optional?)
      - *just 9 contributors..*
******** chicken
      - *PROBLEM: windows support shady*
      - "a practical and portable scheme compiler" since 2000
        - lol..
      - has both an interpreter (for interactive programming) and a compiler to generate C, yet also easy to embed it
        - but unlike chez, emacs-lisp, common-lisp, *it won't compile modules, so your interactive dev may churn at big modules..*
      - **best community, great documentation, great lib eco-system** (eggs)
        - https://wiki.call-cc.org/chicken-projects/egg-index.html
          - a nice single page site
      - very interesting implementation strategy that is educational for language implenentors
******** RIP stalin
      - stopped dev in 2006
      - "Stalin was a highly aggressive optimizing, batch-mode compiler designed to produce extremely fast, stand-alone executable images from Scheme source code, often outperforming C in benchmarks at the time. It achieved this by performing substantial global compile-time analysis, but in return sacrificed common development conveniences like an interactive read-eval-print loop (REPL) or the ability to load code dynamically at runtime."
******* embedded
******** chibi

to add scripting.. but may be better to go for the C-generating schemes for anything big..

******* special cases
******** DAMN cakelisp

https://cakelisp.handmade.network/
  - Metaprogrammable, hot-reloadable, *no-GC* language *for high perf programs (especially games)*, with seamless C/C++ interop
  - What's the status of Cakelisp?

    I use it every day. It is great for me. I've programmed my watch, my phone, my handmade mechanical keyboard, my current paid contract gig project, and more using Cakelisp.

    *I wouldn't recommend others use it because they can likely get similar success from creating their own C compile-time code generation/metaprogramming and custom build systems*, similar to what Ryan Fleury did with RADDebugger. *Taking ownership of your toolset and customizing it to your use case is the lesson to be learned here, not using someone else's exact tools. Different problems require different solutions.*

    I'm extremely glad I invested in building Cakelisp and continue to reap benefits from it.
    
******** gauche

for interpreter/scripting..??

******** steel
- an embeddable scheme (standard) interpreter written in rust, meant to be embedded into rust
- https://mattwparas.github.io/steel/book/about/features.html
  - "*Has a sophisticated FFI layer, where Rust is a first class citizen.* Unlike most languages where C is the choice for FFI, Steel wraps Rust using a stable abi layer and prefers Rust."
    - "native rust structs and functions can be easily passed to the interpreter to use. This means you can expose a set of functions to script your application, and steel can use them efficiently"
  - "Almost all of the built in data structures are immutable by default, including lists, vectors, hashmaps, and hashsets."
- *planned to be used by helix text editor for it's plug-in system*
  - which still would divide the code (compiled/binary + dynamic run-time), making it at best similar to vs-code, not quite emacs

******** clojure
    - java:
      - game note: i think you could use libgdx with it, but it wouldn't work well, as it's functional, with many features hindering performance greatly, when compared to using java..
      - solves a major problem in the JVM world: the need a of good language, that is simple and quick, yet functional annd makes great use of JVM's excellent multi-threading
      - *"It’s a glue language for assembling components, most of which are written in Java."*
        - *special use case: if you want to use java's libs, but not java nor scala, this is probably the quickest way.. and concurrent*
      - made for **server concurrency, hence it's functional programming paradigm**
      - Rob said it "adds syntax" and that *"it should be burned with fire!"*
        - indeed quite opinionated..
      - uses JVM, and thus allows using java libs and **transpiling to javascript (via clojurescript)**, making it a bit more practical
        - used by a ton of corporations
          - possibly the most practical scheme
        - *2nd most used language amongst jvm langs??*
      - https://clojurescript.org/community/libraries
        - web libs for DOM, react, etc.
      - "Clojure advocates immutability and immutable data structures and encourages programmers to be explicit about managing identity and its states. This focus on programming with immutable values and explicit progression-of-time constructs is intended to facilitate developing more robust, especially concurrent, programs that are simple and fast. While its type system is entirely dynamic, recent efforts have also sought the implementation of a dependent type system."
      - **babashka**
        - a scripting langauge (for clojure?) with a native run-time (via graalvm) and interpreter
          - (made in order to solve the problem of JVM's slow startup times)
          - nbb: node.js babashka
            - scripting on the web!
        - also includes a lot of scripting tools: task runner, jvm threads, cli libs, in addition to clojure's libs
        - emacs dev env plugin CIDER or intellij idea plugin Cursive



https://ane.iki.fi/2020/10/05/between-two-lisps.html
  - guile 'n scbl, also notes emacs-lisp, chicken, fennel

https://news.ycombinator.com/item?id=25895807
  - "Scheme is not more minimalist than C.L. in practice; it's standardization is simply more fragmented and has nested layers, often by different organizations, that implementations can support, and then most implementations go well above even that.

Different Scheme implementations tend to share a common base but then tend to provide functionality above that, often shared between different implementations as well."

https://news.ycombinator.com/item?id=25925867
  - good info on pros 'n cons of several implementations

"9. The whole language always available. There is no real distinction between read-time, compile-time, and runtime. You can compile or run code while reading, read or run code while compiling, and read or compile code at runtime.

Running code at read-time lets users reprogram Lisp's syntax; running code at compile-time is the basis of macros; compiling at runtime is the basis of Lisp's use as an extension language in programs like Emacs; and reading at runtime enables programs to communicate using s-expressions, an idea recently reinvented as XML."

a lesson by Naughty Dog game studio's lead dev:
https://all-things-andy-gavin.com/2011/10/25/lispings-ala-john-mccarthy/
  - "...from Crash Bandicoot a much more elaborate language for coding all the gameplay objects called GOOL. In Jak & Daxter I went full on crazy and wrote a native compiler for an object oriented full featured Scheme language called GOAL. We wrote 98% of four Jak & Daxter games in it, including the vector unit assembly."
  - "One of the interesting things about LISP is that it’s actually a pretty easy language to parse, interpret, and compile. This isn’t actually an accident as the S-expression syntax was initially chosen for it’s machine regularity (in those early days of underpowered mainframes). Newer languages are syntactically much more complicated. Ironically most normal programmers, being human, seem to find the more complicated syntax easier and the “simple” S-expression syntax confusing (being backward much of the time to normal human convention). I always found it unambiguous, but go figure. It’s also precisely this regularity that makes the awesome macrology of LISP possible and has allowed the language to remain relevant despite its advanced age."
  - But by the mid 2000s I started doing the kind of programming I used to do in LISP in Ruby. It’s not that Ruby is a better language (although it is a good one), but mostly it was the momentum factor and the availability of modern libraries for interfacing with the vast array of services out there. Using the crappy unreliable or outdated LISP libraries — if they worked at all — was tedious. Plus the LISP implementations were so outmoded. It was very hard to get other programers (except a couple enthusiasts) to work that way. And ugh, those old CMCL and ACL Garbage Collection code/algo’s were (at least when I last used them in 2006) so awful. In ACL I’d get these LispMachine-like multi-hour GCs.
  - Ruby had a great book (Programming Ruby 1.9 & 2.0: The Pragmatic Programmers' Guide) (I put big stock in that) and struck a decent compromise. It’s type system and object model are better (or at least more modern) than Common LISP anyway. The syntax is more inconsistent, and the macro model nowhere near as good. In Ruby you can manually build up strings and feed them into the interpreter, which is equivalent to simple backquote. But you can’t easily do the kind of cool nested constructions that are trivial in LISP.
  - But it turns out. Libraries and implementation matter a lot. Momentum too. Ruby has momentum, people supporting it who aren’t older than me (and I’m not a young programmer anymore, started in 1980!) Still, you can feel lots and lots of LISP influence in all the new runtime typed languages (Ruby, Python, etc). And 30 years later, listeners still rule! Using a language without a listener is like walking without legs. I pity the C, C++, Java only type programmer.
******** fennel

embeds into a lua program..?
  - an abstraction atop another abstraction..??

*** IDEA Smalltalk
  - **can edit *any* part of the program while it's running**
  - the IDE is basically like an OS, written in smalltalk itself
    - **browse any object** (not class, but the underlying data
  - when you save a project, you just save an "image" of all the code, there are no files
  - however, because there are no files, and that you are forced to use it's only IDE, often which looks like it's stuck in the 80s or 90s, it detracts most people
  - https://squeak-dev.squeakfoundation.narkive.com/wuWIwY6M/game-programming-in-squeak
    - discussion why it isn't good for games
  - made in a MIT lab in 1980, huge influence in all programming langs: VM -> Java VM, objective-c, all "object-oriented" paradigms, etc.
  - dialects:
    - "Pharo has the lion’s share of Smalltalk attention in open source. I’d guess Glamourous Toolkit has much of the rest. Squeak is nearly moribund and Cuis is basically a one-man show."
      - https://www.reddit.com/r/programming/comments/tws825/pharo_10_the_pure_objectoriented_language_and/
    - "Hardly you will find very large infrastructure "industry-bent" projects as Pharo's in Squeak or Cuis because the focus is different. Said in poor words, and at the best of my understanding, *the aim of Squeak and Cuis is the dynabook, a creativity tool, the aim of Pharo is more like to make a Smalltalk competitive with Python / Java."*
    - https://www.reddit.com/r/smalltalk/comments/1did2s0/what_are_the_main_differences_between_squeak_and/
      - pharo's philosophy is heresy, also: forked the opensmalltalkvm (used by squeak), depends on third party libs not written in smalltalk, also gets rid of morphic (gui)
**** dialects
***** PROJ Squeak
      - created some resurgence as it was made by the main makers of the lang (Alan Kays), but also dying out just as suddenly due to lack of community, perhaps most being of his age and similarly academic or scientific; it's web-site is composed of a messy wiki that is often out-dated by 15 years, and it's package manager is just as old and out-dated; it's UI looks like Windows 95
      - https://squeak.org/documentation/
        - squeak docs site contains free books for squeak, such as 'squeak by example', but also the original four smalltalk books from the 80s
      - http://wiki.squeak.org/squeak/2983
        - main wiki page is a list of links, including some intersting historical ones
      - the FFI page was updated pretty recently, 2019?, and it's one of the main libs of the Squeak core repo
        - <https://wiki.squeak.org/squeak/1414>
      - croquet is an example of FFI use for OpenGL
        - <https://github.com/NikolaySuslov/croquet-squeak/blob/master/OpenGL-Core.package/OpenGL.class/class/example.st>
      - the Morphic interface is basically what Scratch, the educational game'ish programming app, is
***** TODO Pharo
      - forked from Squeak in 2008, it is far more contemporary, with a great site, docs, etc., leveraging the power of github, newer ui, an uprising of creating new libs including low-level gpu api and low-level ui framework, pretty awesome!
        - TODO: therefore not image-based..??
      - https://pharo.org/documentation
      - https://www.pharo.org/features
        - smalltalk is *insane*
      - seaside
        - web framework
***** Cuis
  - ??

    
***** more specialized dialects:

****** TODO Glamourous Toolkit
- kind of **the emacs of smalltalk**
  - "It seems an editor/database query engine/ browser with a object oriented language Pharo as control/scripting language, while emacs is an editor with emcas-Lisp as the scripting language."
- uses the features of smalltalk for specific applications like code-base exploration/documentation, build an editor, etc.
- built on Pharo, though it's a project of it's own
  
****** Amber
- smalltalk live-coding environment for the web!
- implementation of smalltalk on the javascript runtime
  - therefore can use javascript libs
  - compiles to javascript
- https://lolg.it/amber/amber






*** MAYBE Julia
  - UPDATES:
    - https://news.ycombinator.com/item?id=26519251
      - in 2021, what it takes to simply render a basic image
        - *9.694037 seconds (18.29 M allocations: 1.164 GiB, 4.17% gc time, 0.40% compilation time)*
          - *THIS GOES AGAINST THE HAND-MADE WAY*
            - this an crystal fucked up... *imo, it's better to generate C than to go the llvm route..*
    - seems to be developing/progressing quite well.. and in a good position to replace ruby/python for big programs (unlike crystal and nim), mostly thanks to llvm, but it doesn't seem to look good on the scripting/interpreter side.. so it can't replace them entirely.. and though it is *very interesting for games, as they share the same problem: heavy computation*, the massive binary would suck for mobile devices.. thus it's kinda stuck to it's specialized domain: data-science, where, apparently, *computation, memory, and storage are completely dis-regarded..* :/
    - 2025: propietary aot..??
      - https://github.com/Suzhou-Tongyuan/SyslabCC-JuliaAOT
      - https://github.com/Suzhou-Tongyuan/syslab-deploy
        - julia ir -> c-like ir -> targets
        - "Out-of-the-box support for Windows, macOS, Linux and Android (iOS not tested)"
    - + AOT in 2022, then auto-compilation of packages in 2023!
      - https://docs.julialang.org/en/v1/devdocs/aot/
        - seems to support x86 thus far..
          - *julia actually may be better than ruby..*
    - https://docs.sciml.ai/Symbolics/stable/tutorials/converting_to_C/
      - C generation is basic, via some random math lib
    - i don't think it'll add an interpreter (or interpreter style jit, like luajit)
      - https://github.com/JuliaDebug/JuliaInterpreter.jl
        - community effort, failing
  - it's made specifically for academic data-science uses, so *it suffers from high RAM usage, startup time, and just a heavy run-time in general*, as it has some fancy stuff in there... *so not really useful for any of my use cases: web, scripting/cli-apps, embedded, shareable systems libs--though, llvm-AOT would make it really interesting for game dev..* Also, though it uses the llvm, it's dynamic/JIT-compiled, so *no compilation path (currently) for mobile/consoles..*
  - "Julia is a high performance scripting language used by academics, big data research, and some niche data science fields that require the performance (eg linear programming). As people said, it feels really well put together and has some nice syntactic sugar that’s missing in Python."
    - also macroeconomics/banks
  - slow progress
    - https://www.reddit.com/r/Julia/comments/1jsp1pr/are_the_developers_of_julia_content_with_the/
      - https://www.reddit.com/r/Julia/comments/1jsp1pr/comment/mlovgj4/
        - "Time to first x is a major issue. Pytest spins up in a couple of seconds for a couple of ~500 test codebases I work on. The Julia tests module takes waaay longer, and that’s for just a handful (<50)."

        - "Tooling sucks. LSP is borderline unusable, there are virtually no linting, formatting tools, etc. I’m used to writing python, rust and typescript nowadays - all of which have first class tooling. Julia’s lack thereof is a major pain."

        - "Documentation is horrendous. Even the official language docs are pretty half baked. Trying to work out how to do what I want is a nightmare."

        - "Development is just painful. Why does Julia need to precompile ~50 dependencies just to install a package? It takes ten minutes to add a dependency. Similarly, testing anything is hideously slow, because every time I run my tests, everything has to recompile (as I understand it), so presumably the language is generating a bunch of LLVM IR and then compiling that before it even thinks about running my tests. That is a bunch of overhead I could really do without, and it could surely be optimised away."

  - https://github.com/heyx3/Bplus.jl/blob/master/docs/!why.md
    - why julia for games
      - by a person who wrote his own modular game engine in julia
        - https://github.com/heyx3/Bplus.jl?tab=readme-ov-file
          - looks similar to heaps! just a bunch of wrappers 'n the basic utility functions
    - "Scientists are not expert software engineers, yet they need high performance, so they end up splitting their time and attention between one language for performant libraries (usually C/C++) and another for high-level simplicity and usability (often Python). This isn't ideal.

      If you're familiar at all with gamedev, you already know that we have the same issue! "
    - "Thanks to an extremely clever JIT engine, combined with aggressive Whole-Code-Optimization using inlining, constant-folding, and type inference, you can write complex abstractions which easily become zero-cost."
  - **MAYBE THE BEST SYNTAX(!!!), combining the best of all other scripting langs**
  - *llvm fast? yet dynamic runtime..?*
    - similar to elixir, though it has a slow startup time, it's very fast once it's running!
    - seems to have a unique multiple-dispatch / run-time function overloading impl, resulting in static type functions
      - "*Nearly every Julia function gets re-compiled for each combination of specific parameter types. When calling a function with arguments of unknown type, you do pay the cost of dynamic dispatch, but the function you dispatch to knows the types of these parameters at compile-time. In other words, parameters are always strongly-typed unless you explicitly mark them otherwise.*

        Therefore, *the only time you run into dynamically-typed data is when you create it within your own function, or if you call a function that returns it. Both of these cases can be caught with code introspection tools built into Julia, and easily mitigated. In fact, from what I've heard there is some new VSCode integration that highlights dynamically-typed variables for you, making it trivial.*"
        - this is a great language feature / way to beat the cost of dynamic typing..
       - "Julia is kind of in the middle between Python and C. Julia can't really know whether a variable is a float or an int either (unless you tell it explicitly), but: it cleverly plans ahead whenever you call a function. When you call a function with some arguments, all the function arguments are known. Julia then goes ahead and looks at every operation inside the function and figures out the exact CPU instructions necessary for these particular arguments! Once the exact instructions are known, they can be executed quickly. That's why a function takes longer the first time you call it: on the first call, Julia figures out all the types of all the variables and compiles it all into fast, exact CPU instructions. The second and third time, (if the argument types didn't change), it will cleverly reuse that code, and is blazing fast."
       - "Quick version: you call a function, Julia will specialize that call all the way down to its concrete types. So you write f(x), then call f(1.0), it'll compile something specifically for Float64. If none of the types change in that function (called type-stability), then everything can be statically-typed, so Julia compiles a version of the function where everything is statically typed, and thus you get the speed of a statically-typed language after the first call which just compiles. So basically it is multiple dispatch, i.e. the ability to treat functions as different depending on the types that you call it with, that lets Julia compile statically-typed functions for each concrete type you throw in there."
         - https://www.reddit.com/r/Julia/comments/77shs6/eli5_how_is_julia_so_fast/
     - "*downsides: Julia language devs will always prioritize scientific computing, so there are some things that it won't do much (or at all) that gamedev cares about*

       the biggest issue is mobile. Nobody is running climate simulations on their Android phone, so *it's very unlikely that Julia ever gets support for running on mobile*. It's also based entirely around dynamic code compilation, which could be an outright deal-breaker on AOT platforms like iOS...
       
       Another issue is that *compilation into a static executable was an after-thought...the binary is massive because you still need some dynamic compilation during play and therefore you need the entire Julia runtime, which includes things like LLVM and Clang.*"
       - *~150mb binary AND memory consumption minimum*, as the whole runtime is loaded and running, along with more stuff, like BLAS buffers (for math/computation)
       - maybe will compile to static binaries in the future..? but then wouldn't be able to use dynamic magicks..
       - https://viralinstruction.com/posts/badjulia/
         - a lot more problems with julia
  - Julia has foreign function interfaces for Fortran and C, the rest are "community"-maintained:
    - the ultimate glue-code language!??
      - i doubt it.. there must be so many memory-related problems specific to each FFI..
      - R, MATLAB, C-like langs, Java.. **basically a glue-lang for all the old languages used in scientific academia**
    - https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/
    - https://github.com/JuliaInterop
    - "*Julia can wrap .ll or llvm ir which is 1 step from cpu execution meaning julia can call anything that compiles to ir meaning rust, c++, c, python, all jot compilers are just frontends to llvm and julia can bind them like a universal language, people miss the point with julia. Data science blah blah, Im not a scientist but I use julia for direct integration with llvm. Look at RepliBuild.jl for more on llvm, julia and wrapping libraries and generating binds for julia automatically without writing the code your binding. Plus everything can be executed in parallel so yeah.*"
    - this is wild... but perfect for academic-use!
      - **a dynamic runtime enables the program and user to alter the data at run-time**, which is what data-science folks really need
      - this indeed is a very good reason to create a new language..
  - has a portable run-time? for deploying scripts..?? where?
    - https://github.com/JuliaLang/PackageCompiler.jl#static-julia-compiler
      - a community-made bundler solution..
  - "Julia has a *non-moving, partially concurrent, parallel, generational and mostly precise mark-sweep collector* (an interface for conservative stack scanning is provided as an option for users who wish to call Julia from C)"
    - wow.. sounds impressive..
  - *meta-programming*
    - https://docs.julialang.org/en/v1/manual/metaprogramming/
      - it walks you through the process of expr, s-expr, macros
    - parse-time execution
      - if type hints are not used, can be tough to debug
    - **lisp-style macros**
      - The parsing of Julia code, including the expansion of macros, is handled by an internal parser written in Scheme/Lisp. This parser utilizes a modified version of Femtolisp and processes files like julia-parser.scm and julia-syntax.scm.

        Therefore, *while you write Julia code in Julia syntax, the underlying mechanism that parses and expands macros during the compilation process leverages a Lisp-based parser. This allows for sophisticated code generation and transformation at parse time, a hallmark of Lisp-style metaprogramming.*
        - actually uses a tiny lisp interpreter for macros
          - https://github.com/JuliaLang/julia/tree/master/src/flisp
  - **designed for parallel computing**
  - https://www.reddit.com/r/Julia/comments/10p33sf/is_julia_suitable_today_as_a_scripting_language/
    - https://github.com/brenhinkeller/StaticTools.jl
    - https://julialang.github.io/PackageCompiler.jl/stable/apps.html
    - interpreter less important than compiler (*just-in-time compiler based on LLVM ORCJITv2 is used to generate native machine code*)
  - due to it's very specific domain use of science, it likely doesn't have libs for the things i'm interested in: web, games, etc., and in the case of web, elixir is just a specifically better solution..
  - an indian was one of the four to make it! :)
  - Jeremy Kepner at MIT Lincoln Laboratory was the founding sponsor of the Julia project in its early days. In addition, funds from the Gordon and Betty Moore Foundation, the Alfred P. Sloan Foundation, Intel, and agencies such as NSF, DARPA, NIH, NASA, and FAA have been essential to the development of Julia. Mozilla grant...
  




*** YES Ruby
  - a scripting language that people seem to really *love*
    - **my fav scripting language, and possibly my favorite language overall :o**
    - the community is built around the love for it and the community, which is healthy
      - ruby is not dead
    - **"made for humans"**
  - **DRAGONRUBY**
    - though, technically a fork of mruby.. see entry under [mruby]
    - *may get an AOT compiler soon!*
  - shares syntax with *crystal* and *picoruby, mruby/C*
  - *has a much better leader than Google, not breaking the language as python did, but continously, slowly, developing over time*
    - 3.4 tries to tackle the namespace problem, which was one of the main problems of ruby that was going to be solved in v2, but didn't as he didn't want to break it
      - *ruby has a global namespace*
        - hacky, but not so bad, just have to be careful, as one would in C
        - mostly a problem if a lib/gem uses it
      - *if a mixin contains two modules that share the same object names (functions, clases, constants), they could clash*
        - this is the main thing to be careful about.. otherwise, most things are in modules or modules within modules..
      - annotation, like python decorators / c# attributes
  - the frameworks 'n libraries seem to be more web-dev-oriented, mostly thanks to Rails, the language's premier web framework.., but also Jekyll (used by GitHub Pages), Roda (*this one looks amazing...*), Hinami, Middlemen (this looks like a good step up from Jekyll), and more..
    - there are two particular frameworks that compile to machine language: DragonRuby and RubyMotion, for cross-platform game and apps, deploying to just about any device! :o It sounds like haxe's frameworks! Unfortunately, they are closed-source, giving it a more closed-off, isolated feeling, and they cost quite a chunk of money to try...
      - rubymotion, unfortunately doesn't compile to windows (but it covers mobile and linux/mac)
        - turbo native, seems to have taken it's place..
  - **"Matsumoto describes the design of Ruby as being like a simple Lisp language at its core, with an object system like that of Smalltalk, blocks inspired by higher-order functions, and practical utility like that of Perl."**
    - that's the best description of it, and precisely why i love it
  - aims to be natural, like English;
    - **also_uses_snake_case_convention** :o *finally*, someone gets it! although, maybe-i-like-this-better
    - uses 'some_function?' for functions that return true/false *neat!*
  - https://news.ycombinator.com/item?id=23431941
    - crystal vs ruby
    - "Ruby's "metaprogramming" is something Java, C# and JS don't do well -- dynamically redefining things during runtime. **Everything in Ruby, including literals and operators, can be redefined during runtime, because everything is an object, and every message passed to any object can be redirected, filtered, transformed ad hoc. It's not just classes can be modified. Specific objects can be modified. Well-crafted Ruby code breaks things up into mixins that can be composed together. The closest comparison is one of Ruby's inspiration -- Smalltalk."**
      - TODO: hmmmmm
  - **makes meta-programing easy**
    - in other languages, especially static ones, you must build a macro, which takes a bit of time to get used to, often in some other function or even class/file. in ruby, it can be as simple as one method or key-word
      - the con: in Ruby it's simply too easy to make a mess. You can write bad code in any language, but, in Ruby, you can do it at ten times the productivity. Monkey patching, opening classes, metaprogramming, and even the vileness of eval all have their uses, but they can lure you into some sweaty situations just as rapidly.
    - **libs have far more elegant and novel solutions** than python's libs due to opposing styles
      - DSL galore, due to this
  - **incredible syntax**
    - **_extremely_ clean syntax**
      - uses the last statement's expression in a function as the return value, thus saving a line; and oh you can easily write one-liner functions with Ruby! :o
      - can omit the '()' in function()
      - no need for 'var'
    - **terse syntax**
      - "It's terse without losing readability. Less typing, less time spent with IDEs and boilerplating classes, mucking around with function prototypes, etc. Ruby borrows enough from perl to have some of that "hack it out in a day" flavor without being quite as unreadable and esoteric as perl."
    - **readable syntax**
      - there are many ways to express, and one reason is for readability, even at the cost of performance  - "Blocks are awesome. They're basically just closures, but the inline syntax is really powerful"
  - *modular libs and global namespacing make it painful to find completions*
    - *you must include/require every little thing you want, because there is no std lib*
      - compare this with haxe, where you have ~3? namespaces total (haxe, sys, std)
        - this creates a far better dev experience, especially offline / deep dev sessions
        - though, nowadays with ai, we are alleviated from searching for things..
      - though, i think this a problem for all scripting langs..
        - no, they have namespaces..
      - on the other hand, i think you do the same thing in go..??
  - "This sort of block gives you that "I did something pretty cool in one line" feeling."
  - **perfect for text-processing, hence it's use by systems admin/dev-ops for scripting/automation**
  - seems to have a **_quirky_, more diverse, rad community vibe, similar to Haxe :), but perhaps more accessible and diverse, whereas Haxe attracts just game-makers**
  - *Metaprogramming* "so you can dynamically create / change / etc behaviors using anonymous methods, closures, etc." and also writing a DSL
    - https://www.randomhacks.net/2005/12/03/why-ruby-is-an-acceptable-lisp/
      - a great read comparing lisp to ruby
    - **"Ruby makes hard things easy (think meta-programming, functional programming, etc). Bad programmers overuse it all the time (just because you can use the tool, you do not always have to), and other programmers suffer."**
    - "Ruby's "metaprogramming" is something Java, C# and JS don't do well -- dynamically redefining things during runtime. **Everything in Ruby, including literals and operators, can be redefined during runtime, because everything is an object, and every message passed to any object can be redirected, filtered, transformed ad hoc. It's not just classes can be modified. Specific objects can be modified. Well-crafted Ruby code breaks things up into mixins that can be composed together. The closest comparison is one of Ruby's inspiration -- Smalltalk."**
      - you can even add methods to the main parent Object that everything inherits!! :o *everything is an Object (capital O)*
      - Ruby even lets you add a method to a single specific instance of a class

  - Ruby 3, is 3x faster (was released just before 2021)
    - most performant libs have hand-written C in them, just as python does, so performance often isn't an issue anyway
      - *only function calls to C add up*
    - concurrency/parallelism
      - LIMIT: GVL only limits CPU tasks, not IO tasks
        - so, *you can have multiple threads to parallelize io stuff*
      - threads for basic native OS concurrency
        - automatically scheduled
      - fibers/co-routines for *io concurrency*
        - must manually schedule
        - async lib to automatically schedule fibers
        - *compared to go, maybe not as pretty of a solution??*
        - https://www.reddit.com/r/ruby/comments/16xsjxl/comment/k358oz7/
          - "When a program schedules how a thread executes it is called a green thread. Operating systems have many decades of optimization for how to schedule threads so it’s quite difficult to beat them. In Ruby 1.9 they switched from green threading to real operating system backed threads. What we call a fiber now is essentially a green thread with no scheduler. This is like a coroutine in other languages"
          - "...In Ruby 3.something they introduced the ability to define a scheduler at the language level and now gems like “async” can auto switch fibers based on IO (like if you say “run this DB query” the async gem knows it can run something else until that info returns. The async gem effecively implements an event loop like javascript. So you still have to be careful about not blocking the loop (just like javascript)."
      - ractors for *CPU parallelism*
        - limited, as you cannot share memory/objects
        - still experimental (read: buggy) as of 2024
        - compared to elixir, it requires a lot of work to do this, whereas in elixir, it's built-into the language
  - 3.4
    - *adds TypeProf, "a type analysis tool, which are the “first steps” towards a “future with static type checking, without type declaration, using abstract interpretation”*
      - *Matz hates type declaration*, and unlike python, doesn't want to use type hinting or decoration
    - *prism, a new single header C interpreter, will soon replace the main Cruby impl*
      - *error tolerant*, universal
      - useful for LSP and code formatting (rubocop), where code is parsed very frequently
        - originally, the tools used a different compiler (interpreter), but this effort would make this one universal, used as a compiler and across all tools
        - error tolerant is useful for when you have multiple errors while editing a file and want to see them all, instead of just stopping on the first error
        - 20,000 LOC!
    - *ruby.wasm*
      - *data class*
  - *opal, a javascript transpiler* still seems up to date..!
    - not sure how it compares to haxe..
    - *TODO: how would this work for writing client-side..??* maybe just for server-side stuff.. for nodejs io peformance??
    - *TODO: worth trying!!*
    - https://www.reddit.com/r/ruby/comments/10b1ici/opal_v17_released_with_ruby_32_support/
  - "monkey patching - "If you need a Class to work slightly differently, you can monkey-patch it (this can get dangerous, but sometimes it’s super useful) — you just re-define the Class, which “opens” it, define the methods you want to add, and they are implicitly added."
  - *memory hungry*
    - **possibly it's biggest con**
      - the cost of having "everything as an object"..
    - *instead of using simple data types, even the simplest data types are objects, taking up a minimum of 8 bytes, and often, 8x8 bytes*
      - i'm not sure if you can do bit operations..
      - i'm not sure if there are short ints, or anything smaller than 8 bytes
      - pointers also take 8 bytes
      - the last two bits of an object are used internally, to ID an object, particularly for garbage collection
  - *fine control of GC*
    - https://shopify.engineering/adventures-in-garbage-collection
      - TODO: add to [ruby] notes
  - **too slow for games?? :(**
    - yjit (runtime)
      - **ships with ruby 3.1**
        - all platforms except windows :(
      - optimizing compiler generates assembly
        - LIMIT: C extensions
          - thus, ruby gems with C extensions are being re-written in Ruby!, so that yjit can optimize it, and sometimes, provide better performance, along with much easier maintenance!
      - https://shopify.engineering/porting-yjit-ruby-compiler-to-rust
        - maxime writes a bit about porting yjit from C to rust
    - artichoke (runtime)
      - a ruby made with rust
      - experiment with all sorts of possibilities: including native compilation, webassembly, etc.
    - natalie (runtime)
      - a ruby made with C++
      - native compilation
    - GraalVM (runtime)
      - a VM for Java, and possible implementation for other languages: Ruby, Python, and Javascript, for example, are all official
        - *TruffleRuby is near java speeds!!*
          - but also *eats up 5-10x more memory*, and has *really slow startup time*, making it unusable for web servers and scripts, which are it's most popular uses
          - *however, it could be good for games??*
          - https://github.com/oracle/truffleruby
          - https://eregon.me/blog/2022/01/06/benchmarking-cruby-mjit-yjit-jruby-truffleruby.html
        - allows one to use several languages and libraries together! :o
      - https://en.m.wikipedia.org/wiki/GraalVM
      - https://github.com/graalvm
      - by Oracle, used by Facebook and Twitter
  - *a fantastic set of features, nearly from inception*:
    - object.map => { anonymous function / lambda / closure / "block" (i dunno difference) }
    - container.select/find/filter {|item| item == item_i_want}
    - getter/setters
    - modules (this is interesting and have not seen before: basically can include group of methods to an object! :o), etc.
      - all of this is notably far more *neat and concise* than C#
  - see this for major differences: https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/
  - https://bundler.io/blog/2023/01/31/rust-gem-skeleton.html
    - glue rust to ruby(!!), with new bundler update
  - although i missed this generation, i think i would have enjoyed this little world :)
  - like Haxe, seems to have *a loving cult community of hackers :)*
    - *this alone makes it much more appealing to me than the other pop general languages*
  - github/gitlab, shopify, doordash/postmates/instacart, stripe, etc. countless big web products
    - shopify invests in ruby dev
  - *made by one lovely Japanese guy, for the sake of providing happiness/joy :)*
    - most popular in japan
    - as open-source as it gets
  - https://www.quora.com/Is-the-programming-language-Ruby-dead-It-seems-too-simple-and-limited-compared-to-other-languages
    - I've seen ruby being used for webapp (the most common usage these days), as an automation language (Chef), for high volume data processing tools (FluentD), for desktop apps (ruby + Glade), as a tool to build videogames, for network middleware, as scripting tool (as in system admin kind of a thing).
    - Now, over the last few years ruby in the form of rails, has seen some of its userbase move to other things like node, like go and others (I know people who ditched ruby to go do php). *That's mostly because other technologies finally got on par with some of the amazing concepts on ruby/rails.* That's also because *there is this misconception that states “Ruby is slow” - ruby isn't slow, your code is slow, your solution is slow.* Maybe Ruby and the rails community haven't exactly excelled at teaching people to build fast code - they actually have always been *focusing on doing the “opposite”, not do fast code but do code fast.*
      - Ruby is a complex language to master and it’s a challenge to write an interpreter for it...*In general terms, the simpler a language is to implement the harder it is to write code using that language :)*
      - *Ruby is dead. Long live Ruby...What’s happened to Ruby is that it’s matured.* It doesn’t have a bunch of folks jumping up and down saying “do everything in Ruby!” … what it does have is lots of people quietly getting lots of shit done in Ruby … just like a ton of other languages that nobody’s super-excited about anymore.
      - *Ruby is anything but simple. Simple would imply a single way of doing something. Ruby gives you five ways of doing everything. I legit think it's one of the most complex languages that's in common use.*

*** KILL Python
  - perhaps the most popular scripting language (after javascript), even as of 2022(!!), in direct competition to ruby
  - frameworks and libraries seems to be more scientific-oriented, with machine learning, *ai, math*, 'n so on
    - numpy, tensor flow / *pytorch*, plotting libs, jupyter notebooks, etc.
    - *web frameworks: django (rails copy attempt), flask (sinatra copy), drupal (cms)*
      - for writing straight-forward APIs, *leads to an easy re-write in Go*
    - *sys admin / devops tools: ansible*
  - *pretty mundane, simple, straight-forward (procedural) can't go wrong with using this as a scripting langauge*
    - and therefore doesn't attract a rad, innovative community as ruby does
    - has a few meta-programming features..
      - beyond introspection and decorators, it seems these are generally warned against ever using..
      - introspection (the inspect module)
        - quite complete..
      - eval/exec/compile
        - TODO: i mean, isn't this all you neeed..??
      - metaclasses
        - the class that defines how other classes are created
          - modify or extend classes during creation
            - NOTE: not at run-time.. thus nothing special here..
      - decoraters
        - "functions that take another function as an argument and return a new, modified function"
          - does this count as meta-programming..?
      - money patching..??
        - never knew it had this..!!
        - lol, probably it's most dynamic feature..
  - *"Much of the language consists of special cases rather than general features that combine in orthogonal ways." (as ruby does)*
  - *the syntax is among the most readable, and it shows by it's popularity and love from first-time programmers*
    - although, it's just a preference... **i def prefer delimiters over whitespace as delimiter**
      - there's also no real reason to limit to whitespace delimiting, as Haskell proves that it's possible to support both ways
  - *files are modules, which is lame, forcing you seperate code into many files*
    - maybe needed for local namespacing..??
    - i didn't like this association in haxe either..
  - actually more hacky than ruby, and not in a good way, but as a product of it's bad development
    - https://www.quora.com/What-are-the-main-weaknesses-of-Python-as-a-programming-language
      - __something__
      - len() is a function as opposed to being a method
      - string instance methods returning value (“aaa”.capitalize()) (much stranger when compared with the fact that len() is function not method)
      - getter/setter syntax
      - "".join
      - etc.
      - "Lack of anonymous multi-line functions, combined with unintuitive scoping, has sent me scurrying to Node.js or Ruby time after time. Python syntax is great for a a pipeline of heavy computation, but becomes unwieldy when weaving together asynchronous calls."
      - I'd really prefer an easier way to figure out which exceptions a given class or function can raise. The only way I know of doing this now is to hunt through the source code or look in the documentation and hope that it's comprehensive in this regard.
      - Circular import errors. Imports are statements too, and they can fail if the objects they target have not been created yet. Compare this with languages that support separate compilation (C family and ML family languages), and can link at runtime without having to worry about the order in which things are defined.
  - *pypy*, an especially fast runtime implmentation putting it at Lua speeds, but not so practical, as many libs many still not work with it
  - Google
    - also *in Google fashion, they broke the language-compatibility for the v3 update*
    - *Google just sucks at long-term vision, design, and maintenance*
    - has that google feel to it: it works, but that's it

*** KILL Javascript
  - actually may have a better development story than python!
  - *an old dynamic language used by browsers that has over time become used for everything, especially after node.js enabled writing web backend code with it*
    - "JavaScript (later: ECMAScript), originally a very small, highly domain-specific language, limited to running within a web browser to dynamically modify the web page being shown, that later developed into a widely portable general-purpose programming language.""
  - surprisingly *MIGHT JUST BE THE MOST READABLE POP SCRIPTING LANG!*
  - through Node.js, Express.js (sinatra-inspired micro-framework), etc. 'middle-ware" frameworks, it can then be used server-side
    - **neither javascript nor Node.js really have a standard library, hence the development of a chaos of terrible libraries**
      - yikes!!
  - retarded manual type checking (===, NaN, etc.)
  - has a few, limited meta-programming features
    - (likely for compiler efficiency reasons)
    - eval
      - alt: Function keyword to create functions at run-time
    - introspection
      - see chrome developer tools
        - dev console
    - dynamic property creation and modification
    - a dynamic way to extend object (prototype-based) functionality
    - proxy and reflect api
      - TODO: re-read..
  - deno, bun
    - alt standalone runtimes/VMs
    - deno is the succesor of node.js, made from the same guy, admitting his faults
  - Google's v8 engine is a JIT marvel, much like java's VM, but massive, unweildy


*** KILL other more specialized scripting langs
**** Perl
  - note: dev branched at Perl 5, with Perl 6 becoming Raku [see past langs]
  - "It makes sense that Perl started out as a text processing language.."
  - $a $little $cryptic, but not as bad as i thought!
  - cryptically terse text-processer with a heavy emphasis on regex DSL
    - thus making it popular among dev admin/linux sorts of people
    - though, more interesting than python..
    - from wiki: "Perl, a text processing language that later developed into a general-purpose language..."
  - seems to have the reputation that only old veteran bearded linux hackers have ever mastered it
  - embeds/interops with C++?

**** PHP
  - though it can be used as a general-use language, it's main feature is being able to be embedded into html.. making it rather specialized for web dev..
    - other langs have templating systems seperate from the language, creating a bit more abstraction, and less powerful, whereas embedded php can do anything
  - NOTE: still very much in use, with the most popular web frameworks: from wordpress to drupal to laravel to craftcms
    - surely no serious web app uses this though..??
  - $var, $func?, $_special_var, $everything
    - perl influence
  - perhaps the only thing worse than javascript, mixed with bash, and who knows, maybe some perl too
    - *not planned as a language, but just tacked on features like javascript*
  - *slow development progression/history over a long period of time, especially when compared to the quicker progressions of ruby and even python*
    - probably because so much of the web depends on it..
    - might soon add pipe operators (for function chaining)
    - only recently (2021-2024) added type checking (8.4, from hack lang?), enum, and match (like switch)
  - surprisingly good performance
  - Wordpress and Facebook have kept this alive for a long long time
  - hack (language)
    - a typed dialect of php by facebook


** static langs (statically-typed, automatic memory-management)

this is a vague un-named category (i made up "static langs").. but since languages can change, it makes 'em tough to categorize.. in general, they have these traits:
  - have a garbage collector, on by default, and most do not provide a way manage memory (save nim)
  - little to no run-time features, save introspection, for optimization reasons, and just being able to reason about the code (at compile-time) better
    - and thus static-typing for compile-time checking
  - may have advanced compile-time features: macros
  - may have strongly typed systems, good (ocaml) and bad (go)
    - TODO: wtf does this mean..
  - may have advanced compiler checking (provide checking and error-reporting for advanced features like: gadt, enum, generics, macros??, etc.)
  - a bytecode/vm implementation, though they may also provide a way to transpile to C or llvm-ir or even native assemblies

*these languages provide the best compromises while retaining high-performance and automatic memory-management*. their only losses are the dynamic run-time features, and possibly manual memory-management features/options (which is often done in C anyway..)
  - TODO: NOTE: it seems the biggest difference, or design decision, comes down to: to eval (at run-time) or not. if not, you open the potential for a bunch of (much easier) optimization and compile-time checking.. i now see why people are so against dynamic run-time langs.. the interactive dev just isn't worth it.. especially when you can compile an entire program into bytecode (or native in the case of jai!) in a second or two.
  
there's quite a bit of competition in this category..

but none are nearly as cool as haxe!!
  
*** YES Haxe
  - **my favorite general-use systems language**: simple 'n clean, *light-feeling*--feels like a scripting language!, **more powerful than C# and even nim's macros**, but without all the *heaviness* of it, **feeling more like a cross between actionscript and ocaml: though not nearly as expressive nor beautiful as ruby**, just *siiiick*, garbage collector depends on the target, **low-key best language of all-time**
  - **made for games!**
    - **though, with a garbage collector, instead of worrying about managing memory at a fine level, you worry about the garbage collector, which is a trade-off i'd very easily take..!**
      - https://www.youtube.com/watch?v=pZcKyqLcjzc
        - a dev of Dune using heaps notes *the main problem being memory allocation, not cpu, and sneaking in garbage collection times*
        - *it's absolutely worth not worrying most of the time, then just checking allocations via a memory profiler when there is a problem, or once in a while, as opposed to the insane development cycle of rust/c++, where you worry about everything all the time..*
  - frameworks include: NME, Heaps, OpenFL (now feels like it's stuck with too much Flash baggage..), HaxeFlixel, HaxePunk, Heaps, Kha; all of them are basically an i/o base **to create basically /anything/, cross-platform**. In addition, there's HaxeUI and bindings for React and React Native for cross-platform UI, and bindings for electron for web-style ui, and bindings for raylib, unreal, and maybe even target unity
    - shiro tech stack
      - https://www.youtube.com/watch?v=gazZSJFGnck
    - *hashlink*
      - *a runtime (JIT/bytecode and AOT/C), debugger, cpu profiler, memory profiler, graphics profiler (nvidia nsight), and bundle of game-related libs:*
        - *SDL, directx (vulkan was a pain), web-gpu soon, some basic native ui api, common stb-like libs, steam/console stuff, etc.*
          - basically what Adobe AIR did, but updated
      - a few optimizations listed on the site:
        "HL bytecode is strictly typed
        Fast anonymous objects access using typed "virtuals"
        *Static dispatch of object methods when no override exists*
        *Compact memory representation for all values*
        Inference to reduce null field access checks to the minimum (soon)
        *Low level access for pointers, single float, 8 and 16 bits integers"*
        - ..all this stuff really puts it ahead of other general-use langs.. especially the dynamic ones..
        - *much of this is probably impossible without compile-time type checking..*
      - introspection
        - via reflect and type api, and @:rtti metadata
      - Dynamic keyword, though it is recommended to avoid it..
      - no eval
        - as by this time the code is already transformed into bytecode or C
        - (note: see hscript for run-time eval)
      - concurrency (barely used by their games..)
        - **all of northgard runs on a single cpu thread/core, it's just the gpu that's struggling**
        - **their dune game only recently added threads**
      - https://haxe.org/blog/hashlink-indepth/
        - A small core easily extensible with additional C libraries
          - maybe doesn't need the entire std lib..?
        - **No crash - only catchable exceptions with full stack traces**
          - fault tolerant!?!?
        - **A strictly-typed register-based bytecode**
        - **Full interoperability with C (respect __cdecl) in both x86 and x86-64**
        - tools to debug byte-code
      - https://haxe.org/blog/hashlink-in-depth-p2/
        - **a custom garbage collector**
        - *A set of C functions to manipulate Objects, Bytes, Functions, etc.*
          - **full power over C!!**
        - "The separation between the VM and the run-time is necessary in order to allow the translation of HL byte-code to C."
        - **"because both HL/JIT and HL/C share the same run-time (same garbage collector, same native functions, etc.), they will run exactly the same without any difference in terms of semantics."**
        - "**HashLink has its own low level types** that are used for registers and function parameters. Haxe types are represented using the following low level types: ..."
        - **"Memory consumption in HL is identical to C, and might depend on the C compiler you are using:"**
    - **macros for games**
      - https://www.youtube.com/watch?v=pZcKyqLcjzc
      - https://www.youtube.com/watch?v=pZcKyqLcjzc
        - **AoS->SoA build macro**: convert a class (struct) with data (intended to be used in a container) into class (struct) of arrays, with simple access syntax via a build macro
        - AoS macros: **C-Arrays, C-structs** (@:struct and @:packed for arrays), for example hl.CArray<particle>
        - https://www.youtube.com/watch?v=gazZSJFGnck
          - 55:00
            - must do through C, no way to do it manually through haxe
            - why not generational gc, controlled gc is the way
    - https://www.youtube.com/watch?v=gazZSJFGnck
      - **"shiro game tech stack"**
        - **hscript, hide (domkit-based retained gui), castledb (game database), hxbit (serialization), MPman (network stuff, cross-platform, including consoles, the only part that's closed-source)**
  - *hscript*
    - *TODO: NOTE: if you want to see a how a simple implementation of a language, this is it..*
    - "Haxe script is a complete subset of the Haxe language."
    - "In some projects it's sometimes useful to be *able to interpret some code dynamically, without recompilation*."
    - *shares the same syntax with haxe, so the code is completely re-usable, in case you want to put it into the core program*
    - "*It is dynamically typed but allows all Haxe expressions apart from type (class,enum,typedef) declarations.*"
  - like C#, it has many contemporary features: anonymous functions, local functions, ADTs, properties, etc. and even a macro system (not sure if C# has this...), but far more succint and simple, without bloat, to the point
    - also has **macros** powerful than C#'s code generator and nim's macro system, both of which came much much later
      - https://github.com/SomeRanDev/Haxe-MagicArrayTools
        - **optimizes data transformation function chaining**
    - also like Ruby, it feels very *Linux-y*, where **everything is a simple text file**, including the build file (this is a major difference in feeling to C#, as it can feel like you must edit stuff in VS's gui, or even Unity's gui. In Haxe, **everything can be done by simple text editing**, no gui software necessary)
  - clean, scripty, actionscript syntax
  - maybe the first major language with **cross-platform** in mind? (2005 vs 2011 Dart)
    - has **a standard cross-platform library** that all newer languages try to copy
  - has all of the features of ruby (container filters, anonymous functions, etc.) plus more, but comes with a *much much* faster compiler, making Ruby feel rather obsolete, and just surviving off of it's libraries and community
  - **recently added module-level vars and functions, getting rid of the need of a main class to run it, making it feel more like a scripting langauge**
    - https://haxe.org/blog/module-level-fields/
    - missing the #/dev/env/haxe thing too.. hmm..
      - 'haxe run file.hx/ml' vs .filename
        - no need for 'chmod +x'..! it actually might be simpler..
  - module name, the "main" type of the module, file name, and package name are all tied together
    - pack1.pack2.packN.ModuleName.TypeName
    - kinda restrictive, but such enforcement def makes reading others' code/libs easier, and just makes one less thing to worry about
      - a module can still have several sub-types
  - **_incredible_ compilation options: compile to nearly any other language (including C and C++, to use C and C++ libraries, or to build in C for iOS/consoles/embedded devices, and javascript, to be run in a browser or to use pop javascript libraries or to compile to Node.js, and to bytecode which is then run by a VM (HashLink), itself with two options: HL/JIT and HL/C**, one for faster compilation speed and one for optimized run-time speed *whoa...*
    - NOTE: HL/C isn't readable C, it's bytecode turned into C :/
      - some drama on why they didn't maintain the existing C/C++ transpilers..
    - also traspiles to php, java, C#, etc.
  - PROBLEM: no parrallism..?
    - **concurrency looks easy: just add wait or yield, then use pecan.co lib macro to debug**
    - also have several concurrency libs for various implementations
      - https://player03.com/openfl/threads-guide/
  - auto-generate bindings for libs in many languages
  - don't feel overwhelmed by decades of C/C++ libraries to piece together, nor have to think about pointers/references/smart-pointers and header files
  - don't feel like one has to conform to the ways of Microsoft and the .NET framework: you can write your code in any way you want to, and use any tools you want to too! :)
  - small community feeling, will run into the makers on the forums, discord, or github (including the maker of Haxe/Heaps himself!!), can make a big difference :) but **the con of this is that there's simply not enough community power, so resources are scarce, web-site (including tutorial, book) and package manager are rather out-dated, etc.**
    - although there's a little community around frameworks in it, the dev team is rather closed off
  - it being used by games in production keep the langauge and various game engines 'n media frameworks well-maintained
  - made by one French guy
  - **my fav :)**


this is an example of hscript:
#+begin_src js
  // TODO: add haxe to org-babel!!
  var script = "
	var sum = 0;
	for( a in angles )
		sum += Math.cos(a);
	sum; 
";
var parser = new hscript.Parser();
var program = parser.parseString(script);
var interp = new hscript.Interp();
interp.variables.set("Math",Math); // share the Math class
interp.variables.set("angles",[0,1,2,3]); // set the angles list
trace( interp.execute(program) ); 
#+end_src
  
in general, beyond haxe/ocaml/erlang/etc., most of these languages are just a combination of the maker’s favorite languages mixed together. None are really innovative. Only only a few will catch on, become popular, have libraries, and live on... but that doesn’t mean they shouldn’t be used. Use whatever makes you happy! :) Anyway, it can be really cool making your own little world in your favorite language... As long as it works with C/C++, the worst case is you have to write some “interop” or otherwise “wrapper” code. 

*** OK (OCaml)
  - see [[OCaml]]
    - it's not purely functional, is garbage-collected, and very much also belongs here
      - i think like rust, it's functional by default (uses the same keyword too: let)
  - the oldest of these listed entries (after lisp), yet, still great, even has parallelism, and a great recent generational garbage-collector... i personally don't know of it's faults, beyond it suffering from a small community..
    - just no path to cross-platform.. instead opting for native compilation..

*** MAYBE (Nim)
  - see [[nim]]
  - have option to choose to use a garbage collector to handle memory
    - https://nim-lang.org/docs/mm.html
    - however, default has seemed to move to ARC then ORC (reference counting)
        - see https://nim-lang.org/blog/2020/10/15/introduction-to-arc-orc-in-nim.html

*** MAYBE Nelua
  - PERSONAL NOTE: this is probably the most interesting alternative to haxe.. very very close to C
  - lua-like in many ways: syntax, minimal design / few features that can be used to create more features via meta-programming
    - "Nelua tries to be more minimal and generate more readable and compact C code.", when comparing it to nim
  - meta-programming galore (static)
    - https://nelua.io/overview/#meta-programming
    - *great C pre-precessors*
      - single and multi-line ("clode blocks")
      - defaults to global pre-processor namespace, but can declare a local pre-processor namespace!
      - *require a module into the pre-processor namespace*
        - really neat!
      - use pre-processor functions to create polymorphic functions
      - *"pre-processing on the fly"*
        - "While the compiler is processing you can view what the compiler already knows to generate arbitrary code:"
        - "You can even manipulate what has already been processed:"
        - "The compiler is implemented and runs using Lua, and the preprocessor is actually a Lua function that the compiler is running, so it is even possible to modify or inject code into the compiler itself on the fly"
    - *great macros*
      - looks simlar to haxe
      - both of these are made quite simple
        - C replacements and C replacement macros for expression, identifiers, statements, etc.
      - *Blocks of code can be passed to macros by surrounding them inside a function*
      - use macro to create generics
        - looks annoying.. but then again, you'd learn/better understand how to make macros!
        - generalize macro to replicate C++ generics
    - *concepts*
      - a pre-processor on functions that allows you to do something based on the type of args (including polymorphism), at compile-time
      - TODO: STOPPPED HERE
        - there's quite a lot here..
    - *a ton of excellent C interops*
    - *compiler annotations at var/function level*
      - including inline
  - garbage collector is optional (on by default)
  - compiles (generates/transpiles) to C
  - *compiler written in lua, and thus completely modifiable!*
    - TODO: *hmmmm..*, lol
  - transpiles to C, no native compilation
    - in this case, i see no reason not to use haxe instead..
  - TODO: can it make use of lua's libs??
*** NO Crystal
  - *PROBLEM: slow dev*
    - PROBLEM: currently suffers from runtime struggles (memory usage, compile time (no incremental compilation))
    - PROBLEM: *windows os support sucks, it took 10 years to get it: 2014-2023+*
    - PROBLEM: LSP wasn't great last time i checked
      - https://www.reddit.com/r/crystal_programming/comments/1n909ui/outofthebox_ide/
        - https://forum.crystal-lang.org/t/why-isnt-there-an-lsp-for-crystal/7687/
          - apparently, it ain't easy due to the language! maybe some comprimises must be made..
    - PROBLEM: docs suck
    - PROBLEM: no great frameworks
  - conclusion: although it has all of the things i want--Ruby syntax, good C api, concurrency (but no parallelism :/), macros, garbage collection (wish it were optional though..)--*including nice macro syntax too!*, performance (static-typing and compiled via llvm), etc.--Haxe is *far* more developed and has been in production use for a long time now, including a top-tier JS/web target, a fast-compiling and performant VM target, and tons more stuff, in addition to solid cross-platform app and game frameworks, LSP, etc.
  - https://www.reddit.com/r/crystal_programming/comments/1abvkhy/how_does_crystal_compares_to_haxe/
    - i wrote out a long thought in a comment there, comparing it to haxe
  - this language is the one that **appeals to me the most** (of nim, julia, go, rust, etc.), as i've missed the whole ruby generation, but maybe can join it late with this :) ...but it seems to offer very little over Haxe, which already has most of these features, and many more years behind it
    - like Haxe, i *think* it uses the Boehm garbage collector (mentioned in a post from 2013), so, i don't think it'll offer any better performance than Haxe... unless it's concurrency implementation is better..
      - the garbage collector: https://github.com/ivmai/bdwgc
  - **"fast as C, slick as ruby"**
    - sounds like the dream lang..!
    - with a garbage collector, it competes directly with go
      - i just don't see much hope for it..
  - **community seems to go against ruby's community**
    - this has disuaded many rubyists from using it. *The values of the core maintainers do not align with the more loving, feminist values of ruby's community.*
  - like a compiled and static-typed ruby, along with being *much* faster, in fact, **at C++ speeds!?!?** :o :O
  - **syntax and style very very similar to ruby, like 75% similar**, **just as scripty-feeling as ruby too!!: no main function needed**, not forcefully object-oriented like haxe
  - yet deeply **object-oriented** in it's impementation just as ruby was too
  - macros and ASTs like Haxe
    - simpler to write, though not by much..
    - haxe's macros still more powerful.. (complete AST manipulation)
  - **concurrency like Go**
  - uses ruby's (or jekyll's?) simple yaml config (build?) file to fetch dependencies, making it very simple get dependencies from git/github
    - fixes ruby's main problem here..
  - **makes writing C-bindings easy, easier than Go!** and perhaps generatable? :)
  - transpiles to C (like Haxe), allowing it to use C compilers, and therefore making it really fast
  - i *think* they are building some way to be able to interop with ruby, so as to re-use existing ruby libraries...
    - i don't think it's possible without a ruby runtime.. maybe graalvm?
  - ayolite lib for ruby to call crystal
    - **unfortunately, no lib to call ruby code :(**
  - kemal lib <- roda/sinatra (a simple web app framework)
    - with ai to generate boiler-plate for libs, it should be easy to catch-up..?
  - https://crystal-lang.org/reference/1.3/getting_started/cli.html
    - a cli example in the main tutorial


*** MAYBE (lisp)
  - NOTE: not static, just wayy faster than other dynamic langs
  - PERSONAL NOTE: i'd personally give these a shot, as it's infinitely more interesting than go.. yet perfectly fine for it's same domain too (high performance, concurrency, cross-platform?)
  - common lisp/scbl
    - great native compilation
  - C-generating schemes (gambit)
  - see [[lisp]]


*** KILL Dart
  - PROBLEM: competes directly with haxe
  - PROBLEM: possibly the smallest eco-system of a major language
  - *Google's Haxe, wayyy after haxe :/*
    - comes with a good javascript transpiler
  - and just when you thought go was boring as shit..!!
  - flutter
    - "paint ui" - henrik, of doom emacs
    - basically made the language just to have this framework
    - *has hot-reload, which makes mobile dev a far better experience*
      - *TODO: but then again, can't any lang do this..??*
  - considered pretty dull, but it works; open-source, *designed to be cross-platform*.. like haxe..? *sigh*
    - compile to machine code, javascript, webassembly.. which is what many contemporary languages do..
  - object-oriented way past that paradigm prime
  - feels less scripty, more boring, lots of 'final' keywords
  - *supports mixins!!*
    - interesting..
  - *"Dart has a fully modern toolset with no proprietary bullshit (apple, the old microsoft) nor legacy bullshit (java). It comes with language server, formatter, package management."*
    - true, still better than java 'n apple.. but it's still Google:
  - quite fast
  - Google
    - Google cannot but trusted for their products, but their programming languages seem.. alright, albeit dull

  - https://www.reddit.com/r/dartlang/comments/1bbbexg/comment/ku8ct38/
    - "Dart is also a hard sell because, no matter the task, there's other languages with super interesting advantages. If you want a performant CLI, just use Go tbh. If you want a driver, just use Rust tbh. If you want a highly performant and concurrent back-end, just use Elixir tbh. If you want to tap on an existing ecosystem with lots of manpower to make your back-end, .NET Core is very popular, unfortunately. If you want to make videogames, you probably don't want to make an entirely new framework and game engine, so you'd end up with C++ or C#. GUI apps are like the only place where Dart truly shines via Flutter, and even that isn't totally figured out. Dart doesn't abuse FFI enough for its platform-dependent code to be entirely in Dart, which would be fucking amazing tbh."
 

**** KILL Go (golang)
  - PERSONAL NOTE: i think it's only defining feature is the "portable" binary build system (and minimal std lib..), which is something that requires quite a bit of man-hours.. (now that other langs have simply added its concurrency implementation--fibers/co-routines..)
    - as jon blow says, it's def another "big idea lang", which only exists due to a few big ideas
    - it's possible to create a better, more general-use language, and yet still be fast
      - in fact, they exist: common lisp, ocaml, haxe, and all of the [[C repleacements]]
    - each binary supports one platform at a time, it's just easier to "cross-compile", meaning build from any platform for all platform
    - but then again, doesn't rust, zig, etc. all have this..?
      - rust seems to require a bit more effort to set-up, and zig probably requires a bit more digging into the docs or trial 'n error.. whereas with go, it sounds like one command "go build" and changing the architecture var
      - in haxe, you'd have to generate C, then compile for each platform (via gcc, llvm, etc.). otherwise, just ship the bytecode and vm, which may be even simpler and more portable.., at least for x86-64
    - any other lang can adopt the fibers concurrency model
  - *"Go is easy, it doesn't teach you a lot. It doesn't try to. It wants to make you productive quickly for a narrow, focused set of use cases."*
  - *compiled python, or a high-level C, intended to replace python in high-performance and/or concurrent areas*
    - **it's boring, limited use cases dictates it's community: very very boring**
  - very good choice for performant, easy-to-read/maintain small programs: **particularly concurrent web back-end "micro-services" and cli**
    - **mainly known for adding easy concurrency and it's great build system**
    - *a lot of libs in these domains were re-written in go*, particularly terminal-related libs
  - specialized for *C-style procedural programming*
    - simple, zen systems-programming with the ease of past scripting languages, straight-forward, procedural style (like C), but pretty spartan and feature-less and therefore restrictive (also like C), making it **a bad choice for big applications (which often benefit from advanced features for architecting frameworks),** especially games
    - **a great way to get back into programming, and getting shit done, without being overwhelmed by features (haxe, ruby, 'n especially rust all suffer from this in their own way)**
  - feels very scripty (in syntax)! no static/explicit declarations?
    - not as zen as ruby though, as you've got *a bunch of redundant snippets of code for error handling / nil-checking..*
  - **unappealing for expressive people**
  - **no advanced features (generics, macros, etc.) nor abstractions (neither object-oriented nor functional paradigms)**
    - **thus making it tougher to make frameworks for all of my major use-cases: games, web-apps, gui apps**
  - *at the speed of C too! :o*
  - great garbage collector
    - *TODO: yet you can still use pointers 'n references..?*
  - **great build system**, compiles to a 2MB+ executable binary which contains the runtime (including the garbage collector), which can be configured to be cut down further
  - **great C FFI**: just import the C psuedo-package
    - (no "C extension" as in python/ruby)
  - a simple-to-use **concurrency** implementation, from occam lang?
  - **BAD type system**
    - TODO: why?
  - **took a long time to get generics**
  - Google, but open-source
    - **like all Google products, it's very lackluster, with some plain stupid design shortcomings, and just not well thought-out**
  - https://github.com/rromulos/command-vault/blob/master/cmdvault/cmd/main.go
    - a good example of a simple cli app
  - https://www.reddit.com/r/golang/comments/14vvwon/when_would_you_not_recommend_go_over_rust/
    - "The tooling ecosystem for Go is really good. Debugging in Delve is way simpler than debugging in Rust. The compiler is so insanely fast that it might as well be an interpreter."
    - *"number one killer feature is goroutines. They're incredibly simple to use and the runtime does an excellent job multiplexes work across coroutines and threads. It allows easily scaling concurrent workloads."*
      - though, *since it came out, many other languages implemented this feature*
    - "Simplicity as a feature. Go is so simple that I find it really easy to elevate my thinking from the language or small-scale problem up to architectural concerns. Because I spend more time with my head in this place, I often find I end up with better overarching solutions. *The unique niche of simple, high-level, but not obscuring the implementation details often makes my architectures even better than Python or Javascript."*
    - **"On Rust's side, the number one killer feature is correctness. Go has nil panics, goroutines stomping on shared memory, etc. In Go, you still have to program defensively, similar (but not nearly as bad) as writing good Python code. With error return values and being such a simple language this quickly becomes second nature, but it's still unnecessary cognitive load."**
    - *"As making the right choice for yourself, unless GC matters, personally, I'd start with Go, just because it's going to be incredibly easy to pick up for a Python dev, and immediately brings a lot to the table. Once you write some Go and start bumping up against the dark corners (every language has these), you'll develop an appreciation for why you might want Rust and have a better sense of if and when the learning investment is worth it for you."*
      - *the perfect starter compiled programming language*

 
*** VM-based langs

i have no interest in these languages because they are restricted by their vm implementation, mainly, they aren't cross-platform. In order for these langs to support a device, they must create a native compiler for the platform or a C transpiler. In addition, *iOS and most consoles don't allow run-time execution*.
  - minecraft is a good example of a game that was made in java/jvm, then ported to C/C++/lua

in addition, they are corporate, and they bring about a corporate, clunky, old, verbose feeling, of being over-organized, rather than scripty, hacky

x. clr/C#
   - i honestly don't understand how a clr-ir/l to C transpiler doesn't exist yet.. what a fucking mess for all those lovely kids that made games entirely in C# (via xna/fna).. :/
     - UPDATE: on jan 2023, FNA adds console support via NativeAOT
       - however, many game devs went through a ton of pain to port their games before this.. often paying some company.. and with no help from micro$oft, re-building mono/.net core, fna, nativeaot(?).. /ugh!/
         - (Celeste released in 2018, Castle Crashes in 2008)
     - ai says clr isn't designed to transpile to another high-level lang..
x. jvm
   - standalone vm means no mobile/consoles

**** NO (Julia)
- though not static, it's optimized to do math quickly, which is precisely what games need
- see [[julia]]

*** KILL JVM
  - see [[meh, not interested]]
  - libGDX
  - the most advanced vm
*** KILL CLR
  - see [[meh, not interested]]
  - Unity
  - XNA/FNA


** systems langs (manual memory-management, native compilation, statically-typed)

systems langs often have these traits:
  - compiles ahead-of-time (AOT) to a native (to the machine's architecture) binary executable
    - this is opposed to relying on a VM impl
  - manual memory-management
    - at least has the option to allow the user to manage memory
  - static run-time
    - generally, the user can't do much to the program at run-time
    - statically-typed (unable to alter the type of) identifiers, thus enabling the compiler to check during compile-time

in order to write or even edit these programs, you need the build tools, to build the machine-specific binary file, which means you need build tools for each and every platform you want to target. That means: MSVC++ for windows, Xcode for mac, Android/iOS SDKs for Android/iOS, gcc for linux, and so on. This is also true in the case a lanaguge simply generates C code, wherein, you'd still need the tools to build for C.

go and rust (and zig?) seem to have stream-lined the build systems down to one command: build--'go build', 'cargo run', or whatever--and produces a single portable binary (no linking?, no extra .dll files or whatever C/C++ does).
  - TODO: how does go's portable binary work?? is it just for x86-64 and ARM?

haxe is quite special here in that it provides the option to either generate bytecode that be run cross-platform or generate C for optimization, both of whih should result in the same exact program.

at first i thought games really needed it, but as all dynamic languages interface with C, i don't think it's THAT bad.. Interpreters are magnitudes slower. JIT can actually be enough for many games. But.. i dunno.. **The development experience of a dynamic language, especially for games, is just as important, and even more important than performance to me. Hot-reloading is the minimum i desire, though even C/C++ can achieve that. Lisp-level altering anything and smalltalk-level editing experience are the maximum potentials. Anyway, DragonRuby may actually get an AOT compiler, so we'll see..!**




*** C++ and its replacements / manual memory-management (or at least the option) / native compilation
**** YES Jai
  - the only solution
  - word on the street: better than both odin and zig
  - compiles jon's giant sokobon game in 1.7 seconds on a laptop!
  - https://github.com/Jai-Community/Jai-Community-Library/wiki/Overview
    - a ton of info on the lang..
    - no package manager
      - !!!
    - new is a function, and you can change the way memory is allocated by passing a different context
    - no references
    - no object-oriented crap: classes, private, etc.
    - hygenic macros
      - restricted to compile-time
        - (as run-time macros/manipulation would require JIT and great performance loss)
    - *compiler directives, compiler-based-code-generation, macros > language features*
      - *provides a ton of [[compiler directives]]*
      - generally less features, especially if it's possible to build/add them using all of the tools that language provides
        - this makes it very explicit of what's going on
    - *unlimited compiler control*
      - see [[compiler control]]
    - *macros are syntactically indistinguishable from regular functions*
      - simply '*#insert string-of-code*' to compile time
    - no exceptions
    - no pre-processors
      - as they are un-debuggable text subsitutions
    - no co-routines
      - probably considered a "big idea" lang, lol..
     - function currying at compile-time
     - *arrays as main data type*
       - unlike lisp's focus on linked lists..
         - *doh! this seems like the core problem of lisp..!!*
     - linked lists are structs
       - NVM: interesting..??
         - hmm, looks like the one i implemented in school.. just a normal struct with data and a pointer to the next one..
     - *unlimited compiler control*
     
***** compiler directives

comes with a bunch of very usefule compiler directives:
https://github.com/onelivesleft/jai-cookbook/blob/master/guides/directives.jai

#add_context        Add a declaration to the context
#align              ?
#assert             compiler-time assert
#bake               currying
#bake_arguments     currying
#c_call             is a call to a c library?
#caller_location    use as default value of parameter to set it to source code location
#char               Character literal
#code               code block
#compiler           proc is internal to compiler
#complete           Ensure an if-case satement checks all values of the enum
#expand             macro
#file               path+filename of running executable
#filepath           path of the running executable
#foreign            proc is a foreign function
#foreign_library    specify file for foreign functions
#foreign_system_library specify system file for foreign functions
#if                 compile-time if
#import             Import a module
#insert             insert string
#insert_internal    insert string internal to proc?
#intrinsic          proc is an intrinsic
#load               Load source code, as if it were placed right here (very commonly used)
#modify             filter polymorphic parameter type
#module_parameters  ?
#must               Require a return value to be assigned to a variable
#no_abc             No array-bounds-check
#no_alias           ?
#no_padding         no padding in struct
#place              set location in struct of following members
#placeholder        placeholder identifier to be filled out at compile time
#program_export
#run                Run this code right now (compile time)
#run_and_insert     @deprecated
#runtime_support    proc comes from runtime support
#scope_export       Set the scope for future declarations to be accessible by code that imports this module
#scope_file         Set the scope for foture declarations to just this file
#scope_module       Set the scope for foture declarations to just this module
#specified          Declare intention of maintaining enum values compatibility over time
#string             String literal with delimiter
#symmetric          proc is symmetric
#through            case has fall-through
#type               Type literal, e.g. for function types
#type_info_none     struct does not keep runtime type info
#type_info_procedures_are_void_pointers

***** compiler control

https://github.com/onelivesleft/jai-cookbook/tree/master/compiling
        
- seems to mention you can create your equivalent of a make file and build file, in which *you can add all sorts of things to alter the way the compiler runs the program*
  - and *this seems to make the language far more modular, initially minimal*
  - the build imports a meta-program from the modules folder..
- some examples..
- there's an example where there's a file/piece of code to make a windows executable run without spawning the command prompt
  - that's how *explicit* it is! nothing is hidden
- another example has constructors of structs auto generated
- another example has a wrapper program run a jai program, allowing one to add various options to run it, a sort of *user-made compiler flags*
- generate_code_for_tags.jai seems to show an example of *running code at different phases of the compiler*..?: compiler_phase, type_checked, etc.
  - this seems different from macros..
  - TODO: it seems it allows you to "tag" a var, which is then..??
  - compiler_begin/end_intercept
- under "compiler_utils.jai" is a simple .toString() function
  - (but as it's not object-based, there's no need for it to be a method, just an ordinary function)
- another example checks for variable shadowing! and throws a warning or error
***** meta-programming

https://github.com/onelivesleft/jai-cookbook/tree/master/modules

compiler has a modules folder
or can use -meta flag to use it..?

it seems the person added an incomplete implementation of note on var declarations: 'var i := 0 @notes', which seems to work like compiler directives, wherein, based on the name of the note, it'll run a differe meta-program on it..??


**** MAYBE Beef
  - STATUS: up-to-date as of 2024. very consistent development. currently native desktop OSs, mobile is in early alpha
    - UPDATE 2025: Penny's Big Breakaway, by the people that made Sonic Mania, used Beef with a C++ core engine
  - loads of memory management-related features, thus *suitable for high-performance games and game-making*
    - **"Beef allows for safely mixing different optimization levels on a per-type or per-method level, allowing for performance-critical code to be executed at maximum speed without affecting debuggability of the rest of the application."**
      - a pretty killer feature
    - "Memory management in Beef is manual, and includes **first-class support for custom allocators.** Care has been taken to reduce the burden of manual memory management with language ergonomics and runtime safeties – **Beef can detect memory leaks in real-time, and offers guaranteed protection against use-after-free and double-deletion errors.** As with most safety features in Beef, these memory safeties can be turned off in release builds for maximum performance."
  - comes with it's own IDE
    - "The Beef IDE supports productivity features such as autocomplete, fixits, reformatting, refactoring tools, type inspection, runtime code compilation (hot code swapping), and a built-in profiler."
  - just one maker, extremely tiny game community, if any
    - co-founder of popcap games
  - Maddy (of Celeste) made an engine in it, but seems to have abandoned it..

**** MAYBE Nim
  - PERSONAL NOTE: among the most practical, general-use among newer langs.. but i don't see much reason over haxe, save manual memory management, which in case i'd rather just write C for..
  - **"aims for efficiency, then expressiveness, then elegance, has metaprogramming too, in that order"**
    - this is a good way to categorize languages..
  - "It combines successful concepts from mature languages like Python, Ada and Modula."
    - **...but doesn't allow you to simply import python libs..**
    - brings the disgusting tab-delimited syntax of python to the world of systems langs :'(
  - "performance-oriented, allowing for many kinds of optimizations and implementations"
    - **memory management options: various garbage collectors (current default), reference-counting (future default), rust-like move semantics (most recent)**
      - this is it's defining feature
  - programming paradigm agnostic
  - transpiles to C
  - *writing macros don't require a different syntax*, so it's "elegant" as advertised
    - https://stackoverflow.com/questions/77803775/is-it-possible-to-globally-modify-the-ast-in-nim
      - **not as powerful as haxe's macros?**
      - "In Haxe, it's possible to iterate through and modify a project's entire AST prior to typing using @:build macros. I was wondering if it was possible to do something similar with Nim?"
        "Nim has a rich and powerful macro API for AST reading and modification, but is this possible to do outside of explicit macro calls to the content held in other declarations? Could I, say for example, rewrite a specific function at compile-time prior to the generation of the output?"
      - "No. *macros only have access to their corresponding subtree of the AST.*"
    - https://nim-by-example.github.io/macros/
      - **i wouldn't call these macros _elagant_ by any means... nor even the language**
        - this is indeed hideous..
    - **many features in the language are implemented using macros, therefore keeping the core quite small**
    - https://community.haxe.org/t/macros-when-and-why-is-if-macro-if-macro-required/2530/6
      - "All that aside, Nim and Rust macros don’t quite compare with Haxe’s, where it’s not uncommon to use 3rd party libs, networking, file system, databases, the operating system (invoking other CLI tools) and what not. It’s also common to call into the compiler to perform typing and what not (which as far as Google tells me is not possible in Nim or Rust). Properly separating code is therefore vital in the long run."
  - pop contemporary features: generics, closure, functional paradigm features, type inference, macro, statement as expression, etc.
  - https://community.haxe.org/t/main-differences-between-haxe-and-nim/1120/4
    - template-based macros
    - Nim generic is template based, which gives you more power
      - Nim generics support static[T] which is nice
    - no object-oriented paradigm, just use macros
    - no built-in pattern-matching, use macros/libs
    - object variants to haxe's adt
    - Haxe has a static analyzer and very good inliner. Nim relies on the backend compiler to do the job until now.
  - https://forum.nim-lang.org/t/1880#11674
    - *nim's focus is C target*, Haxe started with javascript target (dynamic), and brings a little baggage there..
    - *nim's macros are better implemented than haxe*
  - **syntax is actually expressive**, though it seems like tab-delimited unexpressive python on the surface, it has many ways to do one thing, possibly even more so that Crystal
    
**** IUNNO D
  - *TODO: seems really cool, not sure why it didn't catch on..??*
  - multi-paradigm
  - parallelism!
  - **incredible memory management: garbage collector but also C-style manual memory management (malloc and free)!!** or custom allocator schemes (i.e. on stack with fallback, RAII style allocation, reference counting, shared reference counting), also some fine control of the garbage collector (add/exclude memory ranges!!)
    - this is the best soultion i've seen..!

**** NO Rust
  - PROBLEM: requires a very deliberate mindset to write in, high cognitive load, lots of features, most of which are actually used frequently
    - Jon Blow's take:
      - https://www.youtube.com/watch?v=4t1K66dMhWk&t=3635s
      - on the ownership model: **"compile-time enforced permissions model that determines what you can and can't do with various pieces of memory", and thus by nature is overly restrictive. There are somethings that you could do that are correct that it won't let you do, because it can't prove they're correct... you have to fight the borrow checker, and it's very frustrating, but it's good because it pushes you into patterns that are better anyway**
      - https://github.com/Jai-Community/Jai-Community-Library/wiki/Overview
        - "Rust is a "big idea" language that uses static compile-time formal verification where the borrow checker attempts to prevent all memory-related bugs. While this can be useful in some fields of software, the borrow checker seriously conflicts with Jai arena allocation, context-based allocation and temporary storage schemes. Arena allocation, as done in many games, is terrible for the borrow checker. Jai does not have a built in borrow checker, however, the metaprogramming features allow one to create arbitrary code inspection and analysis tools appropriate for whatever problem one will personally face."
        - "In order to read and write to global variables, Rust requires you to wrap that code in an unsafe block. Video games often use truckloads of global variables in gameplay code, and regularly access global state in higher levels of the program. Because there is tons of video game gameplay code that regularly accesses global state, if a video game was programmed in Rust, it will end up with everything wrapped in an unsafe block. This essentially throws out all of the nice borrow checking safety features of Rust, and therefore makes Rust inappropriate for game development."

  - *perfect for embedded devices, where memory-safety (not crashing) is most valuable*
    - think: medical devices, military, cars, planes, etc.
  - "Rust is a kitchen-sink language that can do anything well if you're willing to put in the time to learn how to control it."
  - **like C++ but safe--no run-time errors(!!), under the restriction of using a very specific memory management system**, wherein you still have fine control of memory but it's guaranteed to be safe. you *must* learn and use this system to handle the memory yourself (just as you must learn Obj-C's reference counting, or C++'s pointers and smart pointers).
    - makes it a really good choice for robust systems: OS (used in linux kernal), embedded systems, etc.
    - all of that of course comes with the cost of a slower development time (or at least having to be wayyy more careful)
    - mutability: https://doc.rust-lang.org/std/keyword.mut.html, https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/mutability.html
    - still have the option for "unsafe rust" to do the standard C/C++ style raw memory management stuff
    - https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html
  - performance-oriented, allowing for many kinds of optimizations and implementations
  - **incredible documentation design**: a web book, docs, crates (it's package manager), all look *stunning*. Languages with smaller communities will have a tough time matching that!
    - see: https://doc.rust-lang.org/std/index.html, 
    - the book: https://doc.rust-lang.org/book/
  - **a great and excited open-source community**
    - probably the most powerful open-source community among all languages.. for C++, you'd just stick to game-oriented communities
    - despite it's sheer complexity, it's very much loved
  - **has every feature you'd ever want**
    - pop contemporary features: generics, closure, functional features, type inference, a good type system, macro, statement as expression…  
    - **people seem to really quite like this one**,
      - people have went crazy re-writing C++ libs for rust..
      - **there are 100s of rust engines, but no games**, which shows what sort of people use it: **over-engineers**
        - in contrast, C++ has a more solid industrial feeling to it
  - "**Where Go shines in simplicity, Rust shines in expressiveness. Rust's type system is far ahead of Go's, which allows for a workflow where you model your data almost before the implementation details. Code is often more concise. The dark side of this is that if you're not disciplined, concise can end up obfuscated.** Even Python and JS are like this; consider list comprehensions embedded in more list comprehensions vs iterative loops. Sometimes I find myself doing things the Go way in Rust, because it's more readable. This is an option in Rust, but not the other way around."
  - not the prettiest syntax.. but **i quite like it [syntax], after seeing some Ocaml**
    - also like Ocaml, and haxe, has powerful pattern matching, a strong type system, and emphasizes non-mutable data first which lends itself well to funcitonal paradigm
  - people have went crazy re-writing everything from the ground up in rust
  - Bevy game engine, also see "awesome gamdev rust" on github
  - https://discord.com/blog/why-discord-is-switching-from-go-to-rust
    - this article tells of a single example of many where Discord replaced Rust because they were hitting the limit of Go's garbage collector, and to their surprise, beyond that problem, it outperformed go in every way anyway
  - explicit about memory references (&), otherwise the same!
  - terrible class::function syntax
  - Mozilla, and like all mozilla software, open-source (making it wayyy better than Swift)

**** C++
  - despite disliking it long ago, now it *seems to have added many features over time*, making a sort of hodge-podge frankenstein of a langauge. would just have to compare handling memory in this vs rust
  - **30 years old by the time rust v1.0 came out!!**
  - UPDATE: went through big changes from C++11 and on, updating every 3 years: the advent of "modern C++"
    - seems to have a good progression
    - https://www.incredibuild.com/blog/modern-c-the-evolution-of-c
    - mostly C++11:
      - 'auto' (var), range-based loops and "structured binding", and lambda make it feel more like a modern dynamic language, but with better implementations
        - also had type inference far before C#/java ~2011 vs ~2017/2018! return type inference too!
      - variadic template
      - decided on a memory model leading to standard multi-threading and concurrency
    - C++17
      - jon blow uses this one..
    - C++20
      - modules!!!
        - no more #include!!
      - coroutines (another way of concurrency?), maybe just had threads before?
      - concepts
      - ranges
  - **most game engines are written in C++**
    - this is pretty telling..
  - manual memory management via pointers 'n references, "raw" and "smart" pointers 'n the const key-word
    - and therefore pass function arguments by value or pointer or reference or smart pointer too
    - smart pointers (3 kinds) that generally delete themselves once the last reference falls out of scope, in addition to raw pointers
      - you must learn these..
  - adds object-oriented design features (classes) to C
    - (though now gathered some functional paradigm stuff..)
    - also adds the idea of allocating stuff during constructor and de-allocating during deconstructor, and smart pointers handled by objects
  - header files are also annoying
  - adds "standard library" including strings to C (before they were an array of "char"s!)
  - adds generics ("templates"), enums, and other now basic features..
  - loved/hated, mostly hated early on, now quite tolerable, though i wouldn't say pleasant..
  - also a problem of multiple compilers, each of which only work for certain version or certain features?? (gcc, clang (via llvm))
  - "What C++ does better than any other language I'm aware of is allow you to express yourself, consequences be damned. It's like a gun - in the hands of someone well-versed in its use and with a deliberate effort to be safe, it can be properly wielded to great effect. Give it to an untrained or sloppy developer, and there will be plenty of opportunity for incompetence and collateral damage to play out."





*** C and its replacements / manual memory-management / native compilation
  - more of a data-oriented procedural paradigm, usually simpler in feature-set (though zig is quite complex now..)
**** YES (Jai)
  - see [[jai]]

**** Zig
  - *had a rough dev history full of rehauls*
  - not the best tool-chain, though some parts better than odin, and better cross-platform support
  - a C replacement
  - "faster than C", advanced CPU features, SIMD exposed
  - explicit about using the allocator to allocate the heap...
  - **possibly the best C interop i've ever seen: just @CImport and @CInclude("SDL.h"), then C.SDL.DestroyWindow(...)**
  - can use zig as a drop-in replacement C/C++ compiler
    - pretty neat for when you don't want that crap 
  - **actually has meta-programming**
    - thus, simple is not it's aim, unlike odin
  - from the site:
   - "There is no hidden control flow, no hidden memory allocations, no preprocessor, and no macros."
   - page 1:
    - No hidden control flow
    - No hidden allocations
    - First-class support for no standard library
    - A Portable Language for Libraries
    - A Package Manager and Build System for Existing Projects
    - Simplicity
    - Tooling
   - page 2:
    - Small, simple language
    - Performance and Safety: Choose Two
    - Zig competes with C instead of depending on it
    - Order independent top level declarations
    - Optional type instead of null pointers
    - Manual memory management
      - i prefer the simplicity of this over Rust
    - A fresh take on error handling
    - Stack traces on all targets
    - Generic data structures and functions
    - Compile-time reflection and compile-time code execution
    - Integration with C libraries without FFI/bindings
    - Zig is also a C compiler
    - Export functions, variables, and types for C code to depend on
    - **Cross-compiling is a first-class use case**
    - Zig ships with libc
    - Zig Build System
    - **Concurrency via Async Functions**
      - i don't think haxe has this
    - Wide range of targets supported
    - Friendly toward package maintainers
  - great simple web-site 'n documentation
  - this looks great! no hidden bullshit. optional std lib. everything about it makes sense to me! :)
    - whereas Haxe and Rust use macros and "special" solutions in their standard library or hidden in their compiler, Zig doesnt take any shortcuts, doing everything the proper way
  - **one line C interop**
    - // build with `zig build-exe cimport.zig -lc -lraylib`
    - const ray = @cImport({ @cInclude("raylib.h"); });

**** Odin
  - *more stable dev history than zig*
  - not the best tool-chain, especially debugger and auto-complete
  - from the hand-made network
  - like C, cute, with a strong belief that *data and procedures (functions) should be seperate, and that behaviors (class's functions/methods?) shouldn't even exist!*
    - very rad :o
  - parses emoticons!!
  - **comes with game libs!!**
    - all major graphics api (vulkan, metal, etc.) are officially supported
    - official bindings for: SDL2, raylib, etc.
    - **but doesn't come with a package manager**, again, very opinionated..
  - influenced by Go

**** V
  - C-like
  - gc optional

**** C
 - **a very simple "low-level" language used by most electronic devices**, "Currently it is pragmatically true that C is the most versatile and portable language. Any language that does not have the ability to interact with C code risks obscurity."
 - *closest to how hardware works*
 - frameworks: RayLib, not really the best for making frameworks, as it's lacking a lot of features; it'll more or less end up like RayLib: a ton of functions included in the top-level namespace, as there is no concept of namespace!
 - manual memory management via "raw" pointers and the const key-word
 - "Many people would tell you that the biggest burden when programming in C is *worrying about buffer overflows and accidentally dereferencing null pointers*. However, I think that what can make programming in C tedious on a day-to-day basis is that the **C language doesn’t provide many tools to manage complexity. There are no modules or namespaces**, so you have to prefix identifiers to avoid name collisions. *You have to worry about the order of your declarations and adding prototypes in the right places. A lot of information is duplicated in various header files. Constants and macros use the C preprocessor, which can lead to strange bugs. There are no classes or interface types to cleanly encapsulate functionality, and there are no standard container types. We implemented our own dynamic array type, which we had to manipulate through awkward preprocessor macros with no type checking."*
 - **_not_ object-oriented**
   - and interestingly, it forces you to write in a simple, top-to-bottom way, making programs, even if it's just a giant single file, rather easy to read, as opposed to being forced to create a ton of "objects", most of which don't make sense. With less freedom and more constraint, you are able to do what is needed without thinking about how to do it. There's a whole philosophy about this vocalized by Casey Muratori and his hand-made network. And indeed, it makes C libraries much easier to follow along than C++ libraries:
 - no string class!, "C-strings" are just arrays of chars
 - has header files, which is annoying
     - TODO: but it seems nowadays people just write everything in the header file..!?
 - Raylib is quite beautiful: simple, straight-forward, because there's really no other way to do it
 - OpenFrameworks also has Raylib's beauty (not sure if it was C or C++ tho..)
 - now, i'm not sure if i'd want to write a game in that style, *i loved FlashPunk!, i love my objects! ;(*, but i sorta see why straight up simple C results in very good code, *dividing data from functions, ending up to be more modular, more re-usable, and most importantly, easy to follow and optimized*


** assemblies
for the sake of completeness, lol
  - though, actually worth thinking about..

assembly languages
  - varies by hardware? ISA? CISC/RISC?
  - for hardcore optimization


** functional langs

or at least funcitonal-paradigm-focused
  - for example: immutable values by default

*for games, it's useless*. The *functional paradigm incurs huge performance costs for the benefit of abstraction/easy-maintanence for the programmer*.In addition, *none are cross-platform, as none transpile to C nor llvm-ir, as most rely on a VM to handle concurrency*
  - it almost seems as if these languages, or paradigm, goes against the way machines think..

*it seems to me that the functional paradigm's biggest reason for existence is to solve the concurrency/parallelism problem.* Games can require concurrency, but it should'nt be solved/handled at the language level, nor forced upon you. You must choose an implementation/lib and do the work for the component that you want to make concurrent.



Elixir is a special use case, as it's perfect for concurrency for web.
  - https://www.reddit.com/r/gamedev/comments/7adg21/comment/dp9fv44/
  
"Elixir is a functional language; its data structures are immutable. *This is great for reasoning about code and supporting the massive concurrency you enjoy when you write Elixir. The double-edged sword of immutable data structures is that mutations are modeled by taking an existing data structure and an operation and creating a brand new data structure that is the result of applying that operation to the existing data structure."*
    - this problem applies to all purely functional languages
    

the current state of things:
https://www.reddit.com/r/ocaml/comments/m634t8/thoughts_onexperiences_with_f/
  - "The tiny community and obscurity of OCaml made things difficult, and it was just hard to justify F# when it's future isn't as promising as rust or typescript or even elm or elixir. These days I use the ever-advancing typescript systems to emulate what I got from OCaml while taking advantage of the much larger platform, community, and ecosystem. When something is lacking, the TS system is advanced enough to (mostly) allow you to code it in. It's got its faults, but I was able to create a variant types library I'm very happy with so it's good enough for now."

*** specialized use cases
note: the following languages have very different *specialized use cases* due to their special features, which affect their communities:

Haskell
  - purely functional
    - and thus the most restrictive
  - math, language (nlp?)
Elixir
  - server-side parallelism
  - https://www.reddit.com/r/elixir/comments/ao3dp6/usecases_for_elixir/
F#
  - functional-focused yet multi-paradigm for .NET/CLI, general-use
OCaml
  - compilers/AST work, academics, general-use

*** Haskell
  - *the* functional lang
  - *magical feeling to write*
    - many people really like/admire this one
    - *TODO: try it!*
      - though, maybe elixir is enough?..
  - *purely functional*, meaning, there is *no simple way to mutate data* (vars and functions)
    - **this makes it very limiting in practice**
    - must use "monads" to change the state
    - but because it is purely functional, it can do things that no other non-purely-functional languages can do
  - web-site home-page is awesome (todo: make Haxe's home-page like this!)
    - intro from a great little on-line book that was listed on the main site
      - http://learnyouahaskell.com/introduction#so-whats-haskell
  - *native compilation*
  - statically typed
    - very much so. no type casting. int is nothing like a float.
  - lazy. "That means that unless specifically told otherwise, Haskell won't execute functions and calculate things until it's really forced to show you a result"
  - very succint syntax, **no parenthesis!**
  - *"all side effects are completely controlled and you can very easily identify functions with side effects"* - CRobes
  - "there are ways of interacting with the real world, such as printing to a console, but this is done in an absolutely controlled environment" - CRobes
    - soo, *i'm guessing limited to formal sciences: math, languages, etc..??*
  - i dig the arrows: input -> output, content <- readFile
  - purescript
    - subset of haskell that transpiles to js

*** YES OCaml
  - *conclusion: overall a solid garbage-collected langauge, just very slow in development. it's only con really isn't the langauge itself, it's that it's community is really small, mostly academics*, and as haxe attracted all the game devs, there just isn't a need for it for me if i use haxe already..*
    - https://www.reddit.com/r/ocaml/comments/1iw4v7z/why_is_ocaml_not_popular/
      - TODO: a TON of reasons why not here..
      - tooling incredibly slow to develop
        - no IDE support until lsp (save emacs)
          - https://discuss.ocaml.org/t/a-next-generation-ide-for-ocaml/15350/10
            - TODO: super intersitnf!
        - no build system until 2018
        - no concurrency / GIL
          - notably, elixir solved this by re-using BEAM
        - lackluster performance
    - NOTE: *native compilation means no iOS/Android/consoles :/*
  - UPDATE: generational garbage collector
    - "The OCaml 5.0.0 release in 2022 is a complete rewrite of the language runtime, **removing the global GC lock and adding effect handlers via delimited continuations. These changes enable support for shared-memory parallelism and color-blind concurrency**, respectively."
      - https://discuss.ocaml.org/t/multicore-ocaml-vs-thread/5838/12
  - *"OCaml unifies functional, imperative, and object-oriented programming under an ML-like type system."*
    - making it among the most practical functional langs
    - in the functional to object-oriented/procedural sprectrum, OCaml is closer to functional, whereas Haxe is closer to object-oriented/procedural, giving it a very good profile and balance, making it far more practical than more functional languages
    - the "O" stands for object-oriented
  - some benefits of it's functional side:
    - *immutable vars/data-structures by default (final keyword in other langs), good compiler warnings against mutable things*
    - *pattern matching feature ensures all control paths are complete via compiler warnings*, and *a great type system (strong yet inferred) that also helps with compiler warnings*
      - the switch/pattern matching is amazing, as it allows function arguments to magically work with it automatically (sorta like the opposite of how all functions return stuff)
      - this makes it particularly good for writing compilers 'n parsers
        - used to write many compilers including: haxe, rust (the inital one), web assembly, hack, and a lot more in academia
  - has reference types, "a mutable container for a value"
    - for those two(?) reasons and more, it's not purely functional
  - based on the functional language ML (Meta Language)
    - considered to have **the best type system**
  - **surprisingly nice, succint syntax** for an old language with many pop syntax stuff being optional, like allowing one to use white-space instead
  - ML either invented or was the first major use of static type with type-inferring compiler, and thus all dialects benefit it
  - http://roscidus.com/blog/blog/2014/02/13/ocaml-what-you-gain/
    - polymorphic variants, ADTs, cycle-free dependencies, immutable data structures...
  - https://caml.inria.fr/pub/docs/oreilly-book/html/index.html
  - https://www.reddit.com/r/ocaml/comments/12no1vq/what_makes_ocaml_good_for_programming_language/
    - having pattern matching and immutability by default makes it easier to write software that operates on tree structures (ASTs, some IRs, etc). you can just write a particular compiler pass as a function that takes in a tree and outputs a new tree.
      ...
      compared to writing it in another language like Java or CPP, there's much less boilerplate, no need to deal with things like visitor pattern, copying nodes around and worrying about mutation, etc.
    - What hasn't been said in other comments is its rich type system. If you want to represent an AST of your language in a type-safe way, that is, in such a way to write the eval function without resorting to errors or exceptions, you have the right tool for that in OCaml: Generalized Algebraic Data Types (GADTs). Haskell also has official support for GADTs via a compiler extension. (...By the way, if the object language is more expressive than the metalanguage, this beautiful trick stops working. One example is dependent types, which are irrepresentable as an OCaml data type.)
  - SML's (standard ML) module system, with some differences
    - signatures
      - interfaces for modules
    - "first-class" modules > functors
      - SML's modules that take modules as arguments
      - OCaml's modules can be treated as values, returned, and stored in data structures!
    - hierarchal
      - can nest modules
    - more sophisticated module type system with more control over abstract types and existential types
    - equality types not guaranteed to preven run-time errors, unlike SML
    - modules can be compiled seperately
  - object system
    - this seperates it from other MLs
      - and even then, it's not often used, given its module system
    - object...end, to quickly create an object without defining it (anonymous)
    - structural typing (and sub-typing)
      - there are no declarations of types of objects, the structure of the objects (vars, functions) make them distinct
      - an object is a sub-type of another object if it siply provides all the methods and fields
  - haxe took it's game dev potential
    - https://www.reddit.com/r/ocaml/comments/nqq2om/what_should_i_learn/
  - quoted from Nicholas, who wrote haxe's compiler in OCaml:
    - "I have solid experience in writing optimized C code and I can say that Ocaml compiler is definitely faster when it comes to manipulating a lot of memory, thanks to its fast generational GC. And the Haxe compiler does a lot of map's.
      It's not that I'm that much an Ocaml fan: it has poor tooling and is not very known. But so far the benefits outweigh the drawbacks, not mentioning the time it would take to rewrite the whole compiler and the bugs that would get introduced while doing it."
      - https://groups.google.com/g/haxelang/c/X7hiMZtPo9U
  - **robustness from maturity and industrial use**, similar to erlang
  - reason and bucklescript transpile to javascript

*** (F#)
  - actually a much praised language..
  - see [[F#]]

*** BEAM VM / OTP langs
**** Gleam
  - a simple, statically-typed (type inference) lang for the BEAM VM
  - people seem to like this one..

**** rustler lib
  - *write rust NIF to be used by the stack*

**** YES Elixir
  - the clear star of the BEAM world
  - *the most practical functional language, thanks to it's special use case: the web*
  - "you must remember, that it looks like Ruby, but it’s not Ruby at all”, said the creator of the language
  - *"Elixir is a dynamic, functional language for building scalable and maintainable applications."* says it's home-page
    - probably not the most performance-oriented (unlike native compiled langs), it has much better concurrency, and the VM ensures it's much faster and safer/"fault-tolerant" than python/ruby!
  - although ruby-esque on the surface syntax, really *a replacement of Erlang*, of which it shares it's specific VM, thus allowing one to re-use Erlang's libraries
    - **very very easy to use erlang std libs too, just call the function, no need for import..!!**
  - but as opposed to Ruby's focus on object-oriented paradigm, it focuses more on Ruby's concise functional style: of creating very short easy-to-read simple often single-line functions
    - *it's functional focus makes it _perfect_ for web, where a billion threads are running little scripts (and where those billion threads must run side-by-side, never conflicting or sharing any bits of code with other threads)*. It's simply a much better solution than running simple GIL (gobally-locked) interpreters, providing all the advanced features a VM offers--a notably great one--, yet doesn't require full compilation to run it. *I can't think of a better use of bytecode/VM compilation!*
      - multi core (no GIL in Elixir)
  - *limited in use cases compared to more general languages*:
    - *absolutely not suitable for games or other procedural programs*
    - *not suitable for quick 'n simple scripting either,as you'd need to build a whole project and then need the VM to start-up to just to run it*:
      - "The one use case where Ruby still wins for me, though, is a little one-off script. Last time I had occasion to do that, I found you couldn't use any Elixir hex packages without generating a whole mix application. In ruby you could just globally install the gem and require it right into your script."
        - once you include another file, you basically have to create a project for it
  - "BEAM/EVM barely has any JIT happening at all, but it is still *very performant, however the language design combined with internal very low level async I/O allows the BEAM/EVM to outperform almost anything on I/O (like networking, say, for webhosting) while being safer than any just about any language at all."*
  - "However, *.NET Core has very little ability to debug production, you mostly have to rely on your logs or hook up a debugger that often stops-the-world. Compared to the BEAM/EVM that has introspection that would make any network or server admin just drool, but it is done in a different way than you would do it on .NET Core (mostly because debugging individual instruction is as you would on .NET is hell for a concurrently real-time system)."*
  - "Ruby has considerably more libraries and this is IMO at this point the only reason, other than being mandated or wanting to write ruby, that I would still use it over Elixir. The edge for everything else IMO goes to Elixir."
    - *concurrency, FP scope > OO scopes, liveview and live dashboard are 🔥🤘, contexts > models, response times are in the micro vs milli seconds, Phoenix saw webpacker for the 💩 it was and quick pivoted to a sane alternative in esbuild, benchmarking, testing & code analysis (credo, dialyzer), immutability, ex doc is insanely easier to use vs rdoc et al, runs on significantly fewer resources, OTP, hex is better than bundler, deployment (releases), cross platform (ruby has come a long way on windows from what it was but...), stable API vs the OCD of ruby/rails*
  - https://elixirforum.com/t/ruby-in-2023-can-and-should-elixir-replace-ruby-for-simple-scripting/58214
    - not a big enough program to make use of functional programming?
  - https://www.reddit.com/r/elixir/comments/1bo0a8o/why_did_you_switch_from_rails_to_phoenix/
  - https://thoughtbot.com/blog/is-elixir-a-scripting-language
     - running it via command line, it seems it would only work for a single module, and i'm not sure if you can simply import other modules using this method. Its possible to add a shebang and make it an executable
     - running the script via the 'mix' command seems the way to go, as that makes it a proper project allowing you to add modules, but then you'd need to create a new project, with a project folder, with it's own directory structure ' files, snd on top of that you'd need Elixer installed, and im not even sure if it can actually execute standalone without that command...
     - compiling it to a binary is similar, or even more complicated, than haxe: you need a seperate build file, put the script into a main function, compile it, and ensure you have Erlang's VM (BEAM)
  - https://news.ycombinator.com/item?id=14120398
    - elixer vs ruby?
    - "The one use case where Ruby still wins for me, though, is a little one-off script. Last time I had occasion to do that, I found you couldn't use any Elixir hex packages without generating a whole mix application. In ruby you could just globally install the gem and require it right into your script."
    - "I do not particularly like the usual global package installation model, though, because it means that you can only have a single version of a package available for your scripts to require. The best package management model for standalone scripts that I have seen is Groovy's: a script can include a special directive that downloads a specific version of a package just for that script. Any versions can be stored in the global (per-user) package cache so that you don't have to redownload them every time a script runs, but your import statements always give you strictly the version you asked for. This is the model I'd adopt for Elixir."




**** Erlang
  - not the prettiest syntax..
  - no use for me, as i can just use elixir to call it's libs
  - many messaging apps use it (What's App), along with messaging brokers (rabbitMQ)


** embedded scripting langs
  - NOTE: for actual embedded devices, you'd likely use rust for the core (for safety), and then *maybe* scripting lang
  - embeds in to C or rust
    - usually just a VM/byte-code interpreter, possibly JIT (luaJIT)
  - *these seem quite perfect for the use case of interactive programs, where you expect the user to alter the program, interactively*
  - i quite love these languages, as *they reduce the complexity of big programs (game-engines, studio tools) and the complexity of featureful un-managed-memory languages (C++, rust) and enable users to be able to focus on their domain-specific tasks: game design, app design, level/environment-making, animation, model-making, etc.*
  - maybe not worth the trade-off in games (hence why unreal engine stopped using it?), as mentioned by jon blow
    - *the main reason is to have a dynamic run-time to play/experiment/iterate with*
      - *but it sounds like you can do a lot of that in systems langs..*
        - incremental compilation?
        - some way to feed newly compiled code?
          - how does hot reload work in C++?
    - but unreal is developing another scripting language..??: verse
      - https://www.reddit.com/r/unrealengine/comments/1bzfnhb/verse_update_gdc_2024/
        - *concurrent garbage collection tied to objects*
          - okay, well... now that's special..
  - **why unreal engine dropped unrealscript**:
    - One of the key moments in Unreal Engine 4's development was, we had a series of debates about UnrealScript – the scripting language I'd built that we'd carried through three generations. And what we needed to do to make it competitive in the future. And we kept going through bigger and bigger feature lists of what we needed to do to upgrade it, and who could possibly do the work, and it was getting really, really unwieldy. And there was this massive meeting to try and sort it out, and try to cut things and decide what to keep, and plan and... **there was this point where I looked at that and said 'you know, everything you're proposing to add to UnrealScript is already in C++. Why don't we just kill UnrealScript and move to pure C++? You know, maximum performance and maximum debuggability. It gives us all these advantages.'**
  - apple doesn't support code execution
    - but then again, fuck apple

**** YES lua
  - PERSONAL NOTE: i think i first used this for Corona SDK for mobile (iOS, Android) game dev, and it was.. interesting.. *bare*, to the point you had to create your own language constructs useing meta-tables..
    - or maybe that was because i was still thinking object-oriented..
  - extremely simple (only perhaps second to lisp), **a long-lived classic**
  - *LuaJIT: the goat vm/compiler of all dynamic programming languages*, pretty much thanks to that one guy who made it
    - the main lua branch is quite a bit slower, and likely larger, by adding more features over time, making the LuaJIT branch a special, ultimate version
    - small size (VM)
    - *now compatible with lua 5.x*, yet still retaining it's speed
  - an all-powerful meta-data-structure: the table (and meta-tables!), from which you can implement any other data structure, making it a rather *modular language*
  - perfect for it's use case: embedded scripting
  - **feels a bit jank for bigger applications, like games**
  - **extremely simple, and boring..**--though nothing is as boring as go!
  

TODO: merge to lua
conclusion
so basically,

**for C/C++ embedding, it might be best to just use/learn C/C++, as running a VM/byte-code interpreter has a cost that's not worth it for embedded/performace applications such as games**

All of them have standard libraries, though, Lua with it's goal of minimal size, is the smallest, though in a charming in it's own way (see the very simple one-web-page manual). **Python's and Ruby's standard librares solid after decades of use, but def feels less standard compared to compiled languages, making breaking changes, which results in requiring the correct version just to run it..!**

Lua's like a primitive language that can build features that other languages have, but, it's not built-in, it's all dynamic-feeling, so overall it feels janky, imo. **For general scripting use, not embedding, I much prefer Ruby or Python over Lua, and Ruby over Python**. **Lua is made for embedding,** and it's great at that, whereas **Ruby and Python are made for scripting.**

So, in the end, it'll just be a preference between one's favorite general-purpose scripting langauge: ruby, python, powershell, or: just whatever general-purpose langauge one is most familar with at the time, as nowadays many compiled languages also have an interpreter, as the interpreter is *much* simpler to create than a compiler.


TODO: merge to lua
I also don’t have experience with Lua, but i at-least know it can easily embed into C and C++ (via “C api”). It’s also a tiny, extremely minimalistic language that performs extremely fast (for a scripting lang). “It's widely considered to be one of the fastest dynamic language implementations.” says the LuaJIT.org site. It’s like the most general—no, *meta*— language that’s i know of. Like, _“tables”_ are the main data structure, and with _tables_ you can _do anything_, including making most of the language features found in more complex languages, such as classes and inheritance! This shit is crazy! (i wonder if this makes it difficult for auto-complete to work though...) It’s also dynamically typed, which probably makes debugging a pain?

TODO: merge to lua
https://stackoverflow.com/questions/5327340/ruby-vs-lua-as-scripting-language-for-c
  - talks about the ease of moving data between languages (embedded): lua is the easiest, python is easy, ruby seems more difficult..
  - "I've looked at embedding Ruby into C/C++ before, and it seemed extremely difficult. There are a lot of challenges you'll face:
      Calling into Ruby from C/C++ requires 2 layers of functions to be written (one layer to call, and one to catch exceptions)
      Calling back into C/C++ from Ruby requires the normal SWIG-type work
      Moving data back and forth requires keeping careful track of allocations, since Ruby will want to garbage collect anything it can
      I'm sure that this can be done, but it seemed extremely difficult to me, only doable if you can jump into Ruby in a minimum of entry points."
  - "Luabind is really easy to use, there is no need for an external generator like SWIG, the doc is great. Compile times remain decent.
      Biggest problem I've seen : lua is mostly ... write-only. You don't really have classes, but only associative arrays with a bit of syntaxic sugar ( object['key'] can be written object.key ), so you easily end up adding a 'member' in an obscure function, completely forget about it, and have side effects later.
      For this reason, and this reason only, I'd prefer Python. "
    "Not directly related : None of these can be reliably used in a multithreaded environment (so this depends on the complexity of your server).
       N Python threads : the GIL ( Global Interpreter Lock ) is on your way. Each and every time you use a variable in a thread, it's locked, so it kinda ruins the point, except for long I/O operations and calls to C functions.
       lua has coroutines, but they aren't parallelisable.
       Ruby threads aren't really threads, but similar to Lua's coroutines
       Note that you can still create one environement for each thread, but they won't be able to communicate (except with a C++ machinery). This is especially easy in Lua."
   - "The newest versions of Ruby (1.9+) use real system level threads. It does still have a GIL though, which puts it on equal footing with Python."
   - "You may be interested in learning about Squirrel. I believe it was the scripting language used by Left 4 Dead 2. It is more advanced than lua (uses objects and classes) and is meant to easily be embedded in a C++ app, which sounds like exactly what you are looking for."
   - "One thing Lua has going for it is its ability to shuttle data between C++ (or C) and itself very easily. Essentially you're just pushing/popping data onto a stack in order to communicate between the two. Having multiple Lua environments up and running at the same time is quite simple as well (should you need that functionality). Although Lua is a garbage collected language, it's easy to prevent it from doing so on data that needs to stick around in your C++ code. Creating an extensible plugin system should be easy with Lua once you lay the groundwork. Swapping plugins (in this case, scripts) in and out at runtime is also pretty trivial (although this may be true for Ruby as well, I'm not familiar enough with it to know)."
     "One thing to think about is how much object-oriented stuff you want your scripts to be able to handle. Lua uses functions, tables, metatables, and prototypes to implement OO-like programming. Some people like it, some don't; personally I found it interesting to use, if a bit clunky at times. Not having used Ruby, I can't speak for it, but you may want to weigh your need for object/class support."
     "I think in your situation you should also consider how fast you want to get your project up and running. As you and others have noted, Ruby is hard to embed in C++, whereas Lua is not. Time is always precious and if you want to get something working ASAP, Lua is probably your best bet."



  TODO: merge to lua
  https://www.lua.org/manual/5.4/manual.html
  - the simple manual of Lua
  - the io, os, math classes are all super simple and nice
  - there's one page at the end that covers the syntax, which shows the power of simplicity, as you're not burdened with remember sytax crap
  - from the intro:
"Lua is a powerful, efficient, lightweight, embeddable scripting language. It supports procedural programming, object-oriented programming, functional programming, data-driven programming, and data description.

Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode with a register-based virtual machine, and has automatic memory management with a generational garbage collection, making it ideal for configuration, scripting, and rapid prototyping.

Lua is implemented as a library, written in clean C, the common subset of Standard C and C++. The Lua distribution includes a host program called lua, which uses the Lua library to offer a complete, standalone Lua interpreter, for interactive or batch use. Lua is intended to be used both as a powerful, lightweight, embeddable scripting language for any program that needs one, and as a powerful but lightweight and efficient stand-alone language.

As an extension language, Lua has no notion of a "main" program: it works embedded in a host client, called the embedding program or simply the host. (Frequently, this host is the stand-alone lua program.) The host program can invoke functions to execute a piece of Lua code, can write and read Lua variables, and can register C functions to be called by Lua code. Through the use of C functions, Lua can be augmented to cope with a wide range of different domains, thus creating customized programming languages sharing a syntactical framework."
**** YES (lisp, scheme)
  - see [[lisp]]
  - scheme (small versions)
    - *seems like the perfect embedded scripting language..*
    - many choices for C
    - steel (rust)
      - planned for helix
    - still slower than luaJIT..
**** YES mruby
  - PERSONAL: **magical. simple. concise. beautiful. powerful.** contains nearly all of the the magic of ruby, probably just discarding the terribly inefficient bits (and the bits that are hard to parse..). **possibly the most fun way to make games..**
    - *i mean, if it's not meant for a tiny embedded device, why not..? why not have everything you'd ever want??*
  - a light-weight interpreter for ruby intended to be embedded into C/C++
  - light-weight *_register-based_ VM*/byte-code interpreter: RiteVM
  - can be used to compile ruby (CRuby) code
    - though, the process is long..
  - **consistent development and releases alongside ruby**
    - https://github.com/mruby/mruby/blob/master/doc/mruby3.3.md
      - New Platform: Nintendo Wii (#6086)
        Improved Platform: Android (#6013)
        *Improved Platform: Dreamcast (#6130)*
        - LOL, sometimes i love japanese people..
    - though, still fixing quite a lot of bugs..
  - https://gist.github.com/amirrajan/2c42315ffef311600ecb2d8dcfe3ce88
    - an advertising example of mruby's powers over lua
      - named parameters
      - **function-chaining, function block definitions, lamba stuff**
        - Ruby’s enumerable methods allow for filtering, mapping, and sorting to be seperated out into different methods.
      - mixins
      - **meta-programming**
        - you can have your cake and eat it :)
    - https://github.com/mruby/mruby/blob/master/doc/guides/gc-arena-howto.md
      - some interesting bits by Matz on how the garbage collector works
    - *fibers*
      - *not sure what the point of wren is then..* i guess to be simple, maintainable..
    - <400KB memory
    - *"an order of magnitude slower than luaJIT"* - amir
    - *led by Matz!!*
****** dragonruby
- mruby fork that uses SDL, and LLVM, made for the dragonruby game toolkit (engine)
  - dynamic magicks: hot-reload, inspection of a running program (runtime), dynamic aleration of anything (objects: vars, functions), dynamic addition of aynthing
    - this is why it had to be done in ruby (or a lisp)..
- tries to keep up with mruby versions, though it may slightly differ in features as needed
- *dragonruby/lightstorm, "a minimalistic AOT ruby compiler" (2024)*
  - uses AST/MLIR/bytecode (EmitC dialect) -> C
  - seems similar to haxe's hashlink/c solution
  - pricing shows ~"pre-compile bytecode", or something like that..
****** mruby/C
- an even smaller branch of mruby..?
- target: one-chip micro-processors
- <40KB memory size
****** picoruby
- 256KB ROM, 128KB RAM, 32-bit
- only depends on glibc/newlib/newlib-nano
- raspberry pi pico as reference micro-controller board

**** IUNNO ring
  - TODO: need to look into more..
  - seems like a pretty awesome *flexible* language: **keywords can be changed**, **doesn’t enforce a coding style on you** (doesn’t use neither tab nor braces!), something like Lua and Wren (20k loc interpreter ‘n VM), all containers are a “list”, already has bindings for RayLib, SDL, etc.

**** NO wren
  - PERSONAL NOTE: compared to the dynamic-ness of lua and mruby, this is less powerful, less expressive, less magical. *it feels like writing in a boring statically-typed lang, but without any of it's advanced features.* I personally would rather choose either a more powerful embedded scripting lang (mruby), the fastest embedded scripting lang (lua), or a more powerful statically-typed language (jai, haxe) instead. It's just.. *boring*.
  - “Think Smalltalk in a Lua-sized package with a dash of Erlang and wrapped up in a familiar, modern syntax.” is it's slogan, looks like a really cute alternative to Lua, in case Lua is too meta-level / minimal for you and you feel safer hiding behind classes ‘n object-oriented paradigms
    - no, nothing like smalltalk, not sure about erlang either (certainly no BEAM..)
  - modern sytnax with object-oriented-style classes
    - though, the classes here are fare more flexible, as the language is much simpler
  - **go-like concurrency via "fibers"**
    - interesting.. but maybe lua added this too..
      - in fact, all nearly all langs added this feature..
  - meant far embedding to C so doesn't come with a std lib (lua does)
    - can add libuv (a contemporary cross-platform std C lib) to it, as in the wren cli bundle
  - not luaJIT fast, not far from luaJIT -joff (luaJIT impl with JIT off) tho, equal or faster than the current standard implementation of Lua, and nowadays (2024) only marginally quicker than the more complex standard ruby and python C interpreters (non-JIT interpreters are all about the same)
    - though, **it's aim is to be simple: a highly-readable ~7000+ lines of code vm** as opposed to javascript's v8 is 2,300,000 lines of code (as of 2024), more than 300x larger!
      - https://github.com/wren-lang/wren/blob/main/src/vm/wren_vm.c
        - 2000 loc
      - https://github.com/lua/lua/blob/master/lua.c
        - 700 loc
  - **made with <3 by rubyx01 (of luxe game engine), though started by Bob/munificent** of game design patterns / crafting interpreters fame (a similar language is used in his books)
  
**** NO squirrel
  - was used long ago by a few game companies as a general scripting lang for games that even ran on consoles

  
  
** cool ideas!
*** concatenative langs
  - "*concatenative* or *applicative*. In an applicative language, things are evaluated by applying functions to arguments. This includes almost all programming languages in wide use, such as C, Python, ML, Haskell, and Java. In a concatenative programming language, things are evaluated by composing several functions which all operate on a single piece of data, passed from function to function. This piece of data is usually in the form of a stack."
  - "So what makes *stack languages* different? The key concept here is that **there are multiple stacks**: all stack languages have a call stack to support recursion, but they also have a data stack (sometimes called an operand stack) to pass values between functions. The latter is what stack language programmers mean when they talk about "the" stack."
  - "Most languages in widespread use today are applicative languages: the central construct in the language is some form of function call, where a function is applied to a set of parameters, where each parameter is itself the result of a function call, the name of a variable, or a constant. **In stack languages, a function call is made by simply writing the name of the function; the parameters are implicit, and they have to already be on the stack when the call is made. The result of the function call (if any) is then left on the stack after the function returns, for the next function to consume, and so on.** Because functions are invoked simply by mentioning their name without any additional syntax, Forth and Factor refer to functions as "words", because in the syntax they really are just words."
    - https://www.concatenative.org/wiki/view/Concatenative%20language
    - TODO: super interesting.. then just have to make sure the data stack has what you want in it.. *it sounds closer to data-oriented porgramming, where there's data and functions, no correlation between the two, and thus making it far more modular, unlike object-oriented programming..*
    
**** forth
  - 1970, the original? concatenative, (data) stack-based language..?

**** factor
  - "The Factor programming language is a concatenative, stack-based programming language with high-level features including dynamic types, extensible syntax, macros, and garbage collection. On a practical side, Factor has a full-featured library, supports many different platforms, and has been extensively documented.
    The implementation is fully compiled for performance, while still supporting interactive development. Factor applications are portable between all common platforms. Factor can deploy stand-alone applications on all platforms. Full source code for the Factor project is available under a BSD license."

**** kitten
  - "statically typed, stack-based functional programming language designed to be simple and fast. It is a concatenative language, combining aspects of imperative and pure functional programming"
    - concatenative
      - compositional..?
  - *expression language"*
    - **no statements, only expressions that compute a result**
      - i think this is what prolog (lang) did.. you kind of describe the problem as opposed to solving it... very different, that's for sure..!
    - https://kittenlang.org/intro/#expressions-and-stack-based-evaluation
  - function name after arguments, which makes a neater alt to function chaining and method chaining (of object-oriented languages with lambda functions in its methods):
    - -3 abs neg show reverse say



*** pony
  - STATUS: abandoned, changed to a research project
  - **..maybe the most ambitious language project in goals..**
  - actor model for concurrency built-in
  - uses actor model for concurrency
    - TODO: how does this differ from elixir/erlang?
    - maybe the first langauge to do this, and therefore solve a really, really big problem
    - https://www.ponylang.io/discover/why-pony/#isolated-data-is-safe
    - "“reference capabilities”. Reference capabilities allow you to label different bits of data based on how that data can be shared. The Pony compiler will then verify that you are in fact correctly using the data based on the labels you provide. Reference capabilities combined with Pony’s actor model of concurrency makes for a powerful pairing."
    - the problem with concurrency 101
      - "The problem with concurrency is shared mutable data. If two different threads have access to the same piece of data then they might try to update it at the same time. At best this can lead to those two threads having different versions of the data. At worst the updates can interact badly resulting in the data being overwritten with garbage. The standard way to avoid these problems is to use locks to prevent data updates from happening at the same time. This causes big performance hits and is very difficult to get right, so it causes lots of bugs."

        Any data that is immutable (i.e. it cannot be changed) is safe to use concurrently. Since it is immutable it is never updated and it’s the updates that cause concurrency problems.

        If a block of data has only one reference to it then we call it isolated. Since there is only one reference to it, isolated data cannot be shared by multiple threads, so there are no concurrency problems. Isolated data can be passed between multiple threads. As long as only one of them has a reference to it at a time then the data is still safe from concurrency problems.

        The code within a single actor is never run concurrently. This means that, within a single actor, data updates cannot cause problems. It’s only when we want to share data between actors that we have problems.

        By sharing only immutable data and exchanging only isolated data we can have safe concurrent programs without locks. The problem is that it’s very difficult to do that correctly. If you accidentally hang on to a reference to some isolated data you’ve handed over or change something you’ve shared as immutable then everything goes wrong. What you need is for the compiler to force you to live up to your promises. Pony reference capabilities allow the compiler to do just that."

*** streem
  - "a stream based concurrent scripting language. It is based on a programming model similar to the shell, with influences from Ruby, Erlang, and other functional programming languages."
  - https://github.com/matz/streem
    - *by Matz*, the maker of Ruby
  - seems abandonded, but still a rad idea! :D

*** luna/enso
  - https://github.com/enso-org/enso
    - "visual and textual functional programming"

*** inform 7
  - english/nautral langauge, used to make interactive fiction 'n games



** domain-specific langs (DSLs)
for the sake of completeness?

https://en.m.wikipedia.org/wiki/Domain-specific_language
  - a language created for a specific use: a specific domain: a DSL
    - html, xml & json, yaml & toml, postscript, latex?, gml (game maker language), UnityScript, GDScript, and so on

*** shell scripting langs

TODO: see/merge? [cli-shells] for shell scripting langs

TODO: windows computers would still require a linux vm to run it..? and linux computers would need to install powershell (much simpler..)


although specialized, still useful, perhaps more accurately, unavoidable, due to legacy reasons, however:

*given an actual, complete language and a solid ide, i feel infinitely more able to glue together shell crap (pipes, processes, whatever), and just solve problems. With bash, i feel i'm basically confined to piping streams of text between various existing linux cli programs, of which lack any sense of consistency, particularly cli prog flags. The only sane way to solve problems with bash/linux is to rely on ai (that one ai shell..). And if i'm going to use ai, it's probably even easier to just generate precisely what i need in a proper language, which'll be more maintainable, as it's all in a readable language*

also, *ruby is just a fucking great scripting langauge*. it feels it was made to directly replace bash, even including a few bash syntax ideas (ew)

also, *it's easier to install ruby on all desktops oses* than to install a linux vm on windows.. though installing powershell on linux should be easy..
  - TODO: surely there's a bash shell for windows..?? ..but then you'd be missing the linux cli programs..
    - yeah, linux cli is fucking garbage, lmaoo

however, *running a basic series of commands does indeed work fine and quick with dash*.. no need for a big scripting language interpreter.. *especially if it's being run a billion times..*


TODO merge:
https://stackoverflow.com/questions/2342894/why-and-when-to-use-the-shell-instead-of-ruby

The shell's programming language is awful for all but one thing.

Pipelines.

The shell's programming language for pipelines totally rocks.

The |, & and ; operators, plus () and ``` form a tidy little language for describing pipelines.

a & b is concurrent

a ; b is sequential

a | b is a pipeline where a feeds b

That part of shell programming rocks.

Think of ( a & b & c ) | tee capture | analysis as the kind of thing that's hard to express in Python (or Ruby). You can do much of this with iterpipes, but not quite all of it.

Much of the rest you can live without, and use Python (or Ruby) and you'll be happier and more productive.

The biggest thing to watch out for is anything involving expr at the shell level. As soon as you start trying to do "calculations", you've crossed out of the shell's sweet spot and you should stop programming in the shell and rethink what you're doing.

Share
Improve this answer
Follow
edited Feb 26, 2010 at 16:


**** IDEA ruby interpolation within a shell

also see [[streem]]

you might just be able to use programming languages within a shell!..
  - https://github.com/tombenner/ru
  - in might also be included in pry: https://github.com/pry/pry
    - "We can also interpolate Ruby code into the shell. In the example below we use the shell command cat on a random file from the current directory and count the number of lines in that file with wc:"
      - .cat #{Dir['*.*'].sample} | wc -l
        44



  
**** post-windows powershell update

UPDATE:
powershell feels light-years ahead of unix / linux shell stuff
and i love ruby
and haxe
these three are all i'd ever need
(and even then, i'd likely reach for ruby over powershell..)
trash the rest (fish, bash, all of it)
  - though, if i ever have to use linux, fish is the way to go.. as it maintains the old unix way of streaming text via output/input

powershell is what i was looking for. You get the .net framework--if you need it--, and a very neat and organized shell-scripting language. It's refreshing, clear, easy-to-understand, and infinitely more organized compared to linux shell scripts, which feels like a bunch of glue of open-source crap. Finally, a solid general-purpose lang made for shells! Yeah, it's verbose, it's got all that verbose microsoft .net ilk, but it just feels light-years better than the old linux stuff. Instead of glueing small linux apps together (sed/awk, head, tail, cat, etc.), you just have a very simple standard library (get-content -first/-last 10 vs head/tail) with a great standard help feature. If ever there was a place that needed standards, it was shell-scripting!
  - i take that bit about the .net framework back, it's huge!!... it should not belong in a shell scripting lang!! i feel it assumes you are working within microsoft..

**** some notes extracted from to-scripting-languages:

TODO: i wonder if the speed of these simple langs are lightning fast though.. in that case, maybe a totally fine reason..!

from [cli-shells]

shell scripting vs general scripting languages:

basically, my conclusion was that the shell scripting languages are extremely limited, simple, domain-specific, and in the end, i think i imagine i will end up reaching out for a more general-purpose scripting language (ruby) for both the more extensive standard library and the pop libraries in its package manager.

in addition, the bash-like shells (all except fish) have a bit of cryptic syntax, especially using the $. It's not bad however, considering how tiny the language is, but using $ for vars is hella old. Also there's a problem with escaping quotes ("$var" vs $var vs one more way...). Crap like that just sucks. But now that there's ai, maybe it doesn't matter anymore.. or maybe it does, as someone still has to read it..
  - TODO: they should just transpile to bash..

Overall, the shell scripting langauges (bash/zsh, fish, etc.) are great tools for simple scripting: stringing together commands (via the pipe operator: |), managing processes (running commands externally, in a sub-shell, or switching processes), taking in arguments from the command line ($1, $2, $argsv), and so on (though, so are general scripting langs..). But once you want to do a bit more, you'd have to know Linux CLI programs/tools really well to do what you want, whereas, with a more general scripting langauge, you can just do what you want with the normal ways of programming: with an actual type system (in shell scripting langs, vars are strings), with a solid std lib, with helpful external libs.

Ah, that leads to another problem: because all vars are strings, they are a pain to do conditional control flow upon. In fish, for example, you'd have to use a program(?) called test with various flags. So instead of a boolean it'd be:
`if test -z condition` or `if set -q condition`
...or something like that. Definitely not ideal. Though probably worse in bash..


**** Bash (+zsh)
an interpreted scripting language for use on Unix and Unix-like operating systems and environments.

**** Powershell
a scripting language originally for use on Microsoft Windows but nowadays also installable on macOS and Linux.


*** web

see [web-app-frameworks]

bascially langs that transpile to javascript..



javascript
  - see entry under [scripting langs]
*typescript*
  - note: this is not simply a type-checker
  - typed (java)script
  - people are very thankful of this..
  - made by Microsoft
coffeescript
  - rip? lead to typescript?
purescript
  - purely-functional
  - *subset of haskell*
*elm*
  - purely-functional, like a functional REBOL, which is as amazing as it sounds
  - very simple model, update, view structure
  - *lovely person that spent 10 years on it and gave a wonderful talk about "the economics of programming languages"*
    - performed *a charming little presentation using mario :D*

note: many other languages have js transpilers
great ones
  - haxe, dart, f# (clr?)

good ones?
  - ruby (opal)





*** other

sed and awk
  - two text processing languages used mainly in Unix-like environments.





  
** old / history

*** experimental, abandoned
**** skip
  - https://github.com/skiplang/skip
    - "Skip's main new language feature is its precise tracking of side effects, including both mutability of values as well as distinguishing between non-deterministic data sources and those that can provide reactive invalidations (telling Skip when data has changed). When Skip's type system can prove the absence of side effects at a given function boundary developers can opt-in to safely memoizing that computation, with the runtime ensuring that previously cached values are invalidated when underlying data changes."
    - "Skip supports two complementary forms of concurrent programming, both of which avoid the usual thread safety issues thanks to Skip's tracking of side effects. First, Skip supports ergonomic asynchronous computation with async/await syntax. Thanks to Skip's tracking of side effects, asynchronous computations cannot refer to mutable state and are therefore safe to execute in parallel (this means that independent async continuations can continue in parallel). Second, Skip has APIs for direct parallel computation, again using its tracking of side effects to prevent thread safety issues such as shared access to mutable state."


*** intriguing things from the past:
**** Logo
  - lisp without parenthesis!!
  - geared toward education
  - influenced smalltalk, scratch, etc.
  - MIT
  - https://en.wikipedia.org/wiki/Logo_(programming_language)


  
*** past langs:
**** Raku
  - *sounds too powerful for mere mortals..*
  - the Perl 6 branch
    - perl 5.36 is basically perl 7
    - this splintered the perl community
  - https://www.reddit.com/r/programming/comments/1neepdf/comment/ndo8b4k/
    - reason why no one uses it: unreadably dense, uses sigils?? lol
  - "i think Raku is a facinating hobby language - *taking a lot of the Ruby "optimised for joy" stuff to a whole different place (leaving a lot of the ruby simplicity and going for sheer raw power and brevity, at the expense of the learning curve and density)."*
  - **"Raku can call Ruby, Python, Perl, Brainfuck, Lua, C, C++, Go, Scheme (Guile, Gambit), and Rust"**
    - wtf..??
  - has concurrency!
  - seems to have a tragic dev story, like crystal

**** ActionScript
  - succeeded by [haxe]
    - Haxe feels very close to ActionScript in both syntax and features, and really just made the perfect replacement for it, so, there's no need for this now, but good to note for history's sake
      - as it turns out, Nicholas (the maker of Haxe) wrote the compiler for ActionScript 2 :o ...now it all makes sense..!
  - thanks to Flash and it's game engines FlashPunk and Flixel, i was able to make my first *little* games with them! :)
  - **to this day, that was the best game dev experience i've ever had: pure code-only _light-weight scripting_ <3**
  - *my first love, leading me to Haxe*


*** history:
**** rexx
  - ??
  - "Rexx has a simple beauty to it, like Python from 1996"

**** tcl
  - "a scripting language for Unix-like environments, popular in the 1990s for creating GUI applications."
  - "tcl seeems incredible, surely a predecessor to ruby from 1988!" :o
    - "every type can be treated as a string" :o
    - added object-oriented features in 2012
**** eiffel
  - ??
**** ada
  - iirc used in critical systems like military software?
    - maybe focus on memory-safety and fault-tolerance?

**** pascal/delphi
  - ??
  - people seem to have fond memories about this one.. or perhaps using this as the first lang..

**** BASIC
  - "the java of it's time"
    - because Bill Gates sold BASIC to nearly every platform during the 80's (Commodore, Atari, Apple, etc.)
  - https://github.com/wls/Wumpus.bci/blob/master/wumpus.bci
    - 'let' keyword for dynamic types?? :o
  - surprisingly simple and readable, almost like it was specifically made for simple game programming! :o
  - many people cite this an their first prgramming language as a child

  - "Visual Basic for Applications, an extension language specifically for Microsoft Office applications."??

**** simula
  - Simula 67 introduced objects, classes, inheritance and subclasses, virtual procedures, coroutines, and discrete event simulation, and featured garbage collection.
  - the first "object-oriented" language (mere classes), leading to c++/java/object pascal/etc.

***** simula methods vs small-talk messaging:
  - The difference between these two concepts is in how the code referenced by the method or message name is executed. In a Simula-style language, the method name is in most cases bound to a section of code in the target class by the compiler. *In Smalltalk (and smalltalk-like Objective-C), the target of a message is resolved at runtime, with the receiving object itself interpreting the message...A consequence of this is that the message-passing system has no type checking. The object to which the message is directed — the receiver — is not guaranteed to respond to a message, and if it does not, it raises an exception.*
    - https://en.wikipedia.org/wiki/Objective-C#Messages

**** COBOL
  - ??
  - third oldest, has decimal arithmetic


**** hardware-based languages
Commodore64 (c64)
  - https://github.com/lvcabral/retaliate64/blob/master/source/gameData.asm
  - everything is a "co-routine"
  - three-letter terse commands make it feel closer to asssembly

assembly
  - each platform probably has it's own assembly language and assembler
  - https://github.com/Herringway/ebsrc
    - re-creation of earthbound in SNES's assembly
  
https://github.com/flipacholas/Architecture-of-consoles/
  - console architectures




** meh, not interested

*** specialized langs
**** fortran
  - *oldest language, and still in use!!*
  - used for number crunching (especially in academia research)
    - can see it used in numpy!


*** languages created by and for their own corporate products (Sun/Java): or products of their own corporate greed (Apple and Microsoft):
  - **avoid these** unless you must make products on their devices
    - and even then, you can usually get by, by generating C code

**** microsoft / .NET / CLR langs
  - for the same reasons as java, i see no reason to use these..
  - no way for native compilation nor manual-memory-management
    - *UPDATE: finally added a native compiler in 2024*
      - far far too late..
    - though "managed-code" may be enough..?
  - *like a newer java/jvm..*
    - *microsoft is better than apple, but java was the original and open-source*

***** C#
  - *"Microsoft's Java": Java EE = ASP.NET, Java VM (JVM) = .NET CLR, etc. As vomit-inducing that may sound, it feels much better than the java world* (partly due to eclipse ide sucking)
  - mighty mighty C#... along with it's .NET framework and Visual Studio, is really tough to beat for general-use, but boring, and limited by it's java-like bytecode\VM\GC implementation
    - **all of it's garbage collector implementations cause game to stutter when it sweeps up memory**
  - PROBLEM: no open-source way for cross-platform compilation
    - UPDATE: not until 2023 did FNA utilize NativeAOT to compile to consoles
    - unity's il2cpp
     - not open-source
       - though people have de-compiled this..
    - new aot compiler (2022)
     - clr -> platform (as of 2025: iOS experimental, no android, no consoles--maybe switch..)
       - https://fna-xna.github.io/docs/appendix/Appendix-B%3A-FNA-on-Consoles/
         - seems possible, hmm..
           - https://mastodon.social/@noelfb/109615790903279510
             - Noel of Celeste tweets in january 2023
  - solid game frameworks: *Unity, MonoGame/FNA*
  - solid web frameworks/tech: entity, razor, blazor (asp.net before it)
    - all of these feel like clunky hacks.. not elegant at all, fighting against the vm/language, and all very microsofty
  - frameworks for cross-platform apps have sucked for it since the beginning. They were limited to windows (winforms, wpf, etc.), and so newer open-source cross-platform frameworks came out (Avalonia, Uno, ASP.core). ASP.NET, the main web-app framework sucked for a long time allowing others to gain popularity until ASP.core came out, and even now, Blazor may be better
    - https://elixirforum.com/t/phoenix-vs-asp-net-core-performance/3599/8
      - describes the many reasons why even ASP.core is not the best for web
  - *solid feature-set* for the language, the standard library (System, IO, etc.), and the .NET library
    - basically C# v3 (in 2007) set the standards for high-level languages with lambda expressions, anonymous functions, and LINQ via .NET, etc. (during my first programming job!), and didn't add much until v7 (in 2017) when it added pattern matching, tuples, local functions, etc., but that's okay as they are working on all three things: a language, a library, and a tool-set. By C# v10 now, the features are *overwhelming!*. There's really nothing to complain about here.
  - slowwww progression:
    - it wasn't until 2014 it began to be **open-source cross-platform**: ".NET core", and even longer to eventually become the main .NET framework
    - **didnt have a native compiler until 2024!! (.NET 8)**
  - *despite supporting many languages, only a few have held up: C#, F#, and some variant of C++.* D lost in the language wars.
  - always had a compiled approach instead of scripting, making it less popular in the web-dev world, which made it even better, as it keeps the serious native big game/app devs away from the horrendous temporal javascript/electron/html5 web-dev world
  - Microsoft, and very much *feels* like Microsoft: *heavy*: heavy dev environment (visual studio ide until code was released), heavy libraries, clunky standard coding convention, etc., yet very easy to read/understand coming from C-like languages
  - **after using this, it feels like there's really no reason to ever use a scripting (dnyamically-typed, interpreted) language again, or one that doesn't provide ide-integrated debugging, reflection, etc.**
  - has contemporary **scripting** solutions!!?? :o :O
    - Rosylyn compiler, csscript, dotnet-script
  - https://www.nuget.org/packages/MonoGame.Framework.WpfInterop/ - LOL, amazing! WPF UI with MonoGame behind it
  - nuget package library


TODO: merge with above
  ## not really server-side, but it's possible to build web apps!
C#
  - **through ASP.NET Core, can build cross-platform apps (including web** via WebAssembly)
    - this makes it a great choice, competing with not just web apps, but Google's Flutter, and even simple game-like apps.
  - Avalonia framework
    - like Flutter, but with C#/.NET/VS :o
  - Uno framework
    - like Flutter, a little different in implementation, more mobile-oriented, including hot-reloading :o
  - for a long time this only worked with Windows servers (IIS), thus making it less popular, but since ASP.NET *Core* in around 2015, it has since then become open-source, cross-platform (along with VS Code!), making MicroSoft look much better to the dev communities than both Google and Apple!
  - the con of this is that you need a solid development environment: the current version of Visual Studio (not VS Code), probably a Windows IIS server(??), and still need to compile the code, build it, then deploy it, making the entire build process far more cumbersome compared to the common server-side langugaes, where you can just go in with a terminal, edit some code, 'n run it all via CLI
  - however, **for big, serious projects, it's worth the powerful language (C#), framework (.NET), and environment (VS), all of which are perhaps considered some of the best**
  - C# also has one of the biggest dev communities

***** F#
  - conclusion: OCaml is just a better choice, and still progressing, though slowly, and niche
  - Microsoft's OCaml in the .NET world
    - "*You can stay in pure F# until you need to use objects in the .NET framework. Which is to say that it will happen quite often.* There are times where it will feel like there is a little impedance mismatch like when you have to account for the difference between statements and expressions."
  - **really well-regarded 'n much-loved, except that there isn't much use for it in the current state of language choices**
  - **can also generate javascript and gpu code**
  - seems to have forged it's own path over time..
    - though, there used to be a ML compatibility bit to the compiler..
  - https://www.reddit.com/r/ocaml/comments/m634t8/thoughts_onexperiences_with_f/

***** Boo!
  - lol, fail-sauce!


  



**** sun / oracle / Java / JVM langs
  - though open-source, this certainly feels worse than microsoft..
  - never was interested in this, just feels archaic.. from dev tools to *verbose syntax* to frameworks.. everything!
  - java came up because of cross-platform VM and marketing
  - **VM however limits the entire eco-system** though, *it is the most performant VM ever* (along with javascript and BEAM)
    - monstrous VM, must be millions LOC!
    - surely has great JVM interpreters though..
    - *Clojure is a special exception, as it's just a lisp piggy-backing on the VM's tech, and Clojurescript to avoid/transpile javascript*
      - see [lisp] for entry on closure
      - still, seems like a ugly hack. Better to go the pure common lisp route!
***** (Clojure)
- see [[lisp]]
***** YES Scala
  - "java, but good" - doom-emacs config file
  - basically a(nother?) replacement for Java: interops with Java, compiles down to JVM byte-code
  - much loved/thankful by the java folks
  - *resembles ruby* (when it's not busy being constrained to functional paradigm..)
  - *just as featureful and powerful as most of the newer contemporary lanugages*
  
***** Kotlin
- "a better, slicker, java(script)" - doom-emacs config file
- *TODO: why not use Scala? too functional?*
- originally developed by JetBrains (the IDE maker), but the language eventually was chosen by Google to be the main language for Android app devs
  - hence it's better designed than google's other languages
  
***** RIP Groovy
  - kotlin killed it, along with bad tooling (editor integration, etc.)
    - kotlin also allows creating DSLs
  - "Java-syntax-compatible object-oriented programming language for the Java platform. It is both a static and dynamic language with features similar to those of Python, Ruby, and Smalltalk. It can be used as both a programming language and a scripting language for the Java Platform"
  - "Most valid Java files are also valid Groovy files. Although the two languages are similar, Groovy code can be more compact, because it does not need all the elements that Java needs. This makes it possible for Java programmers to learn Groovy gradually by starting with familiar Java syntax before acquiring more Groovy programming idioms."
    - huh, sounds cool..! sounds like just what the JVM world needs!
    - yep, most poeple seem to call it mostly syntactic sugar
  - gradle (build tool)

***** Java
  - PERSONAL NOTE: this is a world i've seem to have avoided, just out of taste... i think this is because when i started, it had a god-awful IDE compared to C++'s Visual Studio: i had to use Eclipse, which was garbage that unfortunately couldn't be collected :/
  - C/C++ power with a garbage collector/VM
  - frameworks include: *LibGDX*... (TODO: any others..??)
  - the vibe i get is strange... there seems to be only an old cult that like it, one that's *business-class or enterprise-class*
  - a good comparison between C++'s pointers and Java's magic
    - https://stackoverflow.com/questions/1750106/how-can-i-use-pointers-in-java#1750197
  - no header files!
  - very heavily object-oriented (not smalltalk either), contending with C++ during the OO era
    - object prototypes
    - lots of interfaces
  - adds lambdas (maybe this was added later on..)
  - *can interop with C through JNI (java native interface)*
    - heard it's not so pretty
    - however, now looking at it again, it's strange that this isn't used more! It looks like a much neater version of C++, like a pre-cursor to C#.
  - *like an early C#, it's similarly bulky, with interfaces, tons of classes, project files, and just making it feel like the opposite of the freedom of a simple scripting language: the opposite of ruby*
    - TODO: *modules/class seem like 5 folder deep??*
      - *maybe modules/classes are tied to folders??*
  - Sun/Oracle






**** apple
  - the worst corporation when it comes to software
    - also the worst dev experience (tools, processes, policies, etc.)
    - *i'll stop using their products because of this..*

***** Swift
  - NOTE: just never picked-up, no enterprise stability, and shitty tooling
    - https://www.reddit.com/r/swift/comments/1hqh5m3/why_isnt_swift_more_mainstream/
      - https://www.reddit.com/r/swift/comments/1hqh5m3/comment/m4pvgs9/
      - https://www.reddit.com/r/swift/comments/1hqh5m3/comment/m4pywp3/
        - basically, apple doesn't have a grassroots community around their lang, and apple themselves don't care about anything other than their own products
    - "For Swift to gain the popularity it needs to go through all the steps .NET went through in the last 9 years or so and perhaps a bit more since the existing .NET's userbase just naturally transitioned from Windows ecosystem towards what everyone else is using."
  - Apple's replacement for god-forsaken Objective-C
    - they still kept the old crap: Apple Foundational Library (NSobject, etc.)
  - *looks really good actually, simple yet powerful, like Rust but with less complexity, too bad it's controlled by Apple!*
  - **manual memory management / no garbage collector / no run-time**
    - reference counting
    - rust-like borrow-checker
  - interops with C and more recently (v5.3) C++
    - deep interop thanks to llvm, down to inline functions
  - cross-compiler binary to everything similar to go and rust
  - macros
  - probably has extremely good interopability between C/C++/Obj-C
  - strangely open-source (obviously made for Apple's own products, yet open-source to take from the open-source world)
    - **advertises to be cross-platform... but, what's the point when all of Apple's frameworks are closed products?..**
      - https://www.reddit.com/r/rust/comments/180fsxk/swift_vs_rust/
        - Apple's strict controls prevent true open-source community development
        - "I love Swift, to me it's a nicer, friendlier version of Rust. The syntax looks better, it has more words and fewer sigils, parameter labels make some API calls look really nice, too. But I simply can't use it for anything I do, and this is true for most developers out there."
      - https://dev.to/rhymu/swift-vs-rust-an-overview-of-swift-from-a-rusty-perspective-18c7
    - "core libraries" seem to be the same as .NET core libraries, probably followed Microsoft's footsteps, but *lacks the game-making and huge C#/.NET communities*
    - https://www.swift.org/core-libraries/
    - https://www.swift.org/about/
      - "One of the most exciting aspects of developing Swift in the open is knowing that it is now free to be ported across a wide range of platforms, devices, and use cases.

        Our goal is to provide source compatibility for Swift across all platforms, even though the actual implementation mechanisms may differ from one platform to the next."
  - also, **like Google, Apple sucks with community / documentation / etc. A lot of power really comes from open-source popularity...**
  - it forces you to name parameters in function calls, which makes code way more readable: attack(enemy: koopa, dmg: 1), *maybe still uses message-passing??*
  - Apple
    - *started propietary, then turned open-source*
      - this really affected it's adoption
      - only one year later though..

  https://www.youtube.com/watch?v=tzt36EGKEZo
    - miguel de icaza (the maker of mono runtime) goes over the benefits of swift over c#
      - great compiler that prevents a lot of errors
      - mutable and immutable arrays/lists
      - long-term vision is to aim for actors
        - classes with their state completely isolated
          - data flows via "sendable" data (thread-safe)
          - only one thread can run inside actor code at a time. Other threads must wait in line. Plus, it's guaranteed by the compiler
      - azul has a pauseless garbage collector for java, sold to big enterprises
      - tried to add reference-counting to .NET, but due to "inner-pointers", by design could not implement it

***** Objective-C
  - *NIGHTMARES*
    - made me stop programming for 10 years
  - shouldn't even be mentioned with small-talk
    - only took the message passing concept, to C, thus leaving out all the fun and magic of a dynamic run-time
  - https://www.reddit.com/r/ObjectiveC/comments/4j2dy7/comment/d333oio/





* stackoverflow's most admired/desired tech
this is a great way to find good pop tech

2024:
https://survey.stackoverflow.co/2024/technology#admired-and-desired
**rust, elixir, zig**
python, typescript, go, kotlin, swift, clojure, etc. are all about the same

**postgresql**

hetzner (cloud platform)

**phoenix** > (by a wide margin) > asp.net core, svelte, htmx, astro

**rust** (for embedded) (no competition!)

docker, **godot**, vite, bun, pacman, nix

markdown, **github discussions**, **obsidian**, **linear (docs)**

**signal**, **matrix**, **discord**, slack

**chatgpt**, **github copilot**, vs studio intellisense


* very subjective and unnecessary stuff

** langauge syntax comparison
compare languages' syntax by reading them (and piecing together the best syntax ideas)

but do note: it's the language's capabilites that matter, not it's snytactical beauty

https://learnxinyminutes.com/

https://hyperpolyglot.org
  - compare syntax between families of languages

good examples:
aim for 2d space shooter classes

todo:
crystal
scala
haxe

C
  - pacman, single-header-style
    - https://github.com/floooh/pacman.c/blob/main/pacman.c
      - uses sokol
      
zig
  - same pacman implementation as above (but in zig)
    - https://github.com/floooh/pacman.zig/blob/main/src/pacman.zig
  - https://github.com/ratfactor/zigish/blob/main/src/main.zig
  - https://github.com/tomhoule/zig-diff/tree/main/src
  - https://github.com/Kiakra/Alka/blob/master/examples/example_shooter_game/src/game.zig

ruby
  - https://github.com/benbalter/jekyll-optional-front-matter/blob/main/lib/jekyll-optional-front-matter/generator.rb
  
elixir
  - https://github.com/elixirkoans/elixir-koans
    - based off ruby koans

rust
  - https://github.com/rsaihe/zenith/tree/main/src/game
  - https://github.com/naodroid/bevy_game_tutorial
  - https://github.com/grzi/scion/tree/main/examples
  
OCaml
  - https://github.com/HaxeFoundation/haxe/blob/development/src/core/tOther.ml
    - brain-exploding example of Haxe's compiler


  




** language execution speed tier list (guestimates)
just a very very very broad gut feeling, lol

note: benchmarks are usually impractical, only exacerbating very specific differences

*** tier 1:
  - manual memory management
  - compiles to native machine code, see [[systems langs]]
  - no difference here really, just depends on the programmer's ability
    - though, Rust's memory-management implementation does have it's trade-offs..

**C** (clang > gcc)
Zig/V/Odin/etc.
**Jai** (native, llvm)

(Chapel) (llvm or C, parallel)
(Fortran)

C++ (clang++ > g++)
**Rust**
Swift (llvm, reference-counting or borrow-checker)


*** tier 2:
  - garbage-collected
  - native compilation or generate C
  - fully-featured / general-use langs

Go (native)
**common lisp (sbcl/native)** - crazy optimization for how powerful this language is..
**scheme (chez/native)**
  
**Julia** (llvm-ir?) - crazy fast for a complex dynamic lang..
Crystal (llvm-ir) - PROBLEM: extremely slow compile times (default, no flags) even for the most trivial hello world code

**Haxe** (c or c++, with clang/llvm optional)
**Nelua** (c)
Nim (c/clang/llvm)

lisp (gambit/c)

C# (aot/native?)
D?
(Haskell?) - functional, and fast??
**OCaml** - suprising for a (impure) functional lang! updated to a great generational garbage collector
Dart (dart2native) - under-rated, without the corporate bloat
Mojo

*** tier 2.5:
  - though not natively-compiled, their VMs have had so much work and money put into it that it performs just as well
  - requires vm ("runtime") to run it
    - also requires time (a second?) to startup the vm

Java (JVM) - *fastest vm*
  - Scala, Kotlin, Clojure, etc. JVM langs
  - truffleruby
  - jRuby
C# (CLR)
  - F#.. are there any other CLR langs..??

*** tier 3:
  - very complex, contemporary bytecode/vm JIT implementations written by gods
  - **NOTE: many consoles and iOS don't allow JIT compilers**

**Julia** (JIT, but can AOT) - how the eff... as fast as JS?? NOTE: very slow startup times, and specific to simple, repetitive computations (number operations, etc.), which is what most benchmarks usually are..

JS (bun, node) - surely the *most complex vm* in terms of optimization..??

*Lua (LuaJIT -j) - the JIT that set the standard*

**Haxe (hashlink, JIT)** - probably below dart, but fuck dart, and google too!
Dart (JIT, also has AOT) - surprisingly fast, or maybe not.. since it's google
(python/pypy and ruby/truffleruby would go here but are impractical)

(adds dynamic run-time / checking)
*dragonruby* - ?? further optimizations..?? "an order of magnitude slower than LuaJIT"
*mRuby* - ?? it should be faster than ruby, as it discards certain features, and uses bytecode..

**Elixir** (BEAM) - TODO: particularly bad for simple CPU tasks used in benchmarks (slow startup time?) but note: the magical concurrency that occurs in BEAM puts it on top of most dynamic languages, especially when it come to real applications, without having to hand-write concurrency structures

*Ruby (YJIT, 3.3)*
PHP - opcode/vm-like runtime, surprisingly slow.. probably ranked higher..
(Pascal?)

Scheme (Chez) - still as slow as ruby JIT?? something must be wrong here..

*** tier 4:
  - standard interpreted bytecode/vm impementations for dynamic langs
    - it gets hazy where it's interpreted and where it uses a vm
  - the differences here can be much bigger in this tier, but by 2024, they are all about the same, with python about 2x slower than the others

**Lua (LuaJIT -joff) - still the fastest interpreter too!**
Racket

**Wren** - intentionally written simply, and still performs really well too
Clojure (Babashka interpreter)
**Ruby** (3.0, CRuby/standard impl) - magical runtime by Japan. suprising for such a complex langauge. very different from the early versions
Lua (5.4) - the LuaJIT guy isn't too happy about this..

Python3 (CPython/standard impl) - slow, TODO: but i don't understand why..

*** tier 5+:
  - quite a gap between tier 4
Tcl
Perl - slowww

https://github.com/jabbalaci/SpeedTests?tab=readme-ov-file


https://github.com/kostya/benchmarks?tab=readme-ov-file
  - test by writing interpreter for brainfuck lang

https://muxup.com/2023q2/updating-wrens-benchmarks
  - update bnechmark of simple standard interpreters

https://benchmarksgame-team.pages.debian.net/benchmarksgame/
  - a joke, and hard to read, because it's more of a competition in which people upload crazy optimized programs that use multiple-cores/threads, but you can kinda see the limits and means using the simple implementations

https://github.com/attractivechaos/plb2
  - someone's benchmarks

https://wren.io/performance.html






* resources
** the opinions of more experienced programmers
*** Jon Blow's opinion
https://www.youtube.com/watch?v=y2Wmz15aXk0
  - **the idea of using a scripting language in a game was a failed experiment**

https://www.youtube.com/watch?v=klE9bzWJbHc
  - video of some millenial streamer that tries jai, but it works
  
https://www.youtube.com/watch?v=baClkzcfxu0
  - jai > zig from the same streamer

*** Robert's opinion
Robert has ported CrossCode to every popular platform, including *two generations of consoles(!)*, in addition to writing a JS AOT compiler, a super-powered low level framework (Kha), and basically the next SDL (Kinc)

Lisp, no language ever been so simple yet so powerful, contemporary languages (as of 2022) still have not caught up, and macros are easier to write

Smalltalk, most readable language, you can alter *any* part of it while it's running making a killer dev experience

Java had good marketing, otherwise, it stole from Smalltalk (VM, object-oriented) and dumbed down the object-oriented part from true objects to mere class prototypes

Basic was the Java of it's time

*** Zeta's opinion
Zeta has written: a game engine on top of Robert's Kinc lib, and is now writing an ARM assembler (for Hashlink), and is tinkering with writing an OS

Java is bad
C# is like Java owned but by Microsoft, and thus doubly bad
C is good
Haxe is very good
Rust is great

** good reads
https://www.reddit.com/r/Zig/comments/1c7s0pm/odin_vs_zig_for_a_hobby_project_crossplatform/
  - good info on zig and odin

https://ziglang.org/learn/why_zig_rust_d_cpp/
  - a good little critique other systems languages (and how to learn from them)

https://floooh.github.io/2020/08/23/sokol-bindgen.html
  - creator of sokol tackles C api language binding generation


## info extraction
https://blog.back4app.com/server-side-programming-languages/
  - a pretty simple and good summary of the popular languages (although, no haxe :( )
  
https://community.haxe.org/t/how-does-haxe-hxcpp-performance-compare-to-writing-c-c/460

https://www.reddit.com/r/gamedev/comments/1edn03/lua_angelscript_haxe_c_java_and_others_which_do/
  - shares my conundrum: an indie dev trying to choose a language environment, and it seems, even 8 years ago C#/MonoGame was still the way to go
  
https://www.reddit.com/r/ruby/comments/5c1prl/ruby_vs_python/
  - always good to gather some real thought from real people
  
https://blog.discord.com/using-rust-to-scale-elixir-for-11-million-concurrent-users-c6f19fc029d3
** other crap

https://www.reddit.com/r/ProgrammingLanguages/comments/10hu5md/why_is_zig_so_much_more_successful_than_crystal/
      - many great comments on the state of languages
      - basically, as languages came out, users flocked toward them, in particular: go, rust, elixir. Any language after them would have much catching up to do.


https://github.com/learn-anything/programming-languages#multi-paradigm
  - ??
  
https://www.youtube.com/watch?app=desktop&v=XZ3w_jec1v8
  - economics of programming languages
  - very wholesome talk by the maker of elm lang
  


https://www.reddit.com/r/webdev/comments/tisrh5/comment/kugqpis/
  - C# vs kotlin use cases

---

https://www.atatus.com/blog/rust-vs-golang/
  - TODO: ??

---

https://www.youtube.com/watch?v=klE9bzWJbHc
  - video of some millenial streamer that tries jai, but it works
=======
check SO yearly surveys
  - https://insights.stackoverflow.com/survey/2021#technology
  - but beware, this only covers most popular stuff, and is extremely web-oriented and C#/.NET-oriented; little to nothing for specialities like game programming or quality indie apps

---
ref:
https://madnight.github.io/githut/#/pull_requests/2023/2
https://github.com/dwyl/learn-elixir/issues/102
https://www.reddit.com/r/elixir/comments/zd9o07/comparing_phoenix_to_rails_in_december_2022/
https://www.quora.com/Is-learning-the-Phoenix-web-framework-easier-for-experienced-Ruby-on-Rails-developers
  - a great answer about thinking in the way of Elixir is *simpler*



*** from another file to merge
todo:
clojure-like repl:
https://www.reddit.com/r/ruby/comments/10i6pr7/is_parallel_threading_never_going_to_be_a_thing/
https://github.com/clojure-emacs/cider/discussions/3422
https://www.reddit.com/r/Clojure/comments/sm80ed/why_is_clojures_repl_better_than_other_dynamic/



ref:
https://madnight.github.io/githut/#/pull_requests/2023/2
https://github.com/dwyl/learn-elixir/issues/102
https://www.reddit.com/r/elixir/comments/zd9o07/comparing_phoenix_to_rails_in_december_2022/
https://www.quora.com/Is-learning-the-Phoenix-web-framework-easier-for-experienced-Ruby-on-Rails-developers
  - a great answer about thinking in the way of Elixir is *simpler*











